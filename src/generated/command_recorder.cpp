
/***************************************************************************
 *
 * Copyright (C) 2021 Google Inc.
 * Copyright (c) 2023-2024 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * *** ---- WARNING! ----
 * ***   THIS FILE IS GENERATED - DO NOT EDIT
 * ***   Update source file command_recorder_generator.py for modifications
 * *** ---- WARNING! ----
 *
 ****************************************************************************/

// NOLINTBEGIN

#include <iomanip>
#include <sstream>

#include "command_common.h"
#include "command_recorder.h"

// Declare CopyArray template functions. We need this declaration since the
// templates call each other and we don't have control over the order of the
// definitions.

template <>
uint8_t* CommandRecorder::CopyArray<uint8_t>(const uint8_t* src, uint64_t start_index, uint64_t count);
template <>
VkExtent2D* CommandRecorder::CopyArray<VkExtent2D>(const VkExtent2D* src, uint64_t start_index, uint64_t count);
template <>
VkExtent3D* CommandRecorder::CopyArray<VkExtent3D>(const VkExtent3D* src, uint64_t start_index, uint64_t count);
template <>
VkOffset2D* CommandRecorder::CopyArray<VkOffset2D>(const VkOffset2D* src, uint64_t start_index, uint64_t count);
template <>
VkOffset3D* CommandRecorder::CopyArray<VkOffset3D>(const VkOffset3D* src, uint64_t start_index, uint64_t count);
template <>
VkRect2D* CommandRecorder::CopyArray<VkRect2D>(const VkRect2D* src, uint64_t start_index, uint64_t count);
template <>
VkBaseInStructure* CommandRecorder::CopyArray<VkBaseInStructure>(const VkBaseInStructure* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkBaseOutStructure* CommandRecorder::CopyArray<VkBaseOutStructure>(const VkBaseOutStructure* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkBufferMemoryBarrier* CommandRecorder::CopyArray<VkBufferMemoryBarrier>(const VkBufferMemoryBarrier* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkDispatchIndirectCommand* CommandRecorder::CopyArray<VkDispatchIndirectCommand>(const VkDispatchIndirectCommand* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkDrawIndexedIndirectCommand* CommandRecorder::CopyArray<VkDrawIndexedIndirectCommand>(
    const VkDrawIndexedIndirectCommand* src, uint64_t start_index, uint64_t count);
template <>
VkDrawIndirectCommand* CommandRecorder::CopyArray<VkDrawIndirectCommand>(const VkDrawIndirectCommand* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkImageSubresourceRange* CommandRecorder::CopyArray<VkImageSubresourceRange>(const VkImageSubresourceRange* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkImageMemoryBarrier* CommandRecorder::CopyArray<VkImageMemoryBarrier>(const VkImageMemoryBarrier* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkMemoryBarrier* CommandRecorder::CopyArray<VkMemoryBarrier>(const VkMemoryBarrier* src, uint64_t start_index,
                                                             uint64_t count);
template <>
VkPipelineCacheHeaderVersionOne* CommandRecorder::CopyArray<VkPipelineCacheHeaderVersionOne>(
    const VkPipelineCacheHeaderVersionOne* src, uint64_t start_index, uint64_t count);
template <>
VkAllocationCallbacks* CommandRecorder::CopyArray<VkAllocationCallbacks>(const VkAllocationCallbacks* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkApplicationInfo* CommandRecorder::CopyArray<VkApplicationInfo>(const VkApplicationInfo* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkFormatProperties* CommandRecorder::CopyArray<VkFormatProperties>(const VkFormatProperties* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkImageFormatProperties* CommandRecorder::CopyArray<VkImageFormatProperties>(const VkImageFormatProperties* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkInstanceCreateInfo* CommandRecorder::CopyArray<VkInstanceCreateInfo>(const VkInstanceCreateInfo* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkMemoryHeap* CommandRecorder::CopyArray<VkMemoryHeap>(const VkMemoryHeap* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryType* CommandRecorder::CopyArray<VkMemoryType>(const VkMemoryType* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceFeatures>(const VkPhysicalDeviceFeatures* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLimits* CommandRecorder::CopyArray<VkPhysicalDeviceLimits>(const VkPhysicalDeviceLimits* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryProperties* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties>(
    const VkPhysicalDeviceMemoryProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSparseProperties* CommandRecorder::CopyArray<VkPhysicalDeviceSparseProperties>(
    const VkPhysicalDeviceSparseProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProperties* CommandRecorder::CopyArray<VkPhysicalDeviceProperties>(
    const VkPhysicalDeviceProperties* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyProperties* CommandRecorder::CopyArray<VkQueueFamilyProperties>(const VkQueueFamilyProperties* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkDeviceQueueCreateInfo* CommandRecorder::CopyArray<VkDeviceQueueCreateInfo>(const VkDeviceQueueCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkDeviceCreateInfo* CommandRecorder::CopyArray<VkDeviceCreateInfo>(const VkDeviceCreateInfo* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkExtensionProperties* CommandRecorder::CopyArray<VkExtensionProperties>(const VkExtensionProperties* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkLayerProperties* CommandRecorder::CopyArray<VkLayerProperties>(const VkLayerProperties* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkSubmitInfo* CommandRecorder::CopyArray<VkSubmitInfo>(const VkSubmitInfo* src, uint64_t start_index, uint64_t count);
template <>
VkMappedMemoryRange* CommandRecorder::CopyArray<VkMappedMemoryRange>(const VkMappedMemoryRange* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkMemoryAllocateInfo* CommandRecorder::CopyArray<VkMemoryAllocateInfo>(const VkMemoryAllocateInfo* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkMemoryRequirements* CommandRecorder::CopyArray<VkMemoryRequirements>(const VkMemoryRequirements* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkSparseMemoryBind* CommandRecorder::CopyArray<VkSparseMemoryBind>(const VkSparseMemoryBind* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkSparseBufferMemoryBindInfo* CommandRecorder::CopyArray<VkSparseBufferMemoryBindInfo>(
    const VkSparseBufferMemoryBindInfo* src, uint64_t start_index, uint64_t count);
template <>
VkSparseImageOpaqueMemoryBindInfo* CommandRecorder::CopyArray<VkSparseImageOpaqueMemoryBindInfo>(
    const VkSparseImageOpaqueMemoryBindInfo* src, uint64_t start_index, uint64_t count);
template <>
VkImageSubresource* CommandRecorder::CopyArray<VkImageSubresource>(const VkImageSubresource* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkSparseImageMemoryBind* CommandRecorder::CopyArray<VkSparseImageMemoryBind>(const VkSparseImageMemoryBind* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkSparseImageMemoryBindInfo* CommandRecorder::CopyArray<VkSparseImageMemoryBindInfo>(
    const VkSparseImageMemoryBindInfo* src, uint64_t start_index, uint64_t count);
template <>
VkBindSparseInfo* CommandRecorder::CopyArray<VkBindSparseInfo>(const VkBindSparseInfo* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkSparseImageFormatProperties* CommandRecorder::CopyArray<VkSparseImageFormatProperties>(
    const VkSparseImageFormatProperties* src, uint64_t start_index, uint64_t count);
template <>
VkSparseImageMemoryRequirements* CommandRecorder::CopyArray<VkSparseImageMemoryRequirements>(
    const VkSparseImageMemoryRequirements* src, uint64_t start_index, uint64_t count);
template <>
VkFenceCreateInfo* CommandRecorder::CopyArray<VkFenceCreateInfo>(const VkFenceCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkSemaphoreCreateInfo* CommandRecorder::CopyArray<VkSemaphoreCreateInfo>(const VkSemaphoreCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkEventCreateInfo* CommandRecorder::CopyArray<VkEventCreateInfo>(const VkEventCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkQueryPoolCreateInfo* CommandRecorder::CopyArray<VkQueryPoolCreateInfo>(const VkQueryPoolCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkBufferCreateInfo* CommandRecorder::CopyArray<VkBufferCreateInfo>(const VkBufferCreateInfo* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkBufferViewCreateInfo* CommandRecorder::CopyArray<VkBufferViewCreateInfo>(const VkBufferViewCreateInfo* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkImageCreateInfo* CommandRecorder::CopyArray<VkImageCreateInfo>(const VkImageCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkSubresourceLayout* CommandRecorder::CopyArray<VkSubresourceLayout>(const VkSubresourceLayout* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkComponentMapping* CommandRecorder::CopyArray<VkComponentMapping>(const VkComponentMapping* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkImageViewCreateInfo* CommandRecorder::CopyArray<VkImageViewCreateInfo>(const VkImageViewCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkShaderModuleCreateInfo* CommandRecorder::CopyArray<VkShaderModuleCreateInfo>(const VkShaderModuleCreateInfo* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPipelineCacheCreateInfo* CommandRecorder::CopyArray<VkPipelineCacheCreateInfo>(const VkPipelineCacheCreateInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkSpecializationMapEntry* CommandRecorder::CopyArray<VkSpecializationMapEntry>(const VkSpecializationMapEntry* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkSpecializationInfo* CommandRecorder::CopyArray<VkSpecializationInfo>(const VkSpecializationInfo* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkPipelineShaderStageCreateInfo* CommandRecorder::CopyArray<VkPipelineShaderStageCreateInfo>(
    const VkPipelineShaderStageCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkComputePipelineCreateInfo* CommandRecorder::CopyArray<VkComputePipelineCreateInfo>(
    const VkComputePipelineCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkVertexInputBindingDescription* CommandRecorder::CopyArray<VkVertexInputBindingDescription>(
    const VkVertexInputBindingDescription* src, uint64_t start_index, uint64_t count);
template <>
VkVertexInputAttributeDescription* CommandRecorder::CopyArray<VkVertexInputAttributeDescription>(
    const VkVertexInputAttributeDescription* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineVertexInputStateCreateInfo* CommandRecorder::CopyArray<VkPipelineVertexInputStateCreateInfo>(
    const VkPipelineVertexInputStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineInputAssemblyStateCreateInfo* CommandRecorder::CopyArray<VkPipelineInputAssemblyStateCreateInfo>(
    const VkPipelineInputAssemblyStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineTessellationStateCreateInfo* CommandRecorder::CopyArray<VkPipelineTessellationStateCreateInfo>(
    const VkPipelineTessellationStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkViewport* CommandRecorder::CopyArray<VkViewport>(const VkViewport* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportStateCreateInfo* CommandRecorder::CopyArray<VkPipelineViewportStateCreateInfo>(
    const VkPipelineViewportStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationStateCreateInfo* CommandRecorder::CopyArray<VkPipelineRasterizationStateCreateInfo>(
    const VkPipelineRasterizationStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineMultisampleStateCreateInfo* CommandRecorder::CopyArray<VkPipelineMultisampleStateCreateInfo>(
    const VkPipelineMultisampleStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkStencilOpState* CommandRecorder::CopyArray<VkStencilOpState>(const VkStencilOpState* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkPipelineDepthStencilStateCreateInfo* CommandRecorder::CopyArray<VkPipelineDepthStencilStateCreateInfo>(
    const VkPipelineDepthStencilStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineColorBlendAttachmentState* CommandRecorder::CopyArray<VkPipelineColorBlendAttachmentState>(
    const VkPipelineColorBlendAttachmentState* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineColorBlendStateCreateInfo* CommandRecorder::CopyArray<VkPipelineColorBlendStateCreateInfo>(
    const VkPipelineColorBlendStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineDynamicStateCreateInfo* CommandRecorder::CopyArray<VkPipelineDynamicStateCreateInfo>(
    const VkPipelineDynamicStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkGraphicsPipelineCreateInfo* CommandRecorder::CopyArray<VkGraphicsPipelineCreateInfo>(
    const VkGraphicsPipelineCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPushConstantRange* CommandRecorder::CopyArray<VkPushConstantRange>(const VkPushConstantRange* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPipelineLayoutCreateInfo* CommandRecorder::CopyArray<VkPipelineLayoutCreateInfo>(
    const VkPipelineLayoutCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerCreateInfo* CommandRecorder::CopyArray<VkSamplerCreateInfo>(const VkSamplerCreateInfo* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkCopyDescriptorSet* CommandRecorder::CopyArray<VkCopyDescriptorSet>(const VkCopyDescriptorSet* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkDescriptorBufferInfo* CommandRecorder::CopyArray<VkDescriptorBufferInfo>(const VkDescriptorBufferInfo* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkDescriptorImageInfo* CommandRecorder::CopyArray<VkDescriptorImageInfo>(const VkDescriptorImageInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkDescriptorPoolSize* CommandRecorder::CopyArray<VkDescriptorPoolSize>(const VkDescriptorPoolSize* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkDescriptorPoolCreateInfo* CommandRecorder::CopyArray<VkDescriptorPoolCreateInfo>(
    const VkDescriptorPoolCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetAllocateInfo* CommandRecorder::CopyArray<VkDescriptorSetAllocateInfo>(
    const VkDescriptorSetAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetLayoutBinding* CommandRecorder::CopyArray<VkDescriptorSetLayoutBinding>(
    const VkDescriptorSetLayoutBinding* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetLayoutCreateInfo* CommandRecorder::CopyArray<VkDescriptorSetLayoutCreateInfo>(
    const VkDescriptorSetLayoutCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkWriteDescriptorSet* CommandRecorder::CopyArray<VkWriteDescriptorSet>(const VkWriteDescriptorSet* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkAttachmentDescription* CommandRecorder::CopyArray<VkAttachmentDescription>(const VkAttachmentDescription* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkAttachmentReference* CommandRecorder::CopyArray<VkAttachmentReference>(const VkAttachmentReference* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkFramebufferCreateInfo* CommandRecorder::CopyArray<VkFramebufferCreateInfo>(const VkFramebufferCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkSubpassDescription* CommandRecorder::CopyArray<VkSubpassDescription>(const VkSubpassDescription* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkSubpassDependency* CommandRecorder::CopyArray<VkSubpassDependency>(const VkSubpassDependency* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkRenderPassCreateInfo* CommandRecorder::CopyArray<VkRenderPassCreateInfo>(const VkRenderPassCreateInfo* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkCommandPoolCreateInfo* CommandRecorder::CopyArray<VkCommandPoolCreateInfo>(const VkCommandPoolCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkCommandBufferAllocateInfo* CommandRecorder::CopyArray<VkCommandBufferAllocateInfo>(
    const VkCommandBufferAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferInheritanceInfo* CommandRecorder::CopyArray<VkCommandBufferInheritanceInfo>(
    const VkCommandBufferInheritanceInfo* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferBeginInfo* CommandRecorder::CopyArray<VkCommandBufferBeginInfo>(const VkCommandBufferBeginInfo* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkBufferCopy* CommandRecorder::CopyArray<VkBufferCopy>(const VkBufferCopy* src, uint64_t start_index, uint64_t count);
template <>
VkImageSubresourceLayers* CommandRecorder::CopyArray<VkImageSubresourceLayers>(const VkImageSubresourceLayers* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkBufferImageCopy* CommandRecorder::CopyArray<VkBufferImageCopy>(const VkBufferImageCopy* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkClearColorValue* CommandRecorder::CopyArray<VkClearColorValue>(const VkClearColorValue* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkClearDepthStencilValue* CommandRecorder::CopyArray<VkClearDepthStencilValue>(const VkClearDepthStencilValue* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkClearValue* CommandRecorder::CopyArray<VkClearValue>(const VkClearValue* src, uint64_t start_index, uint64_t count);
template <>
VkClearAttachment* CommandRecorder::CopyArray<VkClearAttachment>(const VkClearAttachment* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkClearRect* CommandRecorder::CopyArray<VkClearRect>(const VkClearRect* src, uint64_t start_index, uint64_t count);
template <>
VkImageBlit* CommandRecorder::CopyArray<VkImageBlit>(const VkImageBlit* src, uint64_t start_index, uint64_t count);
template <>
VkImageCopy* CommandRecorder::CopyArray<VkImageCopy>(const VkImageCopy* src, uint64_t start_index, uint64_t count);
template <>
VkImageResolve* CommandRecorder::CopyArray<VkImageResolve>(const VkImageResolve* src, uint64_t start_index,
                                                           uint64_t count);
template <>
VkRenderPassBeginInfo* CommandRecorder::CopyArray<VkRenderPassBeginInfo>(const VkRenderPassBeginInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubgroupProperties* CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupProperties>(
    const VkPhysicalDeviceSubgroupProperties* src, uint64_t start_index, uint64_t count);
template <>
VkBindBufferMemoryInfo* CommandRecorder::CopyArray<VkBindBufferMemoryInfo>(const VkBindBufferMemoryInfo* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkBindImageMemoryInfo* CommandRecorder::CopyArray<VkBindImageMemoryInfo>(const VkBindImageMemoryInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevice16BitStorageFeatures* CommandRecorder::CopyArray<VkPhysicalDevice16BitStorageFeatures>(
    const VkPhysicalDevice16BitStorageFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryDedicatedRequirements* CommandRecorder::CopyArray<VkMemoryDedicatedRequirements>(
    const VkMemoryDedicatedRequirements* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryDedicatedAllocateInfo* CommandRecorder::CopyArray<VkMemoryDedicatedAllocateInfo>(
    const VkMemoryDedicatedAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryAllocateFlagsInfo* CommandRecorder::CopyArray<VkMemoryAllocateFlagsInfo>(const VkMemoryAllocateFlagsInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupRenderPassBeginInfo* CommandRecorder::CopyArray<VkDeviceGroupRenderPassBeginInfo>(
    const VkDeviceGroupRenderPassBeginInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupCommandBufferBeginInfo* CommandRecorder::CopyArray<VkDeviceGroupCommandBufferBeginInfo>(
    const VkDeviceGroupCommandBufferBeginInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupSubmitInfo* CommandRecorder::CopyArray<VkDeviceGroupSubmitInfo>(const VkDeviceGroupSubmitInfo* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupBindSparseInfo* CommandRecorder::CopyArray<VkDeviceGroupBindSparseInfo>(
    const VkDeviceGroupBindSparseInfo* src, uint64_t start_index, uint64_t count);
template <>
VkBindBufferMemoryDeviceGroupInfo* CommandRecorder::CopyArray<VkBindBufferMemoryDeviceGroupInfo>(
    const VkBindBufferMemoryDeviceGroupInfo* src, uint64_t start_index, uint64_t count);
template <>
VkBindImageMemoryDeviceGroupInfo* CommandRecorder::CopyArray<VkBindImageMemoryDeviceGroupInfo>(
    const VkBindImageMemoryDeviceGroupInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceGroupProperties* CommandRecorder::CopyArray<VkPhysicalDeviceGroupProperties>(
    const VkPhysicalDeviceGroupProperties* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupDeviceCreateInfo* CommandRecorder::CopyArray<VkDeviceGroupDeviceCreateInfo>(
    const VkDeviceGroupDeviceCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkBufferMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkBufferMemoryRequirementsInfo2>(
    const VkBufferMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count);
template <>
VkImageMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkImageMemoryRequirementsInfo2>(
    const VkImageMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count);
template <>
VkImageSparseMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkImageSparseMemoryRequirementsInfo2>(
    const VkImageSparseMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryRequirements2* CommandRecorder::CopyArray<VkMemoryRequirements2>(const VkMemoryRequirements2* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkSparseImageMemoryRequirements2* CommandRecorder::CopyArray<VkSparseImageMemoryRequirements2>(
    const VkSparseImageMemoryRequirements2* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFeatures2* CommandRecorder::CopyArray<VkPhysicalDeviceFeatures2>(const VkPhysicalDeviceFeatures2* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProperties2* CommandRecorder::CopyArray<VkPhysicalDeviceProperties2>(
    const VkPhysicalDeviceProperties2* src, uint64_t start_index, uint64_t count);
template <>
VkFormatProperties2* CommandRecorder::CopyArray<VkFormatProperties2>(const VkFormatProperties2* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkImageFormatProperties2* CommandRecorder::CopyArray<VkImageFormatProperties2>(const VkImageFormatProperties2* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageFormatInfo2* CommandRecorder::CopyArray<VkPhysicalDeviceImageFormatInfo2>(
    const VkPhysicalDeviceImageFormatInfo2* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyProperties2* CommandRecorder::CopyArray<VkQueueFamilyProperties2>(const VkQueueFamilyProperties2* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryProperties2* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties2>(
    const VkPhysicalDeviceMemoryProperties2* src, uint64_t start_index, uint64_t count);
template <>
VkSparseImageFormatProperties2* CommandRecorder::CopyArray<VkSparseImageFormatProperties2>(
    const VkSparseImageFormatProperties2* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSparseImageFormatInfo2* CommandRecorder::CopyArray<VkPhysicalDeviceSparseImageFormatInfo2>(
    const VkPhysicalDeviceSparseImageFormatInfo2* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePointClippingProperties* CommandRecorder::CopyArray<VkPhysicalDevicePointClippingProperties>(
    const VkPhysicalDevicePointClippingProperties* src, uint64_t start_index, uint64_t count);
template <>
VkInputAttachmentAspectReference* CommandRecorder::CopyArray<VkInputAttachmentAspectReference>(
    const VkInputAttachmentAspectReference* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassInputAttachmentAspectCreateInfo* CommandRecorder::CopyArray<VkRenderPassInputAttachmentAspectCreateInfo>(
    const VkRenderPassInputAttachmentAspectCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkImageViewUsageCreateInfo* CommandRecorder::CopyArray<VkImageViewUsageCreateInfo>(
    const VkImageViewUsageCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineTessellationDomainOriginStateCreateInfo*
CommandRecorder::CopyArray<VkPipelineTessellationDomainOriginStateCreateInfo>(
    const VkPipelineTessellationDomainOriginStateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassMultiviewCreateInfo* CommandRecorder::CopyArray<VkRenderPassMultiviewCreateInfo>(
    const VkRenderPassMultiviewCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiviewFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewFeatures>(
    const VkPhysicalDeviceMultiviewFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiviewProperties* CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewProperties>(
    const VkPhysicalDeviceMultiviewProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVariablePointersFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceVariablePointersFeatures>(
    const VkPhysicalDeviceVariablePointersFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProtectedMemoryFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryFeatures>(
    const VkPhysicalDeviceProtectedMemoryFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProtectedMemoryProperties* CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryProperties>(
    const VkPhysicalDeviceProtectedMemoryProperties* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceQueueInfo2* CommandRecorder::CopyArray<VkDeviceQueueInfo2>(const VkDeviceQueueInfo2* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkProtectedSubmitInfo* CommandRecorder::CopyArray<VkProtectedSubmitInfo>(const VkProtectedSubmitInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkSamplerYcbcrConversionCreateInfo* CommandRecorder::CopyArray<VkSamplerYcbcrConversionCreateInfo>(
    const VkSamplerYcbcrConversionCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerYcbcrConversionInfo* CommandRecorder::CopyArray<VkSamplerYcbcrConversionInfo>(
    const VkSamplerYcbcrConversionInfo* src, uint64_t start_index, uint64_t count);
template <>
VkBindImagePlaneMemoryInfo* CommandRecorder::CopyArray<VkBindImagePlaneMemoryInfo>(
    const VkBindImagePlaneMemoryInfo* src, uint64_t start_index, uint64_t count);
template <>
VkImagePlaneMemoryRequirementsInfo* CommandRecorder::CopyArray<VkImagePlaneMemoryRequirementsInfo>(
    const VkImagePlaneMemoryRequirementsInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSamplerYcbcrConversionFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerYcbcrConversionImageFormatProperties*
CommandRecorder::CopyArray<VkSamplerYcbcrConversionImageFormatProperties>(
    const VkSamplerYcbcrConversionImageFormatProperties* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorUpdateTemplateEntry* CommandRecorder::CopyArray<VkDescriptorUpdateTemplateEntry>(
    const VkDescriptorUpdateTemplateEntry* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorUpdateTemplateCreateInfo* CommandRecorder::CopyArray<VkDescriptorUpdateTemplateCreateInfo>(
    const VkDescriptorUpdateTemplateCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalMemoryProperties* CommandRecorder::CopyArray<VkExternalMemoryProperties>(
    const VkExternalMemoryProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalImageFormatInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalImageFormatInfo>(
    const VkPhysicalDeviceExternalImageFormatInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalImageFormatProperties* CommandRecorder::CopyArray<VkExternalImageFormatProperties>(
    const VkExternalImageFormatProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalBufferInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalBufferInfo>(
    const VkPhysicalDeviceExternalBufferInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalBufferProperties* CommandRecorder::CopyArray<VkExternalBufferProperties>(
    const VkExternalBufferProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceIDProperties* CommandRecorder::CopyArray<VkPhysicalDeviceIDProperties>(
    const VkPhysicalDeviceIDProperties* src, uint64_t start_index, uint64_t count);
template <>
VkExternalMemoryImageCreateInfo* CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfo>(
    const VkExternalMemoryImageCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalMemoryBufferCreateInfo* CommandRecorder::CopyArray<VkExternalMemoryBufferCreateInfo>(
    const VkExternalMemoryBufferCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExportMemoryAllocateInfo* CommandRecorder::CopyArray<VkExportMemoryAllocateInfo>(
    const VkExportMemoryAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalFenceInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalFenceInfo>(
    const VkPhysicalDeviceExternalFenceInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalFenceProperties* CommandRecorder::CopyArray<VkExternalFenceProperties>(const VkExternalFenceProperties* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkExportFenceCreateInfo* CommandRecorder::CopyArray<VkExportFenceCreateInfo>(const VkExportFenceCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkExportSemaphoreCreateInfo* CommandRecorder::CopyArray<VkExportSemaphoreCreateInfo>(
    const VkExportSemaphoreCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalSemaphoreInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalSemaphoreInfo>(
    const VkPhysicalDeviceExternalSemaphoreInfo* src, uint64_t start_index, uint64_t count);
template <>
VkExternalSemaphoreProperties* CommandRecorder::CopyArray<VkExternalSemaphoreProperties>(
    const VkExternalSemaphoreProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance3Properties* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance3Properties>(
    const VkPhysicalDeviceMaintenance3Properties* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetLayoutSupport* CommandRecorder::CopyArray<VkDescriptorSetLayoutSupport>(
    const VkDescriptorSetLayoutSupport* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderDrawParametersFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceShaderDrawParametersFeatures>(
    const VkPhysicalDeviceShaderDrawParametersFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan11Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Features>(
    const VkPhysicalDeviceVulkan11Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan11Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Properties>(
    const VkPhysicalDeviceVulkan11Properties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan12Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Features>(
    const VkPhysicalDeviceVulkan12Features* src, uint64_t start_index, uint64_t count);
template <>
VkConformanceVersion* CommandRecorder::CopyArray<VkConformanceVersion>(const VkConformanceVersion* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan12Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Properties>(
    const VkPhysicalDeviceVulkan12Properties* src, uint64_t start_index, uint64_t count);
template <>
VkImageFormatListCreateInfo* CommandRecorder::CopyArray<VkImageFormatListCreateInfo>(
    const VkImageFormatListCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkAttachmentDescription2* CommandRecorder::CopyArray<VkAttachmentDescription2>(const VkAttachmentDescription2* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkAttachmentReference2* CommandRecorder::CopyArray<VkAttachmentReference2>(const VkAttachmentReference2* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkSubpassDescription2* CommandRecorder::CopyArray<VkSubpassDescription2>(const VkSubpassDescription2* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkSubpassDependency2* CommandRecorder::CopyArray<VkSubpassDependency2>(const VkSubpassDependency2* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkRenderPassCreateInfo2* CommandRecorder::CopyArray<VkRenderPassCreateInfo2>(const VkRenderPassCreateInfo2* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkSubpassBeginInfo* CommandRecorder::CopyArray<VkSubpassBeginInfo>(const VkSubpassBeginInfo* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkSubpassEndInfo* CommandRecorder::CopyArray<VkSubpassEndInfo>(const VkSubpassEndInfo* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkPhysicalDevice8BitStorageFeatures* CommandRecorder::CopyArray<VkPhysicalDevice8BitStorageFeatures>(
    const VkPhysicalDevice8BitStorageFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDriverProperties* CommandRecorder::CopyArray<VkPhysicalDeviceDriverProperties>(
    const VkPhysicalDeviceDriverProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderAtomicInt64Features* CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicInt64Features>(
    const VkPhysicalDeviceShaderAtomicInt64Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderFloat16Int8Features* CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloat16Int8Features>(
    const VkPhysicalDeviceShaderFloat16Int8Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFloatControlsProperties* CommandRecorder::CopyArray<VkPhysicalDeviceFloatControlsProperties>(
    const VkPhysicalDeviceFloatControlsProperties* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetLayoutBindingFlagsCreateInfo* CommandRecorder::CopyArray<VkDescriptorSetLayoutBindingFlagsCreateInfo>(
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorIndexingFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingFeatures>(
    const VkPhysicalDeviceDescriptorIndexingFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorIndexingProperties* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingProperties>(
    const VkPhysicalDeviceDescriptorIndexingProperties* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetVariableDescriptorCountAllocateInfo*
CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountAllocateInfo>(
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetVariableDescriptorCountLayoutSupport*
CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountLayoutSupport>(
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* src, uint64_t start_index, uint64_t count);
template <>
VkSubpassDescriptionDepthStencilResolve* CommandRecorder::CopyArray<VkSubpassDescriptionDepthStencilResolve>(
    const VkSubpassDescriptionDepthStencilResolve* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDepthStencilResolveProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceDepthStencilResolveProperties>(
    const VkPhysicalDeviceDepthStencilResolveProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceScalarBlockLayoutFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceScalarBlockLayoutFeatures>(
    const VkPhysicalDeviceScalarBlockLayoutFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkImageStencilUsageCreateInfo* CommandRecorder::CopyArray<VkImageStencilUsageCreateInfo>(
    const VkImageStencilUsageCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerReductionModeCreateInfo* CommandRecorder::CopyArray<VkSamplerReductionModeCreateInfo>(
    const VkSamplerReductionModeCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSamplerFilterMinmaxProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceSamplerFilterMinmaxProperties>(
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkanMemoryModelFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceVulkanMemoryModelFeatures>(
    const VkPhysicalDeviceVulkanMemoryModelFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImagelessFramebufferFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceImagelessFramebufferFeatures>(
    const VkPhysicalDeviceImagelessFramebufferFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkFramebufferAttachmentImageInfo* CommandRecorder::CopyArray<VkFramebufferAttachmentImageInfo>(
    const VkFramebufferAttachmentImageInfo* src, uint64_t start_index, uint64_t count);
template <>
VkFramebufferAttachmentsCreateInfo* CommandRecorder::CopyArray<VkFramebufferAttachmentsCreateInfo>(
    const VkFramebufferAttachmentsCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassAttachmentBeginInfo* CommandRecorder::CopyArray<VkRenderPassAttachmentBeginInfo>(
    const VkRenderPassAttachmentBeginInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceUniformBufferStandardLayoutFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkAttachmentReferenceStencilLayout* CommandRecorder::CopyArray<VkAttachmentReferenceStencilLayout>(
    const VkAttachmentReferenceStencilLayout* src, uint64_t start_index, uint64_t count);
template <>
VkAttachmentDescriptionStencilLayout* CommandRecorder::CopyArray<VkAttachmentDescriptionStencilLayout>(
    const VkAttachmentDescriptionStencilLayout* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceHostQueryResetFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceHostQueryResetFeatures>(
    const VkPhysicalDeviceHostQueryResetFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTimelineSemaphoreFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreFeatures>(
    const VkPhysicalDeviceTimelineSemaphoreFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTimelineSemaphoreProperties* CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreProperties>(
    const VkPhysicalDeviceTimelineSemaphoreProperties* src, uint64_t start_index, uint64_t count);
template <>
VkSemaphoreTypeCreateInfo* CommandRecorder::CopyArray<VkSemaphoreTypeCreateInfo>(const VkSemaphoreTypeCreateInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkTimelineSemaphoreSubmitInfo* CommandRecorder::CopyArray<VkTimelineSemaphoreSubmitInfo>(
    const VkTimelineSemaphoreSubmitInfo* src, uint64_t start_index, uint64_t count);
template <>
VkSemaphoreWaitInfo* CommandRecorder::CopyArray<VkSemaphoreWaitInfo>(const VkSemaphoreWaitInfo* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkSemaphoreSignalInfo* CommandRecorder::CopyArray<VkSemaphoreSignalInfo>(const VkSemaphoreSignalInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceBufferDeviceAddressFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeatures>(
    const VkPhysicalDeviceBufferDeviceAddressFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkBufferDeviceAddressInfo* CommandRecorder::CopyArray<VkBufferDeviceAddressInfo>(const VkBufferDeviceAddressInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkBufferOpaqueCaptureAddressCreateInfo* CommandRecorder::CopyArray<VkBufferOpaqueCaptureAddressCreateInfo>(
    const VkBufferOpaqueCaptureAddressCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryOpaqueCaptureAddressAllocateInfo* CommandRecorder::CopyArray<VkMemoryOpaqueCaptureAddressAllocateInfo>(
    const VkMemoryOpaqueCaptureAddressAllocateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceMemoryOpaqueCaptureAddressInfo* CommandRecorder::CopyArray<VkDeviceMemoryOpaqueCaptureAddressInfo>(
    const VkDeviceMemoryOpaqueCaptureAddressInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan13Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan13Features>(
    const VkPhysicalDeviceVulkan13Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVulkan13Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan13Properties>(
    const VkPhysicalDeviceVulkan13Properties* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCreationFeedback* CommandRecorder::CopyArray<VkPipelineCreationFeedback>(
    const VkPipelineCreationFeedback* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCreationFeedbackCreateInfo* CommandRecorder::CopyArray<VkPipelineCreationFeedbackCreateInfo>(
    const VkPipelineCreationFeedbackCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderTerminateInvocationFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderTerminateInvocationFeatures>(
    const VkPhysicalDeviceShaderTerminateInvocationFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceToolProperties* CommandRecorder::CopyArray<VkPhysicalDeviceToolProperties>(
    const VkPhysicalDeviceToolProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>(
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePrivateDataFeatures* CommandRecorder::CopyArray<VkPhysicalDevicePrivateDataFeatures>(
    const VkPhysicalDevicePrivateDataFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkDevicePrivateDataCreateInfo* CommandRecorder::CopyArray<VkDevicePrivateDataCreateInfo>(
    const VkDevicePrivateDataCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPrivateDataSlotCreateInfo* CommandRecorder::CopyArray<VkPrivateDataSlotCreateInfo>(
    const VkPrivateDataSlotCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineCreationCacheControlFeatures*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineCreationCacheControlFeatures>(
    const VkPhysicalDevicePipelineCreationCacheControlFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryBarrier2* CommandRecorder::CopyArray<VkMemoryBarrier2>(const VkMemoryBarrier2* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkBufferMemoryBarrier2* CommandRecorder::CopyArray<VkBufferMemoryBarrier2>(const VkBufferMemoryBarrier2* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkImageMemoryBarrier2* CommandRecorder::CopyArray<VkImageMemoryBarrier2>(const VkImageMemoryBarrier2* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkDependencyInfo* CommandRecorder::CopyArray<VkDependencyInfo>(const VkDependencyInfo* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkSemaphoreSubmitInfo* CommandRecorder::CopyArray<VkSemaphoreSubmitInfo>(const VkSemaphoreSubmitInfo* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkCommandBufferSubmitInfo* CommandRecorder::CopyArray<VkCommandBufferSubmitInfo>(const VkCommandBufferSubmitInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkSubmitInfo2* CommandRecorder::CopyArray<VkSubmitInfo2>(const VkSubmitInfo2* src, uint64_t start_index,
                                                         uint64_t count);
template <>
VkPhysicalDeviceSynchronization2Features* CommandRecorder::CopyArray<VkPhysicalDeviceSynchronization2Features>(
    const VkPhysicalDeviceSynchronization2Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>(
    const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageRobustnessFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceImageRobustnessFeatures>(
    const VkPhysicalDeviceImageRobustnessFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkBufferCopy2* CommandRecorder::CopyArray<VkBufferCopy2>(const VkBufferCopy2* src, uint64_t start_index,
                                                         uint64_t count);
template <>
VkCopyBufferInfo2* CommandRecorder::CopyArray<VkCopyBufferInfo2>(const VkCopyBufferInfo2* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkImageCopy2* CommandRecorder::CopyArray<VkImageCopy2>(const VkImageCopy2* src, uint64_t start_index, uint64_t count);
template <>
VkCopyImageInfo2* CommandRecorder::CopyArray<VkCopyImageInfo2>(const VkCopyImageInfo2* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkBufferImageCopy2* CommandRecorder::CopyArray<VkBufferImageCopy2>(const VkBufferImageCopy2* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkCopyBufferToImageInfo2* CommandRecorder::CopyArray<VkCopyBufferToImageInfo2>(const VkCopyBufferToImageInfo2* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkCopyImageToBufferInfo2* CommandRecorder::CopyArray<VkCopyImageToBufferInfo2>(const VkCopyImageToBufferInfo2* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkImageBlit2* CommandRecorder::CopyArray<VkImageBlit2>(const VkImageBlit2* src, uint64_t start_index, uint64_t count);
template <>
VkBlitImageInfo2* CommandRecorder::CopyArray<VkBlitImageInfo2>(const VkBlitImageInfo2* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkImageResolve2* CommandRecorder::CopyArray<VkImageResolve2>(const VkImageResolve2* src, uint64_t start_index,
                                                             uint64_t count);
template <>
VkResolveImageInfo2* CommandRecorder::CopyArray<VkResolveImageInfo2>(const VkResolveImageInfo2* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubgroupSizeControlFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlFeatures>(
    const VkPhysicalDeviceSubgroupSizeControlFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubgroupSizeControlProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlProperties>(
    const VkPhysicalDeviceSubgroupSizeControlProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*
CommandRecorder::CopyArray<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>(
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceInlineUniformBlockFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockFeatures>(
    const VkPhysicalDeviceInlineUniformBlockFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceInlineUniformBlockProperties* CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockProperties>(
    const VkPhysicalDeviceInlineUniformBlockProperties* src, uint64_t start_index, uint64_t count);
template <>
VkWriteDescriptorSetInlineUniformBlock* CommandRecorder::CopyArray<VkWriteDescriptorSetInlineUniformBlock>(
    const VkWriteDescriptorSetInlineUniformBlock* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorPoolInlineUniformBlockCreateInfo* CommandRecorder::CopyArray<VkDescriptorPoolInlineUniformBlockCreateInfo>(
    const VkDescriptorPoolInlineUniformBlockCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTextureCompressionASTCHDRFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>(
    const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingAttachmentInfo* CommandRecorder::CopyArray<VkRenderingAttachmentInfo>(const VkRenderingAttachmentInfo* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkRenderingInfo* CommandRecorder::CopyArray<VkRenderingInfo>(const VkRenderingInfo* src, uint64_t start_index,
                                                             uint64_t count);
template <>
VkPipelineRenderingCreateInfo* CommandRecorder::CopyArray<VkPipelineRenderingCreateInfo>(
    const VkPipelineRenderingCreateInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDynamicRenderingFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingFeatures>(
    const VkPhysicalDeviceDynamicRenderingFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferInheritanceRenderingInfo* CommandRecorder::CopyArray<VkCommandBufferInheritanceRenderingInfo>(
    const VkCommandBufferInheritanceRenderingInfo* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderIntegerDotProductFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerDotProductFeatures>(
    const VkPhysicalDeviceShaderIntegerDotProductFeatures* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderIntegerDotProductProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerDotProductProperties>(
    const VkPhysicalDeviceShaderIntegerDotProductProperties* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTexelBufferAlignmentProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentProperties>(
    const VkPhysicalDeviceTexelBufferAlignmentProperties* src, uint64_t start_index, uint64_t count);
template <>
VkFormatProperties3* CommandRecorder::CopyArray<VkFormatProperties3>(const VkFormatProperties3* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance4Features* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance4Features>(
    const VkPhysicalDeviceMaintenance4Features* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance4Properties* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance4Properties>(
    const VkPhysicalDeviceMaintenance4Properties* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceBufferMemoryRequirements* CommandRecorder::CopyArray<VkDeviceBufferMemoryRequirements>(
    const VkDeviceBufferMemoryRequirements* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceImageMemoryRequirements* CommandRecorder::CopyArray<VkDeviceImageMemoryRequirements>(
    const VkDeviceImageMemoryRequirements* src, uint64_t start_index, uint64_t count);
template <>
VkSurfaceCapabilitiesKHR* CommandRecorder::CopyArray<VkSurfaceCapabilitiesKHR>(const VkSurfaceCapabilitiesKHR* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkSurfaceFormatKHR* CommandRecorder::CopyArray<VkSurfaceFormatKHR>(const VkSurfaceFormatKHR* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkSwapchainCreateInfoKHR>(const VkSwapchainCreateInfoKHR* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPresentInfoKHR* CommandRecorder::CopyArray<VkPresentInfoKHR>(const VkPresentInfoKHR* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkImageSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkImageSwapchainCreateInfoKHR>(
    const VkImageSwapchainCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkBindImageMemorySwapchainInfoKHR* CommandRecorder::CopyArray<VkBindImageMemorySwapchainInfoKHR>(
    const VkBindImageMemorySwapchainInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAcquireNextImageInfoKHR* CommandRecorder::CopyArray<VkAcquireNextImageInfoKHR>(const VkAcquireNextImageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupPresentCapabilitiesKHR* CommandRecorder::CopyArray<VkDeviceGroupPresentCapabilitiesKHR>(
    const VkDeviceGroupPresentCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupPresentInfoKHR* CommandRecorder::CopyArray<VkDeviceGroupPresentInfoKHR>(
    const VkDeviceGroupPresentInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceGroupSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkDeviceGroupSwapchainCreateInfoKHR>(
    const VkDeviceGroupSwapchainCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayModeParametersKHR* CommandRecorder::CopyArray<VkDisplayModeParametersKHR>(
    const VkDisplayModeParametersKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayModeCreateInfoKHR* CommandRecorder::CopyArray<VkDisplayModeCreateInfoKHR>(
    const VkDisplayModeCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayModePropertiesKHR* CommandRecorder::CopyArray<VkDisplayModePropertiesKHR>(
    const VkDisplayModePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayPlaneCapabilitiesKHR* CommandRecorder::CopyArray<VkDisplayPlaneCapabilitiesKHR>(
    const VkDisplayPlaneCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayPlanePropertiesKHR* CommandRecorder::CopyArray<VkDisplayPlanePropertiesKHR>(
    const VkDisplayPlanePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayPropertiesKHR* CommandRecorder::CopyArray<VkDisplayPropertiesKHR>(const VkDisplayPropertiesKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkDisplaySurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkDisplaySurfaceCreateInfoKHR>(
    const VkDisplaySurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayPresentInfoKHR* CommandRecorder::CopyArray<VkDisplayPresentInfoKHR>(const VkDisplayPresentInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_XLIB_KHR
template <>
VkXlibSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkXlibSurfaceCreateInfoKHR>(
    const VkXlibSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_XLIB_KHR
#ifdef VK_USE_PLATFORM_XCB_KHR
template <>
VkXcbSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkXcbSurfaceCreateInfoKHR>(const VkXcbSurfaceCreateInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_XCB_KHR
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
template <>
VkWaylandSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkWaylandSurfaceCreateInfoKHR>(
    const VkWaylandSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WAYLAND_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkAndroidSurfaceCreateInfoKHR>(
    const VkAndroidSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32SurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkWin32SurfaceCreateInfoKHR>(
    const VkWin32SurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkQueueFamilyQueryResultStatusPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyQueryResultStatusPropertiesKHR>(
    const VkQueueFamilyQueryResultStatusPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyVideoPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyVideoPropertiesKHR>(
    const VkQueueFamilyVideoPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoProfileInfoKHR* CommandRecorder::CopyArray<VkVideoProfileInfoKHR>(const VkVideoProfileInfoKHR* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkVideoProfileListInfoKHR* CommandRecorder::CopyArray<VkVideoProfileListInfoKHR>(const VkVideoProfileListInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkVideoCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoCapabilitiesKHR>(const VkVideoCapabilitiesKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVideoFormatInfoKHR* CommandRecorder::CopyArray<VkPhysicalDeviceVideoFormatInfoKHR>(
    const VkPhysicalDeviceVideoFormatInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoFormatPropertiesKHR* CommandRecorder::CopyArray<VkVideoFormatPropertiesKHR>(
    const VkVideoFormatPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoPictureResourceInfoKHR* CommandRecorder::CopyArray<VkVideoPictureResourceInfoKHR>(
    const VkVideoPictureResourceInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoReferenceSlotInfoKHR* CommandRecorder::CopyArray<VkVideoReferenceSlotInfoKHR>(
    const VkVideoReferenceSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoSessionMemoryRequirementsKHR* CommandRecorder::CopyArray<VkVideoSessionMemoryRequirementsKHR>(
    const VkVideoSessionMemoryRequirementsKHR* src, uint64_t start_index, uint64_t count);
template <>
VkBindVideoSessionMemoryInfoKHR* CommandRecorder::CopyArray<VkBindVideoSessionMemoryInfoKHR>(
    const VkBindVideoSessionMemoryInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoSessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionCreateInfoKHR>(
    const VkVideoSessionCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoSessionParametersCreateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionParametersCreateInfoKHR>(
    const VkVideoSessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoSessionParametersUpdateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionParametersUpdateInfoKHR>(
    const VkVideoSessionParametersUpdateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoBeginCodingInfoKHR* CommandRecorder::CopyArray<VkVideoBeginCodingInfoKHR>(const VkVideoBeginCodingInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkVideoEndCodingInfoKHR* CommandRecorder::CopyArray<VkVideoEndCodingInfoKHR>(const VkVideoEndCodingInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkVideoCodingControlInfoKHR* CommandRecorder::CopyArray<VkVideoCodingControlInfoKHR>(
    const VkVideoCodingControlInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeCapabilitiesKHR>(
    const VkVideoDecodeCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeUsageInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeUsageInfoKHR>(const VkVideoDecodeUsageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeInfoKHR>(const VkVideoDecodeInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH264CapabilitiesKHR>(
    const VkVideoEncodeH264CapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264QpKHR* CommandRecorder::CopyArray<VkVideoEncodeH264QpKHR>(const VkVideoEncodeH264QpKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264QualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH264QualityLevelPropertiesKHR>(
    const VkVideoEncodeH264QualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264SessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionCreateInfoKHR>(
    const VkVideoEncodeH264SessionCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersAddInfoKHR>(
    const VkVideoEncodeH264SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersCreateInfoKHR>(
    const VkVideoEncodeH264SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264SessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersGetInfoKHR>(
    const VkVideoEncodeH264SessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264SessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeH264SessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264NaluSliceInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264NaluSliceInfoKHR>(
    const VkVideoEncodeH264NaluSliceInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264PictureInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264PictureInfoKHR>(
    const VkVideoEncodeH264PictureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264DpbSlotInfoKHR>(
    const VkVideoEncodeH264DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264ProfileInfoKHR>(
    const VkVideoEncodeH264ProfileInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264RateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264RateControlInfoKHR>(
    const VkVideoEncodeH264RateControlInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264FrameSizeKHR* CommandRecorder::CopyArray<VkVideoEncodeH264FrameSizeKHR>(
    const VkVideoEncodeH264FrameSizeKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264RateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264RateControlLayerInfoKHR>(
    const VkVideoEncodeH264RateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH264GopRemainingFrameInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264GopRemainingFrameInfoKHR>(
    const VkVideoEncodeH264GopRemainingFrameInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH265CapabilitiesKHR>(
    const VkVideoEncodeH265CapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265SessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionCreateInfoKHR>(
    const VkVideoEncodeH265SessionCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265QpKHR* CommandRecorder::CopyArray<VkVideoEncodeH265QpKHR>(const VkVideoEncodeH265QpKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265QualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH265QualityLevelPropertiesKHR>(
    const VkVideoEncodeH265QualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersAddInfoKHR>(
    const VkVideoEncodeH265SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersCreateInfoKHR>(
    const VkVideoEncodeH265SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265SessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersGetInfoKHR>(
    const VkVideoEncodeH265SessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265SessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeH265SessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265NaluSliceSegmentInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265NaluSliceSegmentInfoKHR>(
    const VkVideoEncodeH265NaluSliceSegmentInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265PictureInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265PictureInfoKHR>(
    const VkVideoEncodeH265PictureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265DpbSlotInfoKHR>(
    const VkVideoEncodeH265DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265ProfileInfoKHR>(
    const VkVideoEncodeH265ProfileInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265RateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265RateControlInfoKHR>(
    const VkVideoEncodeH265RateControlInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265FrameSizeKHR* CommandRecorder::CopyArray<VkVideoEncodeH265FrameSizeKHR>(
    const VkVideoEncodeH265FrameSizeKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265RateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265RateControlLayerInfoKHR>(
    const VkVideoEncodeH265RateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeH265GopRemainingFrameInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265GopRemainingFrameInfoKHR>(
    const VkVideoEncodeH265GopRemainingFrameInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264ProfileInfoKHR>(
    const VkVideoDecodeH264ProfileInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeH264CapabilitiesKHR>(
    const VkVideoDecodeH264CapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264SessionParametersAddInfoKHR>(
    const VkVideoDecodeH264SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeH264SessionParametersCreateInfoKHR>(
    const VkVideoDecodeH264SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264PictureInfoKHR>(
    const VkVideoDecodeH264PictureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH264DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264DpbSlotInfoKHR>(
    const VkVideoDecodeH264DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingFragmentShadingRateAttachmentInfoKHR*
CommandRecorder::CopyArray<VkRenderingFragmentShadingRateAttachmentInfoKHR>(
    const VkRenderingFragmentShadingRateAttachmentInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingFragmentDensityMapAttachmentInfoEXT*
CommandRecorder::CopyArray<VkRenderingFragmentDensityMapAttachmentInfoEXT>(
    const VkRenderingFragmentDensityMapAttachmentInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkAttachmentSampleCountInfoAMD* CommandRecorder::CopyArray<VkAttachmentSampleCountInfoAMD>(
    const VkAttachmentSampleCountInfoAMD* src, uint64_t start_index, uint64_t count);
template <>
VkMultiviewPerViewAttributesInfoNVX* CommandRecorder::CopyArray<VkMultiviewPerViewAttributesInfoNVX>(
    const VkMultiviewPerViewAttributesInfoNVX* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportMemoryWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportMemoryWin32HandleInfoKHR>(
    const VkImportMemoryWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportMemoryWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportMemoryWin32HandleInfoKHR>(
    const VkExportMemoryWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkMemoryWin32HandlePropertiesKHR* CommandRecorder::CopyArray<VkMemoryWin32HandlePropertiesKHR>(
    const VkMemoryWin32HandlePropertiesKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkMemoryGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkMemoryGetWin32HandleInfoKHR>(
    const VkMemoryGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportMemoryFdInfoKHR* CommandRecorder::CopyArray<VkImportMemoryFdInfoKHR>(const VkImportMemoryFdInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkMemoryFdPropertiesKHR* CommandRecorder::CopyArray<VkMemoryFdPropertiesKHR>(const VkMemoryFdPropertiesKHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkMemoryGetFdInfoKHR* CommandRecorder::CopyArray<VkMemoryGetFdInfoKHR>(const VkMemoryGetFdInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32KeyedMutexAcquireReleaseInfoKHR* CommandRecorder::CopyArray<VkWin32KeyedMutexAcquireReleaseInfoKHR>(
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportSemaphoreWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportSemaphoreWin32HandleInfoKHR>(
    const VkImportSemaphoreWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportSemaphoreWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportSemaphoreWin32HandleInfoKHR>(
    const VkExportSemaphoreWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkD3D12FenceSubmitInfoKHR* CommandRecorder::CopyArray<VkD3D12FenceSubmitInfoKHR>(const VkD3D12FenceSubmitInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSemaphoreGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkSemaphoreGetWin32HandleInfoKHR>(
    const VkSemaphoreGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportSemaphoreFdInfoKHR* CommandRecorder::CopyArray<VkImportSemaphoreFdInfoKHR>(
    const VkImportSemaphoreFdInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkSemaphoreGetFdInfoKHR* CommandRecorder::CopyArray<VkSemaphoreGetFdInfoKHR>(const VkSemaphoreGetFdInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePushDescriptorPropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePushDescriptorPropertiesKHR>(
    const VkPhysicalDevicePushDescriptorPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRectLayerKHR* CommandRecorder::CopyArray<VkRectLayerKHR>(const VkRectLayerKHR* src, uint64_t start_index,
                                                           uint64_t count);
template <>
VkPresentRegionKHR* CommandRecorder::CopyArray<VkPresentRegionKHR>(const VkPresentRegionKHR* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkPresentRegionsKHR* CommandRecorder::CopyArray<VkPresentRegionsKHR>(const VkPresentRegionsKHR* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkSharedPresentSurfaceCapabilitiesKHR* CommandRecorder::CopyArray<VkSharedPresentSurfaceCapabilitiesKHR>(
    const VkSharedPresentSurfaceCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportFenceWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportFenceWin32HandleInfoKHR>(
    const VkImportFenceWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportFenceWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportFenceWin32HandleInfoKHR>(
    const VkExportFenceWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkFenceGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkFenceGetWin32HandleInfoKHR>(
    const VkFenceGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportFenceFdInfoKHR* CommandRecorder::CopyArray<VkImportFenceFdInfoKHR>(const VkImportFenceFdInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkFenceGetFdInfoKHR* CommandRecorder::CopyArray<VkFenceGetFdInfoKHR>(const VkFenceGetFdInfoKHR* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePerformanceQueryFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryFeaturesKHR>(
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePerformanceQueryPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryPropertiesKHR>(
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceCounterKHR* CommandRecorder::CopyArray<VkPerformanceCounterKHR>(const VkPerformanceCounterKHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkPerformanceCounterDescriptionKHR* CommandRecorder::CopyArray<VkPerformanceCounterDescriptionKHR>(
    const VkPerformanceCounterDescriptionKHR* src, uint64_t start_index, uint64_t count);
template <>
VkQueryPoolPerformanceCreateInfoKHR* CommandRecorder::CopyArray<VkQueryPoolPerformanceCreateInfoKHR>(
    const VkQueryPoolPerformanceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceCounterResultKHR* CommandRecorder::CopyArray<VkPerformanceCounterResultKHR>(
    const VkPerformanceCounterResultKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAcquireProfilingLockInfoKHR* CommandRecorder::CopyArray<VkAcquireProfilingLockInfoKHR>(
    const VkAcquireProfilingLockInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceQuerySubmitInfoKHR* CommandRecorder::CopyArray<VkPerformanceQuerySubmitInfoKHR>(
    const VkPerformanceQuerySubmitInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSurfaceInfo2KHR* CommandRecorder::CopyArray<VkPhysicalDeviceSurfaceInfo2KHR>(
    const VkPhysicalDeviceSurfaceInfo2KHR* src, uint64_t start_index, uint64_t count);
template <>
VkSurfaceCapabilities2KHR* CommandRecorder::CopyArray<VkSurfaceCapabilities2KHR>(const VkSurfaceCapabilities2KHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkSurfaceFormat2KHR* CommandRecorder::CopyArray<VkSurfaceFormat2KHR>(const VkSurfaceFormat2KHR* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkDisplayProperties2KHR* CommandRecorder::CopyArray<VkDisplayProperties2KHR>(const VkDisplayProperties2KHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkDisplayPlaneProperties2KHR* CommandRecorder::CopyArray<VkDisplayPlaneProperties2KHR>(
    const VkDisplayPlaneProperties2KHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayModeProperties2KHR* CommandRecorder::CopyArray<VkDisplayModeProperties2KHR>(
    const VkDisplayModeProperties2KHR* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayPlaneInfo2KHR* CommandRecorder::CopyArray<VkDisplayPlaneInfo2KHR>(const VkDisplayPlaneInfo2KHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkDisplayPlaneCapabilities2KHR* CommandRecorder::CopyArray<VkDisplayPlaneCapabilities2KHR>(
    const VkDisplayPlaneCapabilities2KHR* src, uint64_t start_index, uint64_t count);
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDevicePortabilitySubsetFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePortabilitySubsetFeaturesKHR>(
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDevicePortabilitySubsetPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePortabilitySubsetPropertiesKHR>(
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceShaderClockFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceShaderClockFeaturesKHR>(
    const VkPhysicalDeviceShaderClockFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265ProfileInfoKHR>(
    const VkVideoDecodeH265ProfileInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeH265CapabilitiesKHR>(
    const VkVideoDecodeH265CapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265SessionParametersAddInfoKHR>(
    const VkVideoDecodeH265SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeH265SessionParametersCreateInfoKHR>(
    const VkVideoDecodeH265SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265PictureInfoKHR>(
    const VkVideoDecodeH265PictureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeH265DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265DpbSlotInfoKHR>(
    const VkVideoDecodeH265DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceQueueGlobalPriorityCreateInfoKHR* CommandRecorder::CopyArray<VkDeviceQueueGlobalPriorityCreateInfoKHR>(
    const VkDeviceQueueGlobalPriorityCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>(
    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyGlobalPriorityPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyGlobalPriorityPropertiesKHR>(
    const VkQueueFamilyGlobalPriorityPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkFragmentShadingRateAttachmentInfoKHR* CommandRecorder::CopyArray<VkFragmentShadingRateAttachmentInfoKHR>(
    const VkFragmentShadingRateAttachmentInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineFragmentShadingRateStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineFragmentShadingRateStateCreateInfoKHR>(
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShadingRateFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShadingRatePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShadingRateKHR* CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateKHR>(
    const VkPhysicalDeviceFragmentShadingRateKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR>(
    const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingAttachmentLocationInfoKHR* CommandRecorder::CopyArray<VkRenderingAttachmentLocationInfoKHR>(
    const VkRenderingAttachmentLocationInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingInputAttachmentIndexInfoKHR* CommandRecorder::CopyArray<VkRenderingInputAttachmentIndexInfoKHR>(
    const VkRenderingInputAttachmentIndexInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderQuadControlFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceShaderQuadControlFeaturesKHR>(
    const VkPhysicalDeviceShaderQuadControlFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkSurfaceProtectedCapabilitiesKHR* CommandRecorder::CopyArray<VkSurfaceProtectedCapabilitiesKHR>(
    const VkSurfaceProtectedCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePresentWaitFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePresentWaitFeaturesKHR>(
    const VkPhysicalDevicePresentWaitFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineInfoKHR* CommandRecorder::CopyArray<VkPipelineInfoKHR>(const VkPipelineInfoKHR* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkPipelineExecutablePropertiesKHR* CommandRecorder::CopyArray<VkPipelineExecutablePropertiesKHR>(
    const VkPipelineExecutablePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineExecutableInfoKHR* CommandRecorder::CopyArray<VkPipelineExecutableInfoKHR>(
    const VkPipelineExecutableInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineExecutableStatisticValueKHR* CommandRecorder::CopyArray<VkPipelineExecutableStatisticValueKHR>(
    const VkPipelineExecutableStatisticValueKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineExecutableStatisticKHR* CommandRecorder::CopyArray<VkPipelineExecutableStatisticKHR>(
    const VkPipelineExecutableStatisticKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineExecutableInternalRepresentationKHR*
CommandRecorder::CopyArray<VkPipelineExecutableInternalRepresentationKHR>(
    const VkPipelineExecutableInternalRepresentationKHR* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryMapInfoKHR* CommandRecorder::CopyArray<VkMemoryMapInfoKHR>(const VkMemoryMapInfoKHR* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkMemoryUnmapInfoKHR* CommandRecorder::CopyArray<VkMemoryUnmapInfoKHR>(const VkMemoryUnmapInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkPipelineLibraryCreateInfoKHR* CommandRecorder::CopyArray<VkPipelineLibraryCreateInfoKHR>(
    const VkPipelineLibraryCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPresentIdKHR* CommandRecorder::CopyArray<VkPresentIdKHR>(const VkPresentIdKHR* src, uint64_t start_index,
                                                           uint64_t count);
template <>
VkPhysicalDevicePresentIdFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePresentIdFeaturesKHR>(
    const VkPhysicalDevicePresentIdFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeInfoKHR>(const VkVideoEncodeInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeCapabilitiesKHR>(
    const VkVideoEncodeCapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* CommandRecorder::CopyArray<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>(
    const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeUsageInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeUsageInfoKHR>(const VkVideoEncodeUsageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeRateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeRateControlLayerInfoKHR>(
    const VkVideoEncodeRateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeRateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeRateControlInfoKHR>(
    const VkVideoEncodeRateControlInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>(
    const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeQualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeQualityLevelPropertiesKHR>(
    const VkVideoEncodeQualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeQualityLevelInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeQualityLevelInfoKHR>(
    const VkVideoEncodeQualityLevelInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeSessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeSessionParametersGetInfoKHR>(
    const VkVideoEncodeSessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoEncodeSessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeSessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeSessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyCheckpointProperties2NV* CommandRecorder::CopyArray<VkQueueFamilyCheckpointProperties2NV>(
    const VkQueueFamilyCheckpointProperties2NV* src, uint64_t start_index, uint64_t count);
template <>
VkCheckpointData2NV* CommandRecorder::CopyArray<VkCheckpointData2NV>(const VkCheckpointData2NV* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>(
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>(
    const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(
    const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(
    const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>(
    const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkTraceRaysIndirectCommand2KHR* CommandRecorder::CopyArray<VkTraceRaysIndirectCommand2KHR>(
    const VkTraceRaysIndirectCommand2KHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR>(
    const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>(
    const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance5FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance5FeaturesKHR>(
    const VkPhysicalDeviceMaintenance5FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance5PropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance5PropertiesKHR>(
    const VkPhysicalDeviceMaintenance5PropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRenderingAreaInfoKHR* CommandRecorder::CopyArray<VkRenderingAreaInfoKHR>(const VkRenderingAreaInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkImageSubresource2KHR* CommandRecorder::CopyArray<VkImageSubresource2KHR>(const VkImageSubresource2KHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkDeviceImageSubresourceInfoKHR* CommandRecorder::CopyArray<VkDeviceImageSubresourceInfoKHR>(
    const VkDeviceImageSubresourceInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkSubresourceLayout2KHR* CommandRecorder::CopyArray<VkSubresourceLayout2KHR>(const VkSubresourceLayout2KHR* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkPipelineCreateFlags2CreateInfoKHR* CommandRecorder::CopyArray<VkPipelineCreateFlags2CreateInfoKHR>(
    const VkPipelineCreateFlags2CreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkBufferUsageFlags2CreateInfoKHR* CommandRecorder::CopyArray<VkBufferUsageFlags2CreateInfoKHR>(
    const VkBufferUsageFlags2CreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>(
    const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkCooperativeMatrixPropertiesKHR* CommandRecorder::CopyArray<VkCooperativeMatrixPropertiesKHR>(
    const VkCooperativeMatrixPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCooperativeMatrixFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>(
    const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCooperativeMatrixPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixPropertiesKHR>(
    const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeAV1ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1ProfileInfoKHR>(
    const VkVideoDecodeAV1ProfileInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeAV1CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1CapabilitiesKHR>(
    const VkVideoDecodeAV1CapabilitiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeAV1SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeAV1SessionParametersCreateInfoKHR>(
    const VkVideoDecodeAV1SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeAV1PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1PictureInfoKHR>(
    const VkVideoDecodeAV1PictureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoDecodeAV1DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1DpbSlotInfoKHR>(
    const VkVideoDecodeAV1DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVideoMaintenance1FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>(
    const VkPhysicalDeviceVideoMaintenance1FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVideoInlineQueryInfoKHR* CommandRecorder::CopyArray<VkVideoInlineQueryInfoKHR>(const VkVideoInlineQueryInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR>(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkVertexInputBindingDivisorDescriptionKHR* CommandRecorder::CopyArray<VkVertexInputBindingDivisorDescriptionKHR>(
    const VkVertexInputBindingDivisorDescriptionKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineVertexInputDivisorStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineVertexInputDivisorStateCreateInfoKHR>(
    const VkPipelineVertexInputDivisorStateCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR>(
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderFloatControls2FeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloatControls2FeaturesKHR>(
    const VkPhysicalDeviceShaderFloatControls2FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceIndexTypeUint8FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceIndexTypeUint8FeaturesKHR>(
    const VkPhysicalDeviceIndexTypeUint8FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLineRasterizationFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationFeaturesKHR>(
    const VkPhysicalDeviceLineRasterizationFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLineRasterizationPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationPropertiesKHR>(
    const VkPhysicalDeviceLineRasterizationPropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationLineStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineRasterizationLineStateCreateInfoKHR>(
    const VkPipelineRasterizationLineStateCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkCalibratedTimestampInfoKHR* CommandRecorder::CopyArray<VkCalibratedTimestampInfoKHR>(
    const VkCalibratedTimestampInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderExpectAssumeFeaturesKHR>(
    const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance6FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance6FeaturesKHR>(
    const VkPhysicalDeviceMaintenance6FeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMaintenance6PropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance6PropertiesKHR>(
    const VkPhysicalDeviceMaintenance6PropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkBindMemoryStatusKHR* CommandRecorder::CopyArray<VkBindMemoryStatusKHR>(const VkBindMemoryStatusKHR* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkBindDescriptorSetsInfoKHR* CommandRecorder::CopyArray<VkBindDescriptorSetsInfoKHR>(
    const VkBindDescriptorSetsInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPushConstantsInfoKHR* CommandRecorder::CopyArray<VkPushConstantsInfoKHR>(const VkPushConstantsInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkPushDescriptorSetInfoKHR* CommandRecorder::CopyArray<VkPushDescriptorSetInfoKHR>(
    const VkPushDescriptorSetInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPushDescriptorSetWithTemplateInfoKHR* CommandRecorder::CopyArray<VkPushDescriptorSetWithTemplateInfoKHR>(
    const VkPushDescriptorSetWithTemplateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkSetDescriptorBufferOffsetsInfoEXT* CommandRecorder::CopyArray<VkSetDescriptorBufferOffsetsInfoEXT>(
    const VkSetDescriptorBufferOffsetsInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkBindDescriptorBufferEmbeddedSamplersInfoEXT*
CommandRecorder::CopyArray<VkBindDescriptorBufferEmbeddedSamplersInfoEXT>(
    const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugReportCallbackCreateInfoEXT* CommandRecorder::CopyArray<VkDebugReportCallbackCreateInfoEXT>(
    const VkDebugReportCallbackCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationStateRasterizationOrderAMD*
CommandRecorder::CopyArray<VkPipelineRasterizationStateRasterizationOrderAMD>(
    const VkPipelineRasterizationStateRasterizationOrderAMD* src, uint64_t start_index, uint64_t count);
template <>
VkDebugMarkerObjectNameInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerObjectNameInfoEXT>(
    const VkDebugMarkerObjectNameInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugMarkerObjectTagInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerObjectTagInfoEXT>(
    const VkDebugMarkerObjectTagInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugMarkerMarkerInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerMarkerInfoEXT>(
    const VkDebugMarkerMarkerInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDedicatedAllocationImageCreateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationImageCreateInfoNV>(
    const VkDedicatedAllocationImageCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkDedicatedAllocationBufferCreateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationBufferCreateInfoNV>(
    const VkDedicatedAllocationBufferCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkDedicatedAllocationMemoryAllocateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationMemoryAllocateInfoNV>(
    const VkDedicatedAllocationMemoryAllocateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTransformFeedbackFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTransformFeedbackPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationStateStreamCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationStateStreamCreateInfoEXT>(
    const VkPipelineRasterizationStateStreamCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCuModuleCreateInfoNVX* CommandRecorder::CopyArray<VkCuModuleCreateInfoNVX>(const VkCuModuleCreateInfoNVX* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkCuFunctionCreateInfoNVX* CommandRecorder::CopyArray<VkCuFunctionCreateInfoNVX>(const VkCuFunctionCreateInfoNVX* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkCuLaunchInfoNVX* CommandRecorder::CopyArray<VkCuLaunchInfoNVX>(const VkCuLaunchInfoNVX* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkImageViewHandleInfoNVX* CommandRecorder::CopyArray<VkImageViewHandleInfoNVX>(const VkImageViewHandleInfoNVX* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkImageViewAddressPropertiesNVX* CommandRecorder::CopyArray<VkImageViewAddressPropertiesNVX>(
    const VkImageViewAddressPropertiesNVX* src, uint64_t start_index, uint64_t count);
template <>
VkTextureLODGatherFormatPropertiesAMD* CommandRecorder::CopyArray<VkTextureLODGatherFormatPropertiesAMD>(
    const VkTextureLODGatherFormatPropertiesAMD* src, uint64_t start_index, uint64_t count);
template <>
VkShaderResourceUsageAMD* CommandRecorder::CopyArray<VkShaderResourceUsageAMD>(const VkShaderResourceUsageAMD* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkShaderStatisticsInfoAMD* CommandRecorder::CopyArray<VkShaderStatisticsInfoAMD>(const VkShaderStatisticsInfoAMD* src,
                                                                                 uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_GGP
template <>
VkStreamDescriptorSurfaceCreateInfoGGP* CommandRecorder::CopyArray<VkStreamDescriptorSurfaceCreateInfoGGP>(
    const VkStreamDescriptorSurfaceCreateInfoGGP* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_GGP
template <>
VkPhysicalDeviceCornerSampledImageFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCornerSampledImageFeaturesNV>(
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkExternalImageFormatPropertiesNV* CommandRecorder::CopyArray<VkExternalImageFormatPropertiesNV>(
    const VkExternalImageFormatPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkExternalMemoryImageCreateInfoNV* CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfoNV>(
    const VkExternalMemoryImageCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkExportMemoryAllocateInfoNV* CommandRecorder::CopyArray<VkExportMemoryAllocateInfoNV>(
    const VkExportMemoryAllocateInfoNV* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportMemoryWin32HandleInfoNV* CommandRecorder::CopyArray<VkImportMemoryWin32HandleInfoNV>(
    const VkImportMemoryWin32HandleInfoNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportMemoryWin32HandleInfoNV* CommandRecorder::CopyArray<VkExportMemoryWin32HandleInfoNV>(
    const VkExportMemoryWin32HandleInfoNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32KeyedMutexAcquireReleaseInfoNV* CommandRecorder::CopyArray<VkWin32KeyedMutexAcquireReleaseInfoNV>(
    const VkWin32KeyedMutexAcquireReleaseInfoNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkValidationFlagsEXT* CommandRecorder::CopyArray<VkValidationFlagsEXT>(const VkValidationFlagsEXT* src,
                                                                       uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_VI_NN
template <>
VkViSurfaceCreateInfoNN* CommandRecorder::CopyArray<VkViSurfaceCreateInfoNN>(const VkViSurfaceCreateInfoNN* src,
                                                                             uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_VI_NN
template <>
VkImageViewASTCDecodeModeEXT* CommandRecorder::CopyArray<VkImageViewASTCDecodeModeEXT>(
    const VkImageViewASTCDecodeModeEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceASTCDecodeFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceASTCDecodeFeaturesEXT>(
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineRobustnessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineRobustnessFeaturesEXT>(
    const VkPhysicalDevicePipelineRobustnessFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineRobustnessPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineRobustnessPropertiesEXT>(
    const VkPhysicalDevicePipelineRobustnessPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRobustnessCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineRobustnessCreateInfoEXT>(
    const VkPipelineRobustnessCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkConditionalRenderingBeginInfoEXT* CommandRecorder::CopyArray<VkConditionalRenderingBeginInfoEXT>(
    const VkConditionalRenderingBeginInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceConditionalRenderingFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferInheritanceConditionalRenderingInfoEXT*
CommandRecorder::CopyArray<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkViewportWScalingNV* CommandRecorder::CopyArray<VkViewportWScalingNV>(const VkViewportWScalingNV* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportWScalingStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineViewportWScalingStateCreateInfoNV>(
    const VkPipelineViewportWScalingStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkSurfaceCapabilities2EXT* CommandRecorder::CopyArray<VkSurfaceCapabilities2EXT>(const VkSurfaceCapabilities2EXT* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkDisplayPowerInfoEXT* CommandRecorder::CopyArray<VkDisplayPowerInfoEXT>(const VkDisplayPowerInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkDeviceEventInfoEXT* CommandRecorder::CopyArray<VkDeviceEventInfoEXT>(const VkDeviceEventInfoEXT* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkDisplayEventInfoEXT* CommandRecorder::CopyArray<VkDisplayEventInfoEXT>(const VkDisplayEventInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkSwapchainCounterCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainCounterCreateInfoEXT>(
    const VkSwapchainCounterCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRefreshCycleDurationGOOGLE* CommandRecorder::CopyArray<VkRefreshCycleDurationGOOGLE>(
    const VkRefreshCycleDurationGOOGLE* src, uint64_t start_index, uint64_t count);
template <>
VkPastPresentationTimingGOOGLE* CommandRecorder::CopyArray<VkPastPresentationTimingGOOGLE>(
    const VkPastPresentationTimingGOOGLE* src, uint64_t start_index, uint64_t count);
template <>
VkPresentTimeGOOGLE* CommandRecorder::CopyArray<VkPresentTimeGOOGLE>(const VkPresentTimeGOOGLE* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPresentTimesInfoGOOGLE* CommandRecorder::CopyArray<VkPresentTimesInfoGOOGLE>(const VkPresentTimesInfoGOOGLE* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* src, uint64_t start_index, uint64_t count);
template <>
VkViewportSwizzleNV* CommandRecorder::CopyArray<VkViewportSwizzleNV>(const VkViewportSwizzleNV* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportSwizzleStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineViewportSwizzleStateCreateInfoNV>(
    const VkPipelineViewportSwizzleStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDiscardRectanglePropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineDiscardRectangleStateCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineDiscardRectangleStateCreateInfoEXT>(
    const VkPipelineDiscardRectangleStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceConservativeRasterizationPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationConservativeStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationConservativeStateCreateInfoEXT>(
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDepthClipEnableFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationDepthClipStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkXYColorEXT* CommandRecorder::CopyArray<VkXYColorEXT>(const VkXYColorEXT* src, uint64_t start_index, uint64_t count);
template <>
VkHdrMetadataEXT* CommandRecorder::CopyArray<VkHdrMetadataEXT>(const VkHdrMetadataEXT* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*
CommandRecorder::CopyArray<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>(
    const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_IOS_MVK
template <>
VkIOSSurfaceCreateInfoMVK* CommandRecorder::CopyArray<VkIOSSurfaceCreateInfoMVK>(const VkIOSSurfaceCreateInfoMVK* src,
                                                                                 uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_IOS_MVK
#ifdef VK_USE_PLATFORM_MACOS_MVK
template <>
VkMacOSSurfaceCreateInfoMVK* CommandRecorder::CopyArray<VkMacOSSurfaceCreateInfoMVK>(
    const VkMacOSSurfaceCreateInfoMVK* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_MACOS_MVK
template <>
VkDebugUtilsLabelEXT* CommandRecorder::CopyArray<VkDebugUtilsLabelEXT>(const VkDebugUtilsLabelEXT* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkDebugUtilsObjectNameInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsObjectNameInfoEXT>(
    const VkDebugUtilsObjectNameInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugUtilsMessengerCallbackDataEXT* CommandRecorder::CopyArray<VkDebugUtilsMessengerCallbackDataEXT>(
    const VkDebugUtilsMessengerCallbackDataEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugUtilsMessengerCreateInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsMessengerCreateInfoEXT>(
    const VkDebugUtilsMessengerCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDebugUtilsObjectTagInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsObjectTagInfoEXT>(
    const VkDebugUtilsObjectTagInfoEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferUsageANDROID* CommandRecorder::CopyArray<VkAndroidHardwareBufferUsageANDROID>(
    const VkAndroidHardwareBufferUsageANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferPropertiesANDROID* CommandRecorder::CopyArray<VkAndroidHardwareBufferPropertiesANDROID>(
    const VkAndroidHardwareBufferPropertiesANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatPropertiesANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatPropertiesANDROID>(
    const VkAndroidHardwareBufferFormatPropertiesANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkImportAndroidHardwareBufferInfoANDROID* CommandRecorder::CopyArray<VkImportAndroidHardwareBufferInfoANDROID>(
    const VkImportAndroidHardwareBufferInfoANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkMemoryGetAndroidHardwareBufferInfoANDROID* CommandRecorder::CopyArray<VkMemoryGetAndroidHardwareBufferInfoANDROID>(
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkExternalFormatANDROID* CommandRecorder::CopyArray<VkExternalFormatANDROID>(const VkExternalFormatANDROID* src,
                                                                             uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatProperties2ANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatProperties2ANDROID>(
    const VkAndroidHardwareBufferFormatProperties2ANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceShaderEnqueueFeaturesAMDX* CommandRecorder::CopyArray<VkPhysicalDeviceShaderEnqueueFeaturesAMDX>(
    const VkPhysicalDeviceShaderEnqueueFeaturesAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceShaderEnqueuePropertiesAMDX* CommandRecorder::CopyArray<VkPhysicalDeviceShaderEnqueuePropertiesAMDX>(
    const VkPhysicalDeviceShaderEnqueuePropertiesAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkExecutionGraphPipelineScratchSizeAMDX* CommandRecorder::CopyArray<VkExecutionGraphPipelineScratchSizeAMDX>(
    const VkExecutionGraphPipelineScratchSizeAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkExecutionGraphPipelineCreateInfoAMDX* CommandRecorder::CopyArray<VkExecutionGraphPipelineCreateInfoAMDX>(
    const VkExecutionGraphPipelineCreateInfoAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDeviceOrHostAddressConstAMDX* CommandRecorder::CopyArray<VkDeviceOrHostAddressConstAMDX>(
    const VkDeviceOrHostAddressConstAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDispatchGraphInfoAMDX* CommandRecorder::CopyArray<VkDispatchGraphInfoAMDX>(const VkDispatchGraphInfoAMDX* src,
                                                                             uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDispatchGraphCountInfoAMDX* CommandRecorder::CopyArray<VkDispatchGraphCountInfoAMDX>(
    const VkDispatchGraphCountInfoAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPipelineShaderStageNodeCreateInfoAMDX* CommandRecorder::CopyArray<VkPipelineShaderStageNodeCreateInfoAMDX>(
    const VkPipelineShaderStageNodeCreateInfoAMDX* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
template <>
VkSampleLocationEXT* CommandRecorder::CopyArray<VkSampleLocationEXT>(const VkSampleLocationEXT* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkSampleLocationsInfoEXT* CommandRecorder::CopyArray<VkSampleLocationsInfoEXT>(const VkSampleLocationsInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkAttachmentSampleLocationsEXT* CommandRecorder::CopyArray<VkAttachmentSampleLocationsEXT>(
    const VkAttachmentSampleLocationsEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSubpassSampleLocationsEXT* CommandRecorder::CopyArray<VkSubpassSampleLocationsEXT>(
    const VkSubpassSampleLocationsEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassSampleLocationsBeginInfoEXT* CommandRecorder::CopyArray<VkRenderPassSampleLocationsBeginInfoEXT>(
    const VkRenderPassSampleLocationsBeginInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineSampleLocationsStateCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineSampleLocationsStateCreateInfoEXT>(
    const VkPipelineSampleLocationsStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSampleLocationsPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceSampleLocationsPropertiesEXT>(
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMultisamplePropertiesEXT* CommandRecorder::CopyArray<VkMultisamplePropertiesEXT>(
    const VkMultisamplePropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineColorBlendAdvancedStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCoverageToColorStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineCoverageToColorStateCreateInfoNV>(
    const VkPipelineCoverageToColorStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCoverageModulationStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineCoverageModulationStateCreateInfoNV>(
    const VkPipelineCoverageModulationStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkDrmFormatModifierPropertiesEXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesEXT>(
    const VkDrmFormatModifierPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDrmFormatModifierPropertiesListEXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesListEXT>(
    const VkDrmFormatModifierPropertiesListEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageDrmFormatModifierInfoEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageDrmFormatModifierListCreateInfoEXT* CommandRecorder::CopyArray<VkImageDrmFormatModifierListCreateInfoEXT>(
    const VkImageDrmFormatModifierListCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageDrmFormatModifierExplicitCreateInfoEXT*
CommandRecorder::CopyArray<VkImageDrmFormatModifierExplicitCreateInfoEXT>(
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageDrmFormatModifierPropertiesEXT* CommandRecorder::CopyArray<VkImageDrmFormatModifierPropertiesEXT>(
    const VkImageDrmFormatModifierPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDrmFormatModifierProperties2EXT* CommandRecorder::CopyArray<VkDrmFormatModifierProperties2EXT>(
    const VkDrmFormatModifierProperties2EXT* src, uint64_t start_index, uint64_t count);
template <>
VkDrmFormatModifierPropertiesList2EXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesList2EXT>(
    const VkDrmFormatModifierPropertiesList2EXT* src, uint64_t start_index, uint64_t count);
template <>
VkValidationCacheCreateInfoEXT* CommandRecorder::CopyArray<VkValidationCacheCreateInfoEXT>(
    const VkValidationCacheCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkShaderModuleValidationCacheCreateInfoEXT* CommandRecorder::CopyArray<VkShaderModuleValidationCacheCreateInfoEXT>(
    const VkShaderModuleValidationCacheCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkShadingRatePaletteNV* CommandRecorder::CopyArray<VkShadingRatePaletteNV>(const VkShadingRatePaletteNV* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportShadingRateImageStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportShadingRateImageStateCreateInfoNV>(
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShadingRateImageFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShadingRateImageFeaturesNV>(
    const VkPhysicalDeviceShadingRateImageFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShadingRateImagePropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShadingRateImagePropertiesNV>(
    const VkPhysicalDeviceShadingRateImagePropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkCoarseSampleLocationNV* CommandRecorder::CopyArray<VkCoarseSampleLocationNV>(const VkCoarseSampleLocationNV* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkCoarseSampleOrderCustomNV* CommandRecorder::CopyArray<VkCoarseSampleOrderCustomNV>(
    const VkCoarseSampleOrderCustomNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkRayTracingShaderGroupCreateInfoNV* CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoNV>(
    const VkRayTracingShaderGroupCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkRayTracingPipelineCreateInfoNV* CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoNV>(
    const VkRayTracingPipelineCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkGeometryTrianglesNV* CommandRecorder::CopyArray<VkGeometryTrianglesNV>(const VkGeometryTrianglesNV* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkGeometryAABBNV* CommandRecorder::CopyArray<VkGeometryAABBNV>(const VkGeometryAABBNV* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkGeometryDataNV* CommandRecorder::CopyArray<VkGeometryDataNV>(const VkGeometryDataNV* src, uint64_t start_index,
                                                               uint64_t count);
template <>
VkGeometryNV* CommandRecorder::CopyArray<VkGeometryNV>(const VkGeometryNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureInfoNV>(
    const VkAccelerationStructureInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureCreateInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoNV>(
    const VkAccelerationStructureCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkBindAccelerationStructureMemoryInfoNV* CommandRecorder::CopyArray<VkBindAccelerationStructureMemoryInfoNV>(
    const VkBindAccelerationStructureMemoryInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkWriteDescriptorSetAccelerationStructureNV* CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureNV>(
    const VkWriteDescriptorSetAccelerationStructureNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureMemoryRequirementsInfoNV*
CommandRecorder::CopyArray<VkAccelerationStructureMemoryRequirementsInfoNV>(
    const VkAccelerationStructureMemoryRequirementsInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPropertiesNV>(
    const VkPhysicalDeviceRayTracingPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkTransformMatrixKHR* CommandRecorder::CopyArray<VkTransformMatrixKHR>(const VkTransformMatrixKHR* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkAabbPositionsKHR* CommandRecorder::CopyArray<VkAabbPositionsKHR>(const VkAabbPositionsKHR* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkAccelerationStructureInstanceKHR* CommandRecorder::CopyArray<VkAccelerationStructureInstanceKHR>(
    const VkAccelerationStructureInstanceKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRepresentativeFragmentTestStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageViewImageFormatInfoEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImageViewImageFormatInfoEXT>(
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkFilterCubicImageViewImageFormatPropertiesEXT*
CommandRecorder::CopyArray<VkFilterCubicImageViewImageFormatPropertiesEXT>(
    const VkFilterCubicImageViewImageFormatPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImportMemoryHostPointerInfoEXT* CommandRecorder::CopyArray<VkImportMemoryHostPointerInfoEXT>(
    const VkImportMemoryHostPointerInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryHostPointerPropertiesEXT* CommandRecorder::CopyArray<VkMemoryHostPointerPropertiesEXT>(
    const VkMemoryHostPointerPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalMemoryHostPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCompilerControlCreateInfoAMD* CommandRecorder::CopyArray<VkPipelineCompilerControlCreateInfoAMD>(
    const VkPipelineCompilerControlCreateInfoAMD* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderCorePropertiesAMD* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesAMD>(
    const VkPhysicalDeviceShaderCorePropertiesAMD* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceMemoryOverallocationCreateInfoAMD* CommandRecorder::CopyArray<VkDeviceMemoryOverallocationCreateInfoAMD>(
    const VkDeviceMemoryOverallocationCreateInfoAMD* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_GGP
template <>
VkPresentFrameTokenGGP* CommandRecorder::CopyArray<VkPresentFrameTokenGGP>(const VkPresentFrameTokenGGP* src,
                                                                           uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_GGP
template <>
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMeshShaderFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderFeaturesNV>(
    const VkPhysicalDeviceMeshShaderFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMeshShaderPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderPropertiesNV>(
    const VkPhysicalDeviceMeshShaderPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkDrawMeshTasksIndirectCommandNV* CommandRecorder::CopyArray<VkDrawMeshTasksIndirectCommandNV>(
    const VkDrawMeshTasksIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderImageFootprintFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportExclusiveScissorStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExclusiveScissorFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceExclusiveScissorFeaturesNV>(
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkQueueFamilyCheckpointPropertiesNV* CommandRecorder::CopyArray<VkQueueFamilyCheckpointPropertiesNV>(
    const VkQueueFamilyCheckpointPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkCheckpointDataNV* CommandRecorder::CopyArray<VkCheckpointDataNV>(const VkCheckpointDataNV* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceValueDataINTEL* CommandRecorder::CopyArray<VkPerformanceValueDataINTEL>(
    const VkPerformanceValueDataINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceValueINTEL* CommandRecorder::CopyArray<VkPerformanceValueINTEL>(const VkPerformanceValueINTEL* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkInitializePerformanceApiInfoINTEL* CommandRecorder::CopyArray<VkInitializePerformanceApiInfoINTEL>(
    const VkInitializePerformanceApiInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkQueryPoolPerformanceQueryCreateInfoINTEL* CommandRecorder::CopyArray<VkQueryPoolPerformanceQueryCreateInfoINTEL>(
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceMarkerInfoINTEL* CommandRecorder::CopyArray<VkPerformanceMarkerInfoINTEL>(
    const VkPerformanceMarkerInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceStreamMarkerInfoINTEL* CommandRecorder::CopyArray<VkPerformanceStreamMarkerInfoINTEL>(
    const VkPerformanceStreamMarkerInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceOverrideInfoINTEL* CommandRecorder::CopyArray<VkPerformanceOverrideInfoINTEL>(
    const VkPerformanceOverrideInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPerformanceConfigurationAcquireInfoINTEL* CommandRecorder::CopyArray<VkPerformanceConfigurationAcquireInfoINTEL>(
    const VkPerformanceConfigurationAcquireInfoINTEL* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePCIBusInfoPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDevicePCIBusInfoPropertiesEXT>(
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDisplayNativeHdrSurfaceCapabilitiesAMD* CommandRecorder::CopyArray<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainDisplayNativeHdrCreateInfoAMD* CommandRecorder::CopyArray<VkSwapchainDisplayNativeHdrCreateInfoAMD>(
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImagePipeSurfaceCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkImagePipeSurfaceCreateInfoFUCHSIA>(
    const VkImagePipeSurfaceCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkMetalSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkMetalSurfaceCreateInfoEXT>(
    const VkMetalSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
template <>
VkPhysicalDeviceFragmentDensityMapFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentDensityMapPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassFragmentDensityMapCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassFragmentDensityMapCreateInfoEXT>(
    const VkRenderPassFragmentDensityMapCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderCoreProperties2AMD* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreProperties2AMD>(
    const VkPhysicalDeviceShaderCoreProperties2AMD* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCoherentMemoryFeaturesAMD* CommandRecorder::CopyArray<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryBudgetPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryPriorityFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryPriorityAllocateInfoEXT* CommandRecorder::CopyArray<VkMemoryPriorityAllocateInfoEXT>(
    const VkMemoryPriorityAllocateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkBufferDeviceAddressCreateInfoEXT* CommandRecorder::CopyArray<VkBufferDeviceAddressCreateInfoEXT>(
    const VkBufferDeviceAddressCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkValidationFeaturesEXT* CommandRecorder::CopyArray<VkValidationFeaturesEXT>(const VkValidationFeaturesEXT* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkCooperativeMatrixPropertiesNV* CommandRecorder::CopyArray<VkCooperativeMatrixPropertiesNV>(
    const VkCooperativeMatrixPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCooperativeMatrixFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCooperativeMatrixPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCoverageReductionModeFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineCoverageReductionStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineCoverageReductionStateCreateInfoNV>(
    const VkPipelineCoverageReductionStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkFramebufferMixedSamplesCombinationNV* CommandRecorder::CopyArray<VkFramebufferMixedSamplesCombinationNV>(
    const VkFramebufferMixedSamplesCombinationNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProvokingVertexFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexFeaturesEXT>(
    const VkPhysicalDeviceProvokingVertexFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceProvokingVertexPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexPropertiesEXT>(
    const VkPhysicalDeviceProvokingVertexPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(
    const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceFullScreenExclusiveInfoEXT* CommandRecorder::CopyArray<VkSurfaceFullScreenExclusiveInfoEXT>(
    const VkSurfaceFullScreenExclusiveInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceCapabilitiesFullScreenExclusiveEXT* CommandRecorder::CopyArray<VkSurfaceCapabilitiesFullScreenExclusiveEXT>(
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceFullScreenExclusiveWin32InfoEXT* CommandRecorder::CopyArray<VkSurfaceFullScreenExclusiveWin32InfoEXT>(
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_WIN32_KHR
template <>
VkHeadlessSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkHeadlessSurfaceCreateInfoEXT>(
    const VkHeadlessSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>(
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceHostImageCopyFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceHostImageCopyFeaturesEXT>(
    const VkPhysicalDeviceHostImageCopyFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceHostImageCopyPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceHostImageCopyPropertiesEXT>(
    const VkPhysicalDeviceHostImageCopyPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryToImageCopyEXT* CommandRecorder::CopyArray<VkMemoryToImageCopyEXT>(const VkMemoryToImageCopyEXT* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkImageToMemoryCopyEXT* CommandRecorder::CopyArray<VkImageToMemoryCopyEXT>(const VkImageToMemoryCopyEXT* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkCopyMemoryToImageInfoEXT* CommandRecorder::CopyArray<VkCopyMemoryToImageInfoEXT>(
    const VkCopyMemoryToImageInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCopyImageToMemoryInfoEXT* CommandRecorder::CopyArray<VkCopyImageToMemoryInfoEXT>(
    const VkCopyImageToMemoryInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCopyImageToImageInfoEXT* CommandRecorder::CopyArray<VkCopyImageToImageInfoEXT>(const VkCopyImageToImageInfoEXT* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkHostImageLayoutTransitionInfoEXT* CommandRecorder::CopyArray<VkHostImageLayoutTransitionInfoEXT>(
    const VkHostImageLayoutTransitionInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSubresourceHostMemcpySizeEXT* CommandRecorder::CopyArray<VkSubresourceHostMemcpySizeEXT>(
    const VkSubresourceHostMemcpySizeEXT* src, uint64_t start_index, uint64_t count);
template <>
VkHostImageCopyDevicePerformanceQueryEXT* CommandRecorder::CopyArray<VkHostImageCopyDevicePerformanceQueryEXT>(
    const VkHostImageCopyDevicePerformanceQueryEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>(
    const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>(
    const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryMapPlacedInfoEXT* CommandRecorder::CopyArray<VkMemoryMapPlacedInfoEXT>(const VkMemoryMapPlacedInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>(
    const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSurfacePresentModeEXT* CommandRecorder::CopyArray<VkSurfacePresentModeEXT>(const VkSurfacePresentModeEXT* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkSurfacePresentScalingCapabilitiesEXT* CommandRecorder::CopyArray<VkSurfacePresentScalingCapabilitiesEXT>(
    const VkSurfacePresentScalingCapabilitiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSurfacePresentModeCompatibilityEXT* CommandRecorder::CopyArray<VkSurfacePresentModeCompatibilityEXT>(
    const VkSurfacePresentModeCompatibilityEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT>(
    const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainPresentFenceInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentFenceInfoEXT>(
    const VkSwapchainPresentFenceInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainPresentModesCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentModesCreateInfoEXT>(
    const VkSwapchainPresentModesCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainPresentModeInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentModeInfoEXT>(
    const VkSwapchainPresentModeInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainPresentScalingCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentScalingCreateInfoEXT>(
    const VkSwapchainPresentScalingCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkReleaseSwapchainImagesInfoEXT* CommandRecorder::CopyArray<VkReleaseSwapchainImagesInfoEXT>(
    const VkReleaseSwapchainImagesInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkGraphicsShaderGroupCreateInfoNV* CommandRecorder::CopyArray<VkGraphicsShaderGroupCreateInfoNV>(
    const VkGraphicsShaderGroupCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkGraphicsPipelineShaderGroupsCreateInfoNV* CommandRecorder::CopyArray<VkGraphicsPipelineShaderGroupsCreateInfoNV>(
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkBindShaderGroupIndirectCommandNV* CommandRecorder::CopyArray<VkBindShaderGroupIndirectCommandNV>(
    const VkBindShaderGroupIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkBindIndexBufferIndirectCommandNV* CommandRecorder::CopyArray<VkBindIndexBufferIndirectCommandNV>(
    const VkBindIndexBufferIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkBindVertexBufferIndirectCommandNV* CommandRecorder::CopyArray<VkBindVertexBufferIndirectCommandNV>(
    const VkBindVertexBufferIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkSetStateFlagsIndirectCommandNV* CommandRecorder::CopyArray<VkSetStateFlagsIndirectCommandNV>(
    const VkSetStateFlagsIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkIndirectCommandsStreamNV* CommandRecorder::CopyArray<VkIndirectCommandsStreamNV>(
    const VkIndirectCommandsStreamNV* src, uint64_t start_index, uint64_t count);
template <>
VkIndirectCommandsLayoutTokenNV* CommandRecorder::CopyArray<VkIndirectCommandsLayoutTokenNV>(
    const VkIndirectCommandsLayoutTokenNV* src, uint64_t start_index, uint64_t count);
template <>
VkIndirectCommandsLayoutCreateInfoNV* CommandRecorder::CopyArray<VkIndirectCommandsLayoutCreateInfoNV>(
    const VkIndirectCommandsLayoutCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkGeneratedCommandsInfoNV* CommandRecorder::CopyArray<VkGeneratedCommandsInfoNV>(const VkGeneratedCommandsInfoNV* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkGeneratedCommandsMemoryRequirementsInfoNV* CommandRecorder::CopyArray<VkGeneratedCommandsMemoryRequirementsInfoNV>(
    const VkGeneratedCommandsMemoryRequirementsInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceInheritedViewportScissorFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>(
    const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferInheritanceViewportScissorInfoNV*
CommandRecorder::CopyArray<VkCommandBufferInheritanceViewportScissorInfoNV>(
    const VkCommandBufferInheritanceViewportScissorInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassTransformBeginInfoQCOM* CommandRecorder::CopyArray<VkRenderPassTransformBeginInfoQCOM>(
    const VkRenderPassTransformBeginInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkCommandBufferInheritanceRenderPassTransformInfoQCOM*
CommandRecorder::CopyArray<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>(
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDepthBiasControlFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthBiasControlFeaturesEXT>(
    const VkPhysicalDeviceDepthBiasControlFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDepthBiasInfoEXT* CommandRecorder::CopyArray<VkDepthBiasInfoEXT>(const VkDepthBiasInfoEXT* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkDepthBiasRepresentationInfoEXT* CommandRecorder::CopyArray<VkDepthBiasRepresentationInfoEXT>(
    const VkDepthBiasRepresentationInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceMemoryReportCallbackDataEXT* CommandRecorder::CopyArray<VkDeviceMemoryReportCallbackDataEXT>(
    const VkDeviceMemoryReportCallbackDataEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceDeviceMemoryReportCreateInfoEXT* CommandRecorder::CopyArray<VkDeviceDeviceMemoryReportCreateInfoEXT>(
    const VkDeviceDeviceMemoryReportCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRobustness2FeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2FeaturesEXT>(
    const VkPhysicalDeviceRobustness2FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRobustness2PropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2PropertiesEXT>(
    const VkPhysicalDeviceRobustness2PropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerCustomBorderColorCreateInfoEXT* CommandRecorder::CopyArray<VkSamplerCustomBorderColorCreateInfoEXT>(
    const VkSamplerCustomBorderColorCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCustomBorderColorPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCustomBorderColorFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePresentBarrierFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDevicePresentBarrierFeaturesNV>(
    const VkPhysicalDevicePresentBarrierFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkSurfaceCapabilitiesPresentBarrierNV* CommandRecorder::CopyArray<VkSurfaceCapabilitiesPresentBarrierNV>(
    const VkSurfaceCapabilitiesPresentBarrierNV* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainPresentBarrierCreateInfoNV* CommandRecorder::CopyArray<VkSwapchainPresentBarrierCreateInfoNV>(
    const VkSwapchainPresentBarrierCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDiagnosticsConfigFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>(
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceDiagnosticsConfigCreateInfoNV* CommandRecorder::CopyArray<VkDeviceDiagnosticsConfigCreateInfoNV>(
    const VkDeviceDiagnosticsConfigCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkCudaModuleCreateInfoNV* CommandRecorder::CopyArray<VkCudaModuleCreateInfoNV>(const VkCudaModuleCreateInfoNV* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkCudaFunctionCreateInfoNV* CommandRecorder::CopyArray<VkCudaFunctionCreateInfoNV>(
    const VkCudaFunctionCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkCudaLaunchInfoNV* CommandRecorder::CopyArray<VkCudaLaunchInfoNV>(const VkCudaLaunchInfoNV* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkPhysicalDeviceCudaKernelLaunchFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCudaKernelLaunchFeaturesNV>(
    const VkPhysicalDeviceCudaKernelLaunchFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCudaKernelLaunchPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCudaKernelLaunchPropertiesNV>(
    const VkPhysicalDeviceCudaKernelLaunchPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkQueryLowLatencySupportNV* CommandRecorder::CopyArray<VkQueryLowLatencySupportNV>(
    const VkQueryLowLatencySupportNV* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalObjectCreateInfoEXT* CommandRecorder::CopyArray<VkExportMetalObjectCreateInfoEXT>(
    const VkExportMetalObjectCreateInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalObjectsInfoEXT* CommandRecorder::CopyArray<VkExportMetalObjectsInfoEXT>(
    const VkExportMetalObjectsInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalDeviceInfoEXT* CommandRecorder::CopyArray<VkExportMetalDeviceInfoEXT>(
    const VkExportMetalDeviceInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalCommandQueueInfoEXT* CommandRecorder::CopyArray<VkExportMetalCommandQueueInfoEXT>(
    const VkExportMetalCommandQueueInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalBufferInfoEXT* CommandRecorder::CopyArray<VkExportMetalBufferInfoEXT>(
    const VkExportMetalBufferInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalBufferInfoEXT* CommandRecorder::CopyArray<VkImportMetalBufferInfoEXT>(
    const VkImportMetalBufferInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalTextureInfoEXT* CommandRecorder::CopyArray<VkExportMetalTextureInfoEXT>(
    const VkExportMetalTextureInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalTextureInfoEXT* CommandRecorder::CopyArray<VkImportMetalTextureInfoEXT>(
    const VkImportMetalTextureInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalIOSurfaceInfoEXT* CommandRecorder::CopyArray<VkExportMetalIOSurfaceInfoEXT>(
    const VkExportMetalIOSurfaceInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalIOSurfaceInfoEXT* CommandRecorder::CopyArray<VkImportMetalIOSurfaceInfoEXT>(
    const VkImportMetalIOSurfaceInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalSharedEventInfoEXT* CommandRecorder::CopyArray<VkExportMetalSharedEventInfoEXT>(
    const VkExportMetalSharedEventInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalSharedEventInfoEXT* CommandRecorder::CopyArray<VkImportMetalSharedEventInfoEXT>(
    const VkImportMetalSharedEventInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_METAL_EXT
template <>
VkPhysicalDeviceDescriptorBufferPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferPropertiesEXT>(
    const VkPhysicalDeviceDescriptorBufferPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>(
    const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorBufferFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferFeaturesEXT>(
    const VkPhysicalDeviceDescriptorBufferFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorAddressInfoEXT* CommandRecorder::CopyArray<VkDescriptorAddressInfoEXT>(
    const VkDescriptorAddressInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorBufferBindingInfoEXT* CommandRecorder::CopyArray<VkDescriptorBufferBindingInfoEXT>(
    const VkDescriptorBufferBindingInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*
CommandRecorder::CopyArray<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>(
    const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorDataEXT* CommandRecorder::CopyArray<VkDescriptorDataEXT>(const VkDescriptorDataEXT* src,
                                                                     uint64_t start_index, uint64_t count);
template <>
VkDescriptorGetInfoEXT* CommandRecorder::CopyArray<VkDescriptorGetInfoEXT>(const VkDescriptorGetInfoEXT* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkBufferCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkBufferCaptureDescriptorDataInfoEXT>(
    const VkBufferCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkImageCaptureDescriptorDataInfoEXT>(
    const VkImageCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageViewCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkImageViewCaptureDescriptorDataInfoEXT>(
    const VkImageViewCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkSamplerCaptureDescriptorDataInfoEXT>(
    const VkSamplerCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkOpaqueCaptureDescriptorDataCreateInfoEXT* CommandRecorder::CopyArray<VkOpaqueCaptureDescriptorDataCreateInfoEXT>(
    const VkOpaqueCaptureDescriptorDataCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureCaptureDescriptorDataInfoEXT*
CommandRecorder::CopyArray<VkAccelerationStructureCaptureDescriptorDataInfoEXT>(
    const VkAccelerationStructureCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>(
    const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>(
    const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkGraphicsPipelineLibraryCreateInfoEXT* CommandRecorder::CopyArray<VkGraphicsPipelineLibraryCreateInfoEXT>(
    const VkGraphicsPipelineLibraryCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>(
    const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>(
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>(
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineFragmentShadingRateEnumStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>(
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceOrHostAddressConstKHR* CommandRecorder::CopyArray<VkDeviceOrHostAddressConstKHR>(
    const VkDeviceOrHostAddressConstKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryMotionTrianglesDataNV*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryMotionTrianglesDataNV>(
    const VkAccelerationStructureGeometryMotionTrianglesDataNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureMotionInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInfoNV>(
    const VkAccelerationStructureMotionInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureMatrixMotionInstanceNV*
CommandRecorder::CopyArray<VkAccelerationStructureMatrixMotionInstanceNV>(
    const VkAccelerationStructureMatrixMotionInstanceNV* src, uint64_t start_index, uint64_t count);
template <>
VkSRTDataNV* CommandRecorder::CopyArray<VkSRTDataNV>(const VkSRTDataNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureSRTMotionInstanceNV* CommandRecorder::CopyArray<VkAccelerationStructureSRTMotionInstanceNV>(
    const VkAccelerationStructureSRTMotionInstanceNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureMotionInstanceDataNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInstanceDataNV>(
    const VkAccelerationStructureMotionInstanceDataNV* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureMotionInstanceNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInstanceNV>(
    const VkAccelerationStructureMotionInstanceNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>(
    const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(
    const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCopyCommandTransformInfoQCOM* CommandRecorder::CopyArray<VkCopyCommandTransformInfoQCOM>(
    const VkCopyCommandTransformInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageCompressionControlFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageCompressionControlFeaturesEXT>(
    const VkPhysicalDeviceImageCompressionControlFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageCompressionControlEXT* CommandRecorder::CopyArray<VkImageCompressionControlEXT>(
    const VkImageCompressionControlEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageCompressionPropertiesEXT* CommandRecorder::CopyArray<VkImageCompressionPropertiesEXT>(
    const VkImageCompressionPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>(
    const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevice4444FormatsFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDevice4444FormatsFeaturesEXT>(
    const VkPhysicalDevice4444FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFaultFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceFaultFeaturesEXT>(
    const VkPhysicalDeviceFaultFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceFaultCountsEXT* CommandRecorder::CopyArray<VkDeviceFaultCountsEXT>(const VkDeviceFaultCountsEXT* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkDeviceFaultAddressInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultAddressInfoEXT>(
    const VkDeviceFaultAddressInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceFaultVendorInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultVendorInfoEXT>(
    const VkDeviceFaultVendorInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceFaultInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultInfoEXT>(const VkDeviceFaultInfoEXT* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkDeviceFaultVendorBinaryHeaderVersionOneEXT* CommandRecorder::CopyArray<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>(
    const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>(
    const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>(
    const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
template <>
VkDirectFBSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkDirectFBSurfaceCreateInfoEXT>(
    const VkDirectFBSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT
template <>
VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>(
    const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMutableDescriptorTypeListEXT* CommandRecorder::CopyArray<VkMutableDescriptorTypeListEXT>(
    const VkMutableDescriptorTypeListEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMutableDescriptorTypeCreateInfoEXT* CommandRecorder::CopyArray<VkMutableDescriptorTypeCreateInfoEXT>(
    const VkMutableDescriptorTypeCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkVertexInputBindingDescription2EXT* CommandRecorder::CopyArray<VkVertexInputBindingDescription2EXT>(
    const VkVertexInputBindingDescription2EXT* src, uint64_t start_index, uint64_t count);
template <>
VkVertexInputAttributeDescription2EXT* CommandRecorder::CopyArray<VkVertexInputAttributeDescription2EXT>(
    const VkVertexInputAttributeDescription2EXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDrmPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDrmPropertiesEXT>(
    const VkPhysicalDeviceDrmPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAddressBindingReportFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAddressBindingReportFeaturesEXT>(
    const VkPhysicalDeviceAddressBindingReportFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceAddressBindingCallbackDataEXT* CommandRecorder::CopyArray<VkDeviceAddressBindingCallbackDataEXT>(
    const VkDeviceAddressBindingCallbackDataEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDepthClipControlFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipControlFeaturesEXT>(
    const VkPhysicalDeviceDepthClipControlFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineViewportDepthClipControlCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineViewportDepthClipControlCreateInfoEXT>(
    const VkPipelineViewportDepthClipControlCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>(
    const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportMemoryZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkImportMemoryZirconHandleInfoFUCHSIA>(
    const VkImportMemoryZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkMemoryZirconHandlePropertiesFUCHSIA* CommandRecorder::CopyArray<VkMemoryZirconHandlePropertiesFUCHSIA>(
    const VkMemoryZirconHandlePropertiesFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkMemoryGetZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkMemoryGetZirconHandleInfoFUCHSIA>(
    const VkMemoryGetZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportSemaphoreZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkImportSemaphoreZirconHandleInfoFUCHSIA>(
    const VkImportSemaphoreZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkSemaphoreGetZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkSemaphoreGetZirconHandleInfoFUCHSIA>(
    const VkSemaphoreGetZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionCreateInfoFUCHSIA>(
    const VkBufferCollectionCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportMemoryBufferCollectionFUCHSIA* CommandRecorder::CopyArray<VkImportMemoryBufferCollectionFUCHSIA>(
    const VkImportMemoryBufferCollectionFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionImageCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionImageCreateInfoFUCHSIA>(
    const VkBufferCollectionImageCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionConstraintsInfoFUCHSIA>(
    const VkBufferCollectionConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferConstraintsInfoFUCHSIA>(
    const VkBufferConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionBufferCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionBufferCreateInfoFUCHSIA>(
    const VkBufferCollectionBufferCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkSysmemColorSpaceFUCHSIA* CommandRecorder::CopyArray<VkSysmemColorSpaceFUCHSIA>(const VkSysmemColorSpaceFUCHSIA* src,
                                                                                 uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionPropertiesFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionPropertiesFUCHSIA>(
    const VkBufferCollectionPropertiesFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImageFormatConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkImageFormatConstraintsInfoFUCHSIA>(
    const VkImageFormatConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImageConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkImageConstraintsInfoFUCHSIA>(
    const VkImageConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_FUCHSIA
template <>
VkSubpassShadingPipelineCreateInfoHUAWEI* CommandRecorder::CopyArray<VkSubpassShadingPipelineCreateInfoHUAWEI>(
    const VkSubpassShadingPipelineCreateInfoHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* CommandRecorder::CopyArray<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>(
    const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>(
    const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* CommandRecorder::CopyArray<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>(
    const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkMemoryGetRemoteAddressInfoNV* CommandRecorder::CopyArray<VkMemoryGetRemoteAddressInfoNV>(
    const VkMemoryGetRemoteAddressInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>(
    const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelinePropertiesIdentifierEXT* CommandRecorder::CopyArray<VkPipelinePropertiesIdentifierEXT>(
    const VkPipelinePropertiesIdentifierEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelinePropertiesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelinePropertiesFeaturesEXT>(
    const VkPhysicalDevicePipelinePropertiesFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFrameBoundaryFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceFrameBoundaryFeaturesEXT>(
    const VkPhysicalDeviceFrameBoundaryFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkFrameBoundaryEXT* CommandRecorder::CopyArray<VkFrameBoundaryEXT>(const VkFrameBoundaryEXT* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>(
    const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSubpassResolvePerformanceQueryEXT* CommandRecorder::CopyArray<VkSubpassResolvePerformanceQueryEXT>(
    const VkSubpassResolvePerformanceQueryEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMultisampledRenderToSingleSampledInfoEXT* CommandRecorder::CopyArray<VkMultisampledRenderToSingleSampledInfoEXT>(
    const VkMultisampledRenderToSingleSampledInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenSurfaceCreateInfoQNX* CommandRecorder::CopyArray<VkScreenSurfaceCreateInfoQNX>(
    const VkScreenSurfaceCreateInfoQNX* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
template <>
VkPhysicalDeviceColorWriteEnableFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(
    const VkPhysicalDeviceColorWriteEnableFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineColorWriteCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineColorWriteCreateInfoEXT>(
    const VkPipelineColorWriteCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>(
    const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageViewMinLodFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImageViewMinLodFeaturesEXT>(
    const VkPhysicalDeviceImageViewMinLodFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageViewMinLodCreateInfoEXT* CommandRecorder::CopyArray<VkImageViewMinLodCreateInfoEXT>(
    const VkImageViewMinLodCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiDrawFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawFeaturesEXT>(
    const VkPhysicalDeviceMultiDrawFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiDrawPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawPropertiesEXT>(
    const VkPhysicalDeviceMultiDrawPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMultiDrawInfoEXT* CommandRecorder::CopyArray<VkMultiDrawInfoEXT>(const VkMultiDrawInfoEXT* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkMultiDrawIndexedInfoEXT* CommandRecorder::CopyArray<VkMultiDrawIndexedInfoEXT>(const VkMultiDrawIndexedInfoEXT* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>(
    const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderTileImageFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderTileImageFeaturesEXT>(
    const VkPhysicalDeviceShaderTileImageFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderTileImagePropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderTileImagePropertiesEXT>(
    const VkPhysicalDeviceShaderTileImagePropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMicromapUsageEXT* CommandRecorder::CopyArray<VkMicromapUsageEXT>(const VkMicromapUsageEXT* src, uint64_t start_index,
                                                                   uint64_t count);
template <>
VkDeviceOrHostAddressKHR* CommandRecorder::CopyArray<VkDeviceOrHostAddressKHR>(const VkDeviceOrHostAddressKHR* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkMicromapBuildInfoEXT* CommandRecorder::CopyArray<VkMicromapBuildInfoEXT>(const VkMicromapBuildInfoEXT* src,
                                                                           uint64_t start_index, uint64_t count);
template <>
VkMicromapCreateInfoEXT* CommandRecorder::CopyArray<VkMicromapCreateInfoEXT>(const VkMicromapCreateInfoEXT* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceOpacityMicromapFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceOpacityMicromapFeaturesEXT>(
    const VkPhysicalDeviceOpacityMicromapFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceOpacityMicromapPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceOpacityMicromapPropertiesEXT>(
    const VkPhysicalDeviceOpacityMicromapPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMicromapVersionInfoEXT* CommandRecorder::CopyArray<VkMicromapVersionInfoEXT>(const VkMicromapVersionInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkCopyMicromapToMemoryInfoEXT* CommandRecorder::CopyArray<VkCopyMicromapToMemoryInfoEXT>(
    const VkCopyMicromapToMemoryInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCopyMemoryToMicromapInfoEXT* CommandRecorder::CopyArray<VkCopyMemoryToMicromapInfoEXT>(
    const VkCopyMemoryToMicromapInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkCopyMicromapInfoEXT* CommandRecorder::CopyArray<VkCopyMicromapInfoEXT>(const VkCopyMicromapInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkMicromapBuildSizesInfoEXT* CommandRecorder::CopyArray<VkMicromapBuildSizesInfoEXT>(
    const VkMicromapBuildSizesInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureTrianglesOpacityMicromapEXT*
CommandRecorder::CopyArray<VkAccelerationStructureTrianglesOpacityMicromapEXT>(
    const VkAccelerationStructureTrianglesOpacityMicromapEXT* src, uint64_t start_index, uint64_t count);
template <>
VkMicromapTriangleEXT* CommandRecorder::CopyArray<VkMicromapTriangleEXT>(const VkMicromapTriangleEXT* src,
                                                                         uint64_t start_index, uint64_t count);
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceDisplacementMicromapFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDisplacementMicromapFeaturesNV>(
    const VkPhysicalDeviceDisplacementMicromapFeaturesNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceDisplacementMicromapPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDisplacementMicromapPropertiesNV>(
    const VkPhysicalDeviceDisplacementMicromapPropertiesNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkAccelerationStructureTrianglesDisplacementMicromapNV*
CommandRecorder::CopyArray<VkAccelerationStructureTrianglesDisplacementMicromapNV>(
    const VkAccelerationStructureTrianglesDisplacementMicromapNV* src, uint64_t start_index, uint64_t count);
#endif  // VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>(
    const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerBorderColorComponentMappingCreateInfoEXT*
CommandRecorder::CopyArray<VkSamplerBorderColorComponentMappingCreateInfoEXT>(
    const VkSamplerBorderColorComponentMappingCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>(
    const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderCorePropertiesARM* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesARM>(
    const VkPhysicalDeviceShaderCorePropertiesARM* src, uint64_t start_index, uint64_t count);
template <>
VkDeviceQueueShaderCoreControlCreateInfoARM* CommandRecorder::CopyArray<VkDeviceQueueShaderCoreControlCreateInfoARM>(
    const VkDeviceQueueShaderCoreControlCreateInfoARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSchedulingControlsFeaturesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceSchedulingControlsFeaturesARM>(
    const VkPhysicalDeviceSchedulingControlsFeaturesARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSchedulingControlsPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceSchedulingControlsPropertiesARM>(
    const VkPhysicalDeviceSchedulingControlsPropertiesARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>(
    const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageViewSlicedCreateInfoEXT* CommandRecorder::CopyArray<VkImageViewSlicedCreateInfoEXT>(
    const VkImageViewSlicedCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>(
    const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetBindingReferenceVALVE* CommandRecorder::CopyArray<VkDescriptorSetBindingReferenceVALVE>(
    const VkDescriptorSetBindingReferenceVALVE* src, uint64_t start_index, uint64_t count);
template <>
VkDescriptorSetLayoutHostMappingInfoVALVE* CommandRecorder::CopyArray<VkDescriptorSetLayoutHostMappingInfoVALVE>(
    const VkDescriptorSetLayoutHostMappingInfoVALVE* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>(
    const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>(
    const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRenderPassStripedFeaturesARM* CommandRecorder::CopyArray<VkPhysicalDeviceRenderPassStripedFeaturesARM>(
    const VkPhysicalDeviceRenderPassStripedFeaturesARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRenderPassStripedPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceRenderPassStripedPropertiesARM>(
    const VkPhysicalDeviceRenderPassStripedPropertiesARM* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassStripeInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeInfoARM>(const VkRenderPassStripeInfoARM* src,
                                                                                 uint64_t start_index, uint64_t count);
template <>
VkRenderPassStripeBeginInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeBeginInfoARM>(
    const VkRenderPassStripeBeginInfoARM* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassStripeSubmitInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeSubmitInfoARM>(
    const VkRenderPassStripeSubmitInfoARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>(
    const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>(
    const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkSubpassFragmentDensityMapOffsetEndInfoQCOM* CommandRecorder::CopyArray<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>(
    const VkSubpassFragmentDensityMapOffsetEndInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkCopyMemoryIndirectCommandNV* CommandRecorder::CopyArray<VkCopyMemoryIndirectCommandNV>(
    const VkCopyMemoryIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkCopyMemoryToImageIndirectCommandNV* CommandRecorder::CopyArray<VkCopyMemoryToImageIndirectCommandNV>(
    const VkCopyMemoryToImageIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>(
    const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>(
    const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkDecompressMemoryRegionNV* CommandRecorder::CopyArray<VkDecompressMemoryRegionNV>(
    const VkDecompressMemoryRegionNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryDecompressionFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceMemoryDecompressionFeaturesNV>(
    const VkPhysicalDeviceMemoryDecompressionFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMemoryDecompressionPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceMemoryDecompressionPropertiesNV>(
    const VkPhysicalDeviceMemoryDecompressionPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkComputePipelineIndirectBufferInfoNV* CommandRecorder::CopyArray<VkComputePipelineIndirectBufferInfoNV>(
    const VkComputePipelineIndirectBufferInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineIndirectDeviceAddressInfoNV* CommandRecorder::CopyArray<VkPipelineIndirectDeviceAddressInfoNV>(
    const VkPipelineIndirectDeviceAddressInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkBindPipelineIndirectCommandNV* CommandRecorder::CopyArray<VkBindPipelineIndirectCommandNV>(
    const VkBindPipelineIndirectCommandNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLinearColorAttachmentFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>(
    const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>(
    const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkImageViewSampleWeightCreateInfoQCOM* CommandRecorder::CopyArray<VkImageViewSampleWeightCreateInfoQCOM>(
    const VkImageViewSampleWeightCreateInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageProcessingFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessingFeaturesQCOM>(
    const VkPhysicalDeviceImageProcessingFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageProcessingPropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessingPropertiesQCOM>(
    const VkPhysicalDeviceImageProcessingPropertiesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceNestedCommandBufferFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>(
    const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceNestedCommandBufferPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNestedCommandBufferPropertiesEXT>(
    const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkExternalMemoryAcquireUnmodifiedEXT* CommandRecorder::CopyArray<VkExternalMemoryAcquireUnmodifiedEXT>(
    const VkExternalMemoryAcquireUnmodifiedEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>(
    const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkColorBlendEquationEXT* CommandRecorder::CopyArray<VkColorBlendEquationEXT>(const VkColorBlendEquationEXT* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkColorBlendAdvancedEXT* CommandRecorder::CopyArray<VkColorBlendAdvancedEXT>(const VkColorBlendAdvancedEXT* src,
                                                                             uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>(
    const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassCreationControlEXT* CommandRecorder::CopyArray<VkRenderPassCreationControlEXT>(
    const VkRenderPassCreationControlEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassCreationFeedbackInfoEXT* CommandRecorder::CopyArray<VkRenderPassCreationFeedbackInfoEXT>(
    const VkRenderPassCreationFeedbackInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassCreationFeedbackCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassCreationFeedbackCreateInfoEXT>(
    const VkRenderPassCreationFeedbackCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassSubpassFeedbackInfoEXT* CommandRecorder::CopyArray<VkRenderPassSubpassFeedbackInfoEXT>(
    const VkRenderPassSubpassFeedbackInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkRenderPassSubpassFeedbackCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassSubpassFeedbackCreateInfoEXT>(
    const VkRenderPassSubpassFeedbackCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDirectDriverLoadingInfoLUNARG* CommandRecorder::CopyArray<VkDirectDriverLoadingInfoLUNARG>(
    const VkDirectDriverLoadingInfoLUNARG* src, uint64_t start_index, uint64_t count);
template <>
VkDirectDriverLoadingListLUNARG* CommandRecorder::CopyArray<VkDirectDriverLoadingListLUNARG>(
    const VkDirectDriverLoadingListLUNARG* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>(
    const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>(
    const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPipelineShaderStageModuleIdentifierCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>(
    const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkShaderModuleIdentifierEXT* CommandRecorder::CopyArray<VkShaderModuleIdentifierEXT>(
    const VkShaderModuleIdentifierEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceOpticalFlowFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceOpticalFlowFeaturesNV>(
    const VkPhysicalDeviceOpticalFlowFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceOpticalFlowPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceOpticalFlowPropertiesNV>(
    const VkPhysicalDeviceOpticalFlowPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkOpticalFlowImageFormatInfoNV* CommandRecorder::CopyArray<VkOpticalFlowImageFormatInfoNV>(
    const VkOpticalFlowImageFormatInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkOpticalFlowImageFormatPropertiesNV* CommandRecorder::CopyArray<VkOpticalFlowImageFormatPropertiesNV>(
    const VkOpticalFlowImageFormatPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkOpticalFlowSessionCreateInfoNV* CommandRecorder::CopyArray<VkOpticalFlowSessionCreateInfoNV>(
    const VkOpticalFlowSessionCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkOpticalFlowSessionCreatePrivateDataInfoNV* CommandRecorder::CopyArray<VkOpticalFlowSessionCreatePrivateDataInfoNV>(
    const VkOpticalFlowSessionCreatePrivateDataInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkOpticalFlowExecuteInfoNV* CommandRecorder::CopyArray<VkOpticalFlowExecuteInfoNV>(
    const VkOpticalFlowExecuteInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLegacyDitheringFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceLegacyDitheringFeaturesEXT>(
    const VkPhysicalDeviceLegacyDitheringFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>(
    const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>(
    const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>(
    const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatResolvePropertiesANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatResolvePropertiesANDROID>(
    const VkAndroidHardwareBufferFormatResolvePropertiesANDROID* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_ANDROID_KHR
template <>
VkPhysicalDeviceShaderObjectFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderObjectFeaturesEXT>(
    const VkPhysicalDeviceShaderObjectFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderObjectPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderObjectPropertiesEXT>(
    const VkPhysicalDeviceShaderObjectPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkShaderCreateInfoEXT* CommandRecorder::CopyArray<VkShaderCreateInfoEXT>(const VkShaderCreateInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceTilePropertiesFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceTilePropertiesFeaturesQCOM>(
    const VkPhysicalDeviceTilePropertiesFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkTilePropertiesQCOM* CommandRecorder::CopyArray<VkTilePropertiesQCOM>(const VkTilePropertiesQCOM* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAmigoProfilingFeaturesSEC* CommandRecorder::CopyArray<VkPhysicalDeviceAmigoProfilingFeaturesSEC>(
    const VkPhysicalDeviceAmigoProfilingFeaturesSEC* src, uint64_t start_index, uint64_t count);
template <>
VkAmigoProfilingSubmitInfoSEC* CommandRecorder::CopyArray<VkAmigoProfilingSubmitInfoSEC>(
    const VkAmigoProfilingSubmitInfoSEC* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>(
    const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>(
    const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>(
    const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>(
    const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>(
    const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>(
    const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>(
    const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkLayerSettingEXT* CommandRecorder::CopyArray<VkLayerSettingEXT>(const VkLayerSettingEXT* src, uint64_t start_index,
                                                                 uint64_t count);
template <>
VkLayerSettingsCreateInfoEXT* CommandRecorder::CopyArray<VkLayerSettingsCreateInfoEXT>(
    const VkLayerSettingsCreateInfoEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>(
    const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>(
    const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>(
    const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>(
    const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkLatencySleepModeInfoNV* CommandRecorder::CopyArray<VkLatencySleepModeInfoNV>(const VkLatencySleepModeInfoNV* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkLatencySleepInfoNV* CommandRecorder::CopyArray<VkLatencySleepInfoNV>(const VkLatencySleepInfoNV* src,
                                                                       uint64_t start_index, uint64_t count);
template <>
VkSetLatencyMarkerInfoNV* CommandRecorder::CopyArray<VkSetLatencyMarkerInfoNV>(const VkSetLatencyMarkerInfoNV* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkLatencyTimingsFrameReportNV* CommandRecorder::CopyArray<VkLatencyTimingsFrameReportNV>(
    const VkLatencyTimingsFrameReportNV* src, uint64_t start_index, uint64_t count);
template <>
VkGetLatencyMarkerInfoNV* CommandRecorder::CopyArray<VkGetLatencyMarkerInfoNV>(const VkGetLatencyMarkerInfoNV* src,
                                                                               uint64_t start_index, uint64_t count);
template <>
VkLatencySubmissionPresentIdNV* CommandRecorder::CopyArray<VkLatencySubmissionPresentIdNV>(
    const VkLatencySubmissionPresentIdNV* src, uint64_t start_index, uint64_t count);
template <>
VkSwapchainLatencyCreateInfoNV* CommandRecorder::CopyArray<VkSwapchainLatencyCreateInfoNV>(
    const VkSwapchainLatencyCreateInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkOutOfBandQueueTypeInfoNV* CommandRecorder::CopyArray<VkOutOfBandQueueTypeInfoNV>(
    const VkOutOfBandQueueTypeInfoNV* src, uint64_t start_index, uint64_t count);
template <>
VkLatencySurfaceCapabilitiesNV* CommandRecorder::CopyArray<VkLatencySurfaceCapabilitiesNV>(
    const VkLatencySurfaceCapabilitiesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>(
    const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*
CommandRecorder::CopyArray<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>(
    const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDevicePerStageDescriptorSetFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>(
    const VkPhysicalDevicePerStageDescriptorSetFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageProcessing2FeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessing2FeaturesQCOM>(
    const VkPhysicalDeviceImageProcessing2FeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageProcessing2PropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessing2PropertiesQCOM>(
    const VkPhysicalDeviceImageProcessing2PropertiesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerBlockMatchWindowCreateInfoQCOM* CommandRecorder::CopyArray<VkSamplerBlockMatchWindowCreateInfoQCOM>(
    const VkSamplerBlockMatchWindowCreateInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCubicWeightsFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceCubicWeightsFeaturesQCOM>(
    const VkPhysicalDeviceCubicWeightsFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerCubicWeightsCreateInfoQCOM* CommandRecorder::CopyArray<VkSamplerCubicWeightsCreateInfoQCOM>(
    const VkSamplerCubicWeightsCreateInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkBlitImageCubicWeightsInfoQCOM* CommandRecorder::CopyArray<VkBlitImageCubicWeightsInfoQCOM>(
    const VkBlitImageCubicWeightsInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>(
    const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*
CommandRecorder::CopyArray<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>(
    const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceCubicClampFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceCubicClampFeaturesQCOM>(
    const VkPhysicalDeviceCubicClampFeaturesQCOM* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count);
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenBufferPropertiesQNX* CommandRecorder::CopyArray<VkScreenBufferPropertiesQNX>(
    const VkScreenBufferPropertiesQNX* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenBufferFormatPropertiesQNX* CommandRecorder::CopyArray<VkScreenBufferFormatPropertiesQNX>(
    const VkScreenBufferFormatPropertiesQNX* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkImportScreenBufferInfoQNX* CommandRecorder::CopyArray<VkImportScreenBufferInfoQNX>(
    const VkImportScreenBufferInfoQNX* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkExternalFormatQNX* CommandRecorder::CopyArray<VkExternalFormatQNX>(const VkExternalFormatQNX* src,
                                                                     uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>(
    const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX* src, uint64_t start_index, uint64_t count);
#endif  // VK_USE_PLATFORM_SCREEN_QNX
template <>
VkPhysicalDeviceLayeredDriverPropertiesMSFT* CommandRecorder::CopyArray<VkPhysicalDeviceLayeredDriverPropertiesMSFT>(
    const VkPhysicalDeviceLayeredDriverPropertiesMSFT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>(
    const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRawAccessChainsFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceRawAccessChainsFeaturesNV>(
    const VkPhysicalDeviceRawAccessChainsFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>(
    const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>(
    const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingValidationFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingValidationFeaturesNV>(
    const VkPhysicalDeviceRayTracingValidationFeaturesNV* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageAlignmentControlFeaturesMESA*
CommandRecorder::CopyArray<VkPhysicalDeviceImageAlignmentControlFeaturesMESA>(
    const VkPhysicalDeviceImageAlignmentControlFeaturesMESA* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceImageAlignmentControlPropertiesMESA*
CommandRecorder::CopyArray<VkPhysicalDeviceImageAlignmentControlPropertiesMESA>(
    const VkPhysicalDeviceImageAlignmentControlPropertiesMESA* src, uint64_t start_index, uint64_t count);
template <>
VkImageAlignmentControlCreateInfoMESA* CommandRecorder::CopyArray<VkImageAlignmentControlCreateInfoMESA>(
    const VkImageAlignmentControlCreateInfoMESA* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureBuildRangeInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildRangeInfoKHR>(
    const VkAccelerationStructureBuildRangeInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryTrianglesDataKHR*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryTrianglesDataKHR>(
    const VkAccelerationStructureGeometryTrianglesDataKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryAabbsDataKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryAabbsDataKHR>(
    const VkAccelerationStructureGeometryAabbsDataKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryInstancesDataKHR*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryInstancesDataKHR>(
    const VkAccelerationStructureGeometryInstancesDataKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryDataKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryDataKHR>(
    const VkAccelerationStructureGeometryDataKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureGeometryKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryKHR>(
    const VkAccelerationStructureGeometryKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureBuildGeometryInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildGeometryInfoKHR>(
    const VkAccelerationStructureBuildGeometryInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureCreateInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoKHR>(
    const VkAccelerationStructureCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkWriteDescriptorSetAccelerationStructureKHR* CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureKHR>(
    const VkWriteDescriptorSetAccelerationStructureKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAccelerationStructureFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceAccelerationStructurePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureDeviceAddressInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureDeviceAddressInfoKHR>(
    const VkAccelerationStructureDeviceAddressInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureVersionInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureVersionInfoKHR>(
    const VkAccelerationStructureVersionInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkCopyAccelerationStructureToMemoryInfoKHR* CommandRecorder::CopyArray<VkCopyAccelerationStructureToMemoryInfoKHR>(
    const VkCopyAccelerationStructureToMemoryInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkCopyMemoryToAccelerationStructureInfoKHR* CommandRecorder::CopyArray<VkCopyMemoryToAccelerationStructureInfoKHR>(
    const VkCopyMemoryToAccelerationStructureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkCopyAccelerationStructureInfoKHR* CommandRecorder::CopyArray<VkCopyAccelerationStructureInfoKHR>(
    const VkCopyAccelerationStructureInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkAccelerationStructureBuildSizesInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildSizesInfoKHR>(
    const VkAccelerationStructureBuildSizesInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRayTracingShaderGroupCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoKHR>(
    const VkRayTracingShaderGroupCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRayTracingPipelineInterfaceCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingPipelineInterfaceCreateInfoKHR>(
    const VkRayTracingPipelineInterfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkRayTracingPipelineCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoKHR>(
    const VkRayTracingPipelineCreateInfoKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingPipelineFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayTracingPipelinePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkStridedDeviceAddressRegionKHR* CommandRecorder::CopyArray<VkStridedDeviceAddressRegionKHR>(
    const VkStridedDeviceAddressRegionKHR* src, uint64_t start_index, uint64_t count);
template <>
VkTraceRaysIndirectCommandKHR* CommandRecorder::CopyArray<VkTraceRaysIndirectCommandKHR>(
    const VkTraceRaysIndirectCommandKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceRayQueryFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceRayQueryFeaturesKHR>(
    const VkPhysicalDeviceRayQueryFeaturesKHR* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMeshShaderFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderFeaturesEXT>(
    const VkPhysicalDeviceMeshShaderFeaturesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkPhysicalDeviceMeshShaderPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderPropertiesEXT>(
    const VkPhysicalDeviceMeshShaderPropertiesEXT* src, uint64_t start_index, uint64_t count);
template <>
VkDrawMeshTasksIndirectCommandEXT* CommandRecorder::CopyArray<VkDrawMeshTasksIndirectCommandEXT>(
    const VkDrawMeshTasksIndirectCommandEXT* src, uint64_t start_index, uint64_t count);

// Define CopyArray template functions.

template <>
uint8_t* CommandRecorder::CopyArray<uint8_t>(const uint8_t* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<uint8_t*>(m_allocator.Alloc(sizeof(uint8_t) * count));
    memcpy(ptr, src, sizeof(uint8_t) * count);
    return ptr;
}
template <>
VkExtent2D* CommandRecorder::CopyArray<VkExtent2D>(const VkExtent2D* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExtent2D*>(m_allocator.Alloc(sizeof(VkExtent2D) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
    }
    return ptr;
}

template <>
VkExtent3D* CommandRecorder::CopyArray<VkExtent3D>(const VkExtent3D* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExtent3D*>(m_allocator.Alloc(sizeof(VkExtent3D) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].depth = src[start_index + i].depth;
    }
    return ptr;
}

template <>
VkOffset2D* CommandRecorder::CopyArray<VkOffset2D>(const VkOffset2D* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOffset2D*>(m_allocator.Alloc(sizeof(VkOffset2D) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
    }
    return ptr;
}

template <>
VkOffset3D* CommandRecorder::CopyArray<VkOffset3D>(const VkOffset3D* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOffset3D*>(m_allocator.Alloc(sizeof(VkOffset3D) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
        ptr[i].z = src[start_index + i].z;
    }
    return ptr;
}

template <>
VkRect2D* CommandRecorder::CopyArray<VkRect2D>(const VkRect2D* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRect2D*>(m_allocator.Alloc(sizeof(VkRect2D) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].extent = src[start_index + i].extent;
    }
    return ptr;
}

template <>
VkBaseInStructure* CommandRecorder::CopyArray<VkBaseInStructure>(const VkBaseInStructure* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkBaseInStructure*>(m_allocator.Alloc(sizeof(VkBaseInStructure) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
    }
    return ptr;
}

template <>
VkBaseOutStructure* CommandRecorder::CopyArray<VkBaseOutStructure>(const VkBaseOutStructure* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkBaseOutStructure*>(m_allocator.Alloc(sizeof(VkBaseOutStructure) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
    }
    return ptr;
}

template <>
VkBufferMemoryBarrier* CommandRecorder::CopyArray<VkBufferMemoryBarrier>(const VkBufferMemoryBarrier* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferMemoryBarrier*>(m_allocator.Alloc(sizeof(VkBufferMemoryBarrier) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkDispatchIndirectCommand* CommandRecorder::CopyArray<VkDispatchIndirectCommand>(const VkDispatchIndirectCommand* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDispatchIndirectCommand*>(m_allocator.Alloc(sizeof(VkDispatchIndirectCommand) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
        ptr[i].z = src[start_index + i].z;
    }
    return ptr;
}

template <>
VkDrawIndexedIndirectCommand* CommandRecorder::CopyArray<VkDrawIndexedIndirectCommand>(
    const VkDrawIndexedIndirectCommand* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrawIndexedIndirectCommand*>(
        m_allocator.Alloc(sizeof(VkDrawIndexedIndirectCommand) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].indexCount = src[start_index + i].indexCount;
        ptr[i].instanceCount = src[start_index + i].instanceCount;
        ptr[i].firstIndex = src[start_index + i].firstIndex;
        ptr[i].vertexOffset = src[start_index + i].vertexOffset;
        ptr[i].firstInstance = src[start_index + i].firstInstance;
    }
    return ptr;
}

template <>
VkDrawIndirectCommand* CommandRecorder::CopyArray<VkDrawIndirectCommand>(const VkDrawIndirectCommand* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrawIndirectCommand*>(m_allocator.Alloc(sizeof(VkDrawIndirectCommand) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].vertexCount = src[start_index + i].vertexCount;
        ptr[i].instanceCount = src[start_index + i].instanceCount;
        ptr[i].firstVertex = src[start_index + i].firstVertex;
        ptr[i].firstInstance = src[start_index + i].firstInstance;
    }
    return ptr;
}

template <>
VkImageSubresourceRange* CommandRecorder::CopyArray<VkImageSubresourceRange>(const VkImageSubresourceRange* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSubresourceRange*>(m_allocator.Alloc(sizeof(VkImageSubresourceRange) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].aspectMask = src[start_index + i].aspectMask;
        ptr[i].baseMipLevel = src[start_index + i].baseMipLevel;
        ptr[i].levelCount = src[start_index + i].levelCount;
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
        ptr[i].layerCount = src[start_index + i].layerCount;
    }
    return ptr;
}

template <>
VkImageMemoryBarrier* CommandRecorder::CopyArray<VkImageMemoryBarrier>(const VkImageMemoryBarrier* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageMemoryBarrier*>(m_allocator.Alloc(sizeof(VkImageMemoryBarrier) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].oldLayout = src[start_index + i].oldLayout;
        ptr[i].newLayout = src[start_index + i].newLayout;
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
        ptr[i].image = src[start_index + i].image;
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;
    }
    return ptr;
}

template <>
VkMemoryBarrier* CommandRecorder::CopyArray<VkMemoryBarrier>(const VkMemoryBarrier* src, uint64_t start_index,
                                                             uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryBarrier*>(m_allocator.Alloc(sizeof(VkMemoryBarrier) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
    }
    return ptr;
}

template <>
VkPipelineCacheHeaderVersionOne* CommandRecorder::CopyArray<VkPipelineCacheHeaderVersionOne>(
    const VkPipelineCacheHeaderVersionOne* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCacheHeaderVersionOne*>(
        m_allocator.Alloc(sizeof(VkPipelineCacheHeaderVersionOne) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].headerSize = src[start_index + i].headerSize;
        ptr[i].headerVersion = src[start_index + i].headerVersion;
        ptr[i].vendorID = src[start_index + i].vendorID;
        ptr[i].deviceID = src[start_index + i].deviceID;
        std::memcpy(ptr[i].pipelineCacheUUID, src[start_index + i].pipelineCacheUUID,
                    sizeof(src[start_index + i].pipelineCacheUUID));
    }
    return ptr;
}

template <>
VkAllocationCallbacks* CommandRecorder::CopyArray<VkAllocationCallbacks>(const VkAllocationCallbacks* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAllocationCallbacks*>(m_allocator.Alloc(sizeof(VkAllocationCallbacks) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].pUserData = src[start_index + i].pUserData;
        ptr[i].pfnAllocation = src[start_index + i].pfnAllocation;
        ptr[i].pfnReallocation = src[start_index + i].pfnReallocation;
        ptr[i].pfnFree = src[start_index + i].pfnFree;
        ptr[i].pfnInternalAllocation = src[start_index + i].pfnInternalAllocation;
        ptr[i].pfnInternalFree = src[start_index + i].pfnInternalFree;
    }
    return ptr;
}

template <>
VkApplicationInfo* CommandRecorder::CopyArray<VkApplicationInfo>(const VkApplicationInfo* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkApplicationInfo*>(m_allocator.Alloc(sizeof(VkApplicationInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pApplicationName = nullptr;
        if (src[start_index + i].pApplicationName) {
            ptr[i].pApplicationName = CopyArray<>(src[start_index + i].pApplicationName, 0,
                                                  strlen(src[start_index + i].pApplicationName) + 1);
        }
        ptr[i].applicationVersion = src[start_index + i].applicationVersion;
        ptr[i].pEngineName = nullptr;
        if (src[start_index + i].pEngineName) {
            ptr[i].pEngineName =
                CopyArray<>(src[start_index + i].pEngineName, 0, strlen(src[start_index + i].pEngineName) + 1);
        }
        ptr[i].engineVersion = src[start_index + i].engineVersion;
        ptr[i].apiVersion = src[start_index + i].apiVersion;
    }
    return ptr;
}

template <>
VkFormatProperties* CommandRecorder::CopyArray<VkFormatProperties>(const VkFormatProperties* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkFormatProperties*>(m_allocator.Alloc(sizeof(VkFormatProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].linearTilingFeatures = src[start_index + i].linearTilingFeatures;
        ptr[i].optimalTilingFeatures = src[start_index + i].optimalTilingFeatures;
        ptr[i].bufferFeatures = src[start_index + i].bufferFeatures;
    }
    return ptr;
}

template <>
VkImageFormatProperties* CommandRecorder::CopyArray<VkImageFormatProperties>(const VkImageFormatProperties* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageFormatProperties*>(m_allocator.Alloc(sizeof(VkImageFormatProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].maxExtent = src[start_index + i].maxExtent;
        ptr[i].maxMipLevels = src[start_index + i].maxMipLevels;
        ptr[i].maxArrayLayers = src[start_index + i].maxArrayLayers;
        ptr[i].sampleCounts = src[start_index + i].sampleCounts;
        ptr[i].maxResourceSize = src[start_index + i].maxResourceSize;
    }
    return ptr;
}

template <>
VkInstanceCreateInfo* CommandRecorder::CopyArray<VkInstanceCreateInfo>(const VkInstanceCreateInfo* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkInstanceCreateInfo*>(m_allocator.Alloc(sizeof(VkInstanceCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pApplicationInfo = src[start_index + i].pApplicationInfo;
        ptr[i].enabledLayerCount = src[start_index + i].enabledLayerCount;
        ptr[i].ppEnabledLayerNames = nullptr;
        if (src[start_index + i].ppEnabledLayerNames) {
            ptr[i].ppEnabledLayerNames = CopyArray<>(src[start_index + i].ppEnabledLayerNames, 0, 1);
        }
        ptr[i].enabledExtensionCount = src[start_index + i].enabledExtensionCount;
        ptr[i].ppEnabledExtensionNames = nullptr;
        if (src[start_index + i].ppEnabledExtensionNames) {
            ptr[i].ppEnabledExtensionNames = CopyArray<>(src[start_index + i].ppEnabledExtensionNames, 0, 1);
        }
    }
    return ptr;
}

template <>
VkMemoryHeap* CommandRecorder::CopyArray<VkMemoryHeap>(const VkMemoryHeap* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryHeap*>(m_allocator.Alloc(sizeof(VkMemoryHeap) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].size = src[start_index + i].size;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkMemoryType* CommandRecorder::CopyArray<VkMemoryType>(const VkMemoryType* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryType*>(m_allocator.Alloc(sizeof(VkMemoryType) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].propertyFlags = src[start_index + i].propertyFlags;
        ptr[i].heapIndex = src[start_index + i].heapIndex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceFeatures>(const VkPhysicalDeviceFeatures* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFeatures*>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].robustBufferAccess = src[start_index + i].robustBufferAccess;
        ptr[i].fullDrawIndexUint32 = src[start_index + i].fullDrawIndexUint32;
        ptr[i].imageCubeArray = src[start_index + i].imageCubeArray;
        ptr[i].independentBlend = src[start_index + i].independentBlend;
        ptr[i].geometryShader = src[start_index + i].geometryShader;
        ptr[i].tessellationShader = src[start_index + i].tessellationShader;
        ptr[i].sampleRateShading = src[start_index + i].sampleRateShading;
        ptr[i].dualSrcBlend = src[start_index + i].dualSrcBlend;
        ptr[i].logicOp = src[start_index + i].logicOp;
        ptr[i].multiDrawIndirect = src[start_index + i].multiDrawIndirect;
        ptr[i].drawIndirectFirstInstance = src[start_index + i].drawIndirectFirstInstance;
        ptr[i].depthClamp = src[start_index + i].depthClamp;
        ptr[i].depthBiasClamp = src[start_index + i].depthBiasClamp;
        ptr[i].fillModeNonSolid = src[start_index + i].fillModeNonSolid;
        ptr[i].depthBounds = src[start_index + i].depthBounds;
        ptr[i].wideLines = src[start_index + i].wideLines;
        ptr[i].largePoints = src[start_index + i].largePoints;
        ptr[i].alphaToOne = src[start_index + i].alphaToOne;
        ptr[i].multiViewport = src[start_index + i].multiViewport;
        ptr[i].samplerAnisotropy = src[start_index + i].samplerAnisotropy;
        ptr[i].textureCompressionETC2 = src[start_index + i].textureCompressionETC2;
        ptr[i].textureCompressionASTC_LDR = src[start_index + i].textureCompressionASTC_LDR;
        ptr[i].textureCompressionBC = src[start_index + i].textureCompressionBC;
        ptr[i].occlusionQueryPrecise = src[start_index + i].occlusionQueryPrecise;
        ptr[i].pipelineStatisticsQuery = src[start_index + i].pipelineStatisticsQuery;
        ptr[i].vertexPipelineStoresAndAtomics = src[start_index + i].vertexPipelineStoresAndAtomics;
        ptr[i].fragmentStoresAndAtomics = src[start_index + i].fragmentStoresAndAtomics;
        ptr[i].shaderTessellationAndGeometryPointSize = src[start_index + i].shaderTessellationAndGeometryPointSize;
        ptr[i].shaderImageGatherExtended = src[start_index + i].shaderImageGatherExtended;
        ptr[i].shaderStorageImageExtendedFormats = src[start_index + i].shaderStorageImageExtendedFormats;
        ptr[i].shaderStorageImageMultisample = src[start_index + i].shaderStorageImageMultisample;
        ptr[i].shaderStorageImageReadWithoutFormat = src[start_index + i].shaderStorageImageReadWithoutFormat;
        ptr[i].shaderStorageImageWriteWithoutFormat = src[start_index + i].shaderStorageImageWriteWithoutFormat;
        ptr[i].shaderUniformBufferArrayDynamicIndexing = src[start_index + i].shaderUniformBufferArrayDynamicIndexing;
        ptr[i].shaderSampledImageArrayDynamicIndexing = src[start_index + i].shaderSampledImageArrayDynamicIndexing;
        ptr[i].shaderStorageBufferArrayDynamicIndexing = src[start_index + i].shaderStorageBufferArrayDynamicIndexing;
        ptr[i].shaderStorageImageArrayDynamicIndexing = src[start_index + i].shaderStorageImageArrayDynamicIndexing;
        ptr[i].shaderClipDistance = src[start_index + i].shaderClipDistance;
        ptr[i].shaderCullDistance = src[start_index + i].shaderCullDistance;
        ptr[i].shaderFloat64 = src[start_index + i].shaderFloat64;
        ptr[i].shaderInt64 = src[start_index + i].shaderInt64;
        ptr[i].shaderInt16 = src[start_index + i].shaderInt16;
        ptr[i].shaderResourceResidency = src[start_index + i].shaderResourceResidency;
        ptr[i].shaderResourceMinLod = src[start_index + i].shaderResourceMinLod;
        ptr[i].sparseBinding = src[start_index + i].sparseBinding;
        ptr[i].sparseResidencyBuffer = src[start_index + i].sparseResidencyBuffer;
        ptr[i].sparseResidencyImage2D = src[start_index + i].sparseResidencyImage2D;
        ptr[i].sparseResidencyImage3D = src[start_index + i].sparseResidencyImage3D;
        ptr[i].sparseResidency2Samples = src[start_index + i].sparseResidency2Samples;
        ptr[i].sparseResidency4Samples = src[start_index + i].sparseResidency4Samples;
        ptr[i].sparseResidency8Samples = src[start_index + i].sparseResidency8Samples;
        ptr[i].sparseResidency16Samples = src[start_index + i].sparseResidency16Samples;
        ptr[i].sparseResidencyAliased = src[start_index + i].sparseResidencyAliased;
        ptr[i].variableMultisampleRate = src[start_index + i].variableMultisampleRate;
        ptr[i].inheritedQueries = src[start_index + i].inheritedQueries;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLimits* CommandRecorder::CopyArray<VkPhysicalDeviceLimits>(const VkPhysicalDeviceLimits* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLimits*>(m_allocator.Alloc(sizeof(VkPhysicalDeviceLimits) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].maxImageDimension1D = src[start_index + i].maxImageDimension1D;
        ptr[i].maxImageDimension2D = src[start_index + i].maxImageDimension2D;
        ptr[i].maxImageDimension3D = src[start_index + i].maxImageDimension3D;
        ptr[i].maxImageDimensionCube = src[start_index + i].maxImageDimensionCube;
        ptr[i].maxImageArrayLayers = src[start_index + i].maxImageArrayLayers;
        ptr[i].maxTexelBufferElements = src[start_index + i].maxTexelBufferElements;
        ptr[i].maxUniformBufferRange = src[start_index + i].maxUniformBufferRange;
        ptr[i].maxStorageBufferRange = src[start_index + i].maxStorageBufferRange;
        ptr[i].maxPushConstantsSize = src[start_index + i].maxPushConstantsSize;
        ptr[i].maxMemoryAllocationCount = src[start_index + i].maxMemoryAllocationCount;
        ptr[i].maxSamplerAllocationCount = src[start_index + i].maxSamplerAllocationCount;
        ptr[i].bufferImageGranularity = src[start_index + i].bufferImageGranularity;
        ptr[i].sparseAddressSpaceSize = src[start_index + i].sparseAddressSpaceSize;
        ptr[i].maxBoundDescriptorSets = src[start_index + i].maxBoundDescriptorSets;
        ptr[i].maxPerStageDescriptorSamplers = src[start_index + i].maxPerStageDescriptorSamplers;
        ptr[i].maxPerStageDescriptorUniformBuffers = src[start_index + i].maxPerStageDescriptorUniformBuffers;
        ptr[i].maxPerStageDescriptorStorageBuffers = src[start_index + i].maxPerStageDescriptorStorageBuffers;
        ptr[i].maxPerStageDescriptorSampledImages = src[start_index + i].maxPerStageDescriptorSampledImages;
        ptr[i].maxPerStageDescriptorStorageImages = src[start_index + i].maxPerStageDescriptorStorageImages;
        ptr[i].maxPerStageDescriptorInputAttachments = src[start_index + i].maxPerStageDescriptorInputAttachments;
        ptr[i].maxPerStageResources = src[start_index + i].maxPerStageResources;
        ptr[i].maxDescriptorSetSamplers = src[start_index + i].maxDescriptorSetSamplers;
        ptr[i].maxDescriptorSetUniformBuffers = src[start_index + i].maxDescriptorSetUniformBuffers;
        ptr[i].maxDescriptorSetUniformBuffersDynamic = src[start_index + i].maxDescriptorSetUniformBuffersDynamic;
        ptr[i].maxDescriptorSetStorageBuffers = src[start_index + i].maxDescriptorSetStorageBuffers;
        ptr[i].maxDescriptorSetStorageBuffersDynamic = src[start_index + i].maxDescriptorSetStorageBuffersDynamic;
        ptr[i].maxDescriptorSetSampledImages = src[start_index + i].maxDescriptorSetSampledImages;
        ptr[i].maxDescriptorSetStorageImages = src[start_index + i].maxDescriptorSetStorageImages;
        ptr[i].maxDescriptorSetInputAttachments = src[start_index + i].maxDescriptorSetInputAttachments;
        ptr[i].maxVertexInputAttributes = src[start_index + i].maxVertexInputAttributes;
        ptr[i].maxVertexInputBindings = src[start_index + i].maxVertexInputBindings;
        ptr[i].maxVertexInputAttributeOffset = src[start_index + i].maxVertexInputAttributeOffset;
        ptr[i].maxVertexInputBindingStride = src[start_index + i].maxVertexInputBindingStride;
        ptr[i].maxVertexOutputComponents = src[start_index + i].maxVertexOutputComponents;
        ptr[i].maxTessellationGenerationLevel = src[start_index + i].maxTessellationGenerationLevel;
        ptr[i].maxTessellationPatchSize = src[start_index + i].maxTessellationPatchSize;
        ptr[i].maxTessellationControlPerVertexInputComponents =
            src[start_index + i].maxTessellationControlPerVertexInputComponents;
        ptr[i].maxTessellationControlPerVertexOutputComponents =
            src[start_index + i].maxTessellationControlPerVertexOutputComponents;
        ptr[i].maxTessellationControlPerPatchOutputComponents =
            src[start_index + i].maxTessellationControlPerPatchOutputComponents;
        ptr[i].maxTessellationControlTotalOutputComponents =
            src[start_index + i].maxTessellationControlTotalOutputComponents;
        ptr[i].maxTessellationEvaluationInputComponents = src[start_index + i].maxTessellationEvaluationInputComponents;
        ptr[i].maxTessellationEvaluationOutputComponents =
            src[start_index + i].maxTessellationEvaluationOutputComponents;
        ptr[i].maxGeometryShaderInvocations = src[start_index + i].maxGeometryShaderInvocations;
        ptr[i].maxGeometryInputComponents = src[start_index + i].maxGeometryInputComponents;
        ptr[i].maxGeometryOutputComponents = src[start_index + i].maxGeometryOutputComponents;
        ptr[i].maxGeometryOutputVertices = src[start_index + i].maxGeometryOutputVertices;
        ptr[i].maxGeometryTotalOutputComponents = src[start_index + i].maxGeometryTotalOutputComponents;
        ptr[i].maxFragmentInputComponents = src[start_index + i].maxFragmentInputComponents;
        ptr[i].maxFragmentOutputAttachments = src[start_index + i].maxFragmentOutputAttachments;
        ptr[i].maxFragmentDualSrcAttachments = src[start_index + i].maxFragmentDualSrcAttachments;
        ptr[i].maxFragmentCombinedOutputResources = src[start_index + i].maxFragmentCombinedOutputResources;
        ptr[i].maxComputeSharedMemorySize = src[start_index + i].maxComputeSharedMemorySize;
        std::memcpy(ptr[i].maxComputeWorkGroupCount, src[start_index + i].maxComputeWorkGroupCount,
                    sizeof(src[start_index + i].maxComputeWorkGroupCount));
        ptr[i].maxComputeWorkGroupInvocations = src[start_index + i].maxComputeWorkGroupInvocations;
        std::memcpy(ptr[i].maxComputeWorkGroupSize, src[start_index + i].maxComputeWorkGroupSize,
                    sizeof(src[start_index + i].maxComputeWorkGroupSize));
        ptr[i].subPixelPrecisionBits = src[start_index + i].subPixelPrecisionBits;
        ptr[i].subTexelPrecisionBits = src[start_index + i].subTexelPrecisionBits;
        ptr[i].mipmapPrecisionBits = src[start_index + i].mipmapPrecisionBits;
        ptr[i].maxDrawIndexedIndexValue = src[start_index + i].maxDrawIndexedIndexValue;
        ptr[i].maxDrawIndirectCount = src[start_index + i].maxDrawIndirectCount;
        ptr[i].maxSamplerLodBias = src[start_index + i].maxSamplerLodBias;
        ptr[i].maxSamplerAnisotropy = src[start_index + i].maxSamplerAnisotropy;
        ptr[i].maxViewports = src[start_index + i].maxViewports;
        std::memcpy(ptr[i].maxViewportDimensions, src[start_index + i].maxViewportDimensions,
                    sizeof(src[start_index + i].maxViewportDimensions));
        std::memcpy(ptr[i].viewportBoundsRange, src[start_index + i].viewportBoundsRange,
                    sizeof(src[start_index + i].viewportBoundsRange));
        ptr[i].viewportSubPixelBits = src[start_index + i].viewportSubPixelBits;
        ptr[i].minMemoryMapAlignment = src[start_index + i].minMemoryMapAlignment;
        ptr[i].minTexelBufferOffsetAlignment = src[start_index + i].minTexelBufferOffsetAlignment;
        ptr[i].minUniformBufferOffsetAlignment = src[start_index + i].minUniformBufferOffsetAlignment;
        ptr[i].minStorageBufferOffsetAlignment = src[start_index + i].minStorageBufferOffsetAlignment;
        ptr[i].minTexelOffset = src[start_index + i].minTexelOffset;
        ptr[i].maxTexelOffset = src[start_index + i].maxTexelOffset;
        ptr[i].minTexelGatherOffset = src[start_index + i].minTexelGatherOffset;
        ptr[i].maxTexelGatherOffset = src[start_index + i].maxTexelGatherOffset;
        ptr[i].minInterpolationOffset = src[start_index + i].minInterpolationOffset;
        ptr[i].maxInterpolationOffset = src[start_index + i].maxInterpolationOffset;
        ptr[i].subPixelInterpolationOffsetBits = src[start_index + i].subPixelInterpolationOffsetBits;
        ptr[i].maxFramebufferWidth = src[start_index + i].maxFramebufferWidth;
        ptr[i].maxFramebufferHeight = src[start_index + i].maxFramebufferHeight;
        ptr[i].maxFramebufferLayers = src[start_index + i].maxFramebufferLayers;
        ptr[i].framebufferColorSampleCounts = src[start_index + i].framebufferColorSampleCounts;
        ptr[i].framebufferDepthSampleCounts = src[start_index + i].framebufferDepthSampleCounts;
        ptr[i].framebufferStencilSampleCounts = src[start_index + i].framebufferStencilSampleCounts;
        ptr[i].framebufferNoAttachmentsSampleCounts = src[start_index + i].framebufferNoAttachmentsSampleCounts;
        ptr[i].maxColorAttachments = src[start_index + i].maxColorAttachments;
        ptr[i].sampledImageColorSampleCounts = src[start_index + i].sampledImageColorSampleCounts;
        ptr[i].sampledImageIntegerSampleCounts = src[start_index + i].sampledImageIntegerSampleCounts;
        ptr[i].sampledImageDepthSampleCounts = src[start_index + i].sampledImageDepthSampleCounts;
        ptr[i].sampledImageStencilSampleCounts = src[start_index + i].sampledImageStencilSampleCounts;
        ptr[i].storageImageSampleCounts = src[start_index + i].storageImageSampleCounts;
        ptr[i].maxSampleMaskWords = src[start_index + i].maxSampleMaskWords;
        ptr[i].timestampComputeAndGraphics = src[start_index + i].timestampComputeAndGraphics;
        ptr[i].timestampPeriod = src[start_index + i].timestampPeriod;
        ptr[i].maxClipDistances = src[start_index + i].maxClipDistances;
        ptr[i].maxCullDistances = src[start_index + i].maxCullDistances;
        ptr[i].maxCombinedClipAndCullDistances = src[start_index + i].maxCombinedClipAndCullDistances;
        ptr[i].discreteQueuePriorities = src[start_index + i].discreteQueuePriorities;
        std::memcpy(ptr[i].pointSizeRange, src[start_index + i].pointSizeRange,
                    sizeof(src[start_index + i].pointSizeRange));
        std::memcpy(ptr[i].lineWidthRange, src[start_index + i].lineWidthRange,
                    sizeof(src[start_index + i].lineWidthRange));
        ptr[i].pointSizeGranularity = src[start_index + i].pointSizeGranularity;
        ptr[i].lineWidthGranularity = src[start_index + i].lineWidthGranularity;
        ptr[i].strictLines = src[start_index + i].strictLines;
        ptr[i].standardSampleLocations = src[start_index + i].standardSampleLocations;
        ptr[i].optimalBufferCopyOffsetAlignment = src[start_index + i].optimalBufferCopyOffsetAlignment;
        ptr[i].optimalBufferCopyRowPitchAlignment = src[start_index + i].optimalBufferCopyRowPitchAlignment;
        ptr[i].nonCoherentAtomSize = src[start_index + i].nonCoherentAtomSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryProperties* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties>(
    const VkPhysicalDeviceMemoryProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].memoryTypeCount = src[start_index + i].memoryTypeCount;
        std::memcpy(ptr[i].memoryTypes, src[start_index + i].memoryTypes, sizeof(src[start_index + i].memoryTypes));
        ptr[i].memoryHeapCount = src[start_index + i].memoryHeapCount;
        std::memcpy(ptr[i].memoryHeaps, src[start_index + i].memoryHeaps, sizeof(src[start_index + i].memoryHeaps));
    }
    return ptr;
}

template <>
VkPhysicalDeviceSparseProperties* CommandRecorder::CopyArray<VkPhysicalDeviceSparseProperties>(
    const VkPhysicalDeviceSparseProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSparseProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSparseProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].residencyStandard2DBlockShape = src[start_index + i].residencyStandard2DBlockShape;
        ptr[i].residencyStandard2DMultisampleBlockShape = src[start_index + i].residencyStandard2DMultisampleBlockShape;
        ptr[i].residencyStandard3DBlockShape = src[start_index + i].residencyStandard3DBlockShape;
        ptr[i].residencyAlignedMipSize = src[start_index + i].residencyAlignedMipSize;
        ptr[i].residencyNonResidentStrict = src[start_index + i].residencyNonResidentStrict;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProperties* CommandRecorder::CopyArray<VkPhysicalDeviceProperties>(
    const VkPhysicalDeviceProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPhysicalDeviceProperties*>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].apiVersion = src[start_index + i].apiVersion;
        ptr[i].driverVersion = src[start_index + i].driverVersion;
        ptr[i].vendorID = src[start_index + i].vendorID;
        ptr[i].deviceID = src[start_index + i].deviceID;
        ptr[i].deviceType = src[start_index + i].deviceType;
        std::memcpy(ptr[i].deviceName, src[start_index + i].deviceName, sizeof(src[start_index + i].deviceName));
        std::memcpy(ptr[i].pipelineCacheUUID, src[start_index + i].pipelineCacheUUID,
                    sizeof(src[start_index + i].pipelineCacheUUID));
        ptr[i].limits = src[start_index + i].limits;
        ptr[i].sparseProperties = src[start_index + i].sparseProperties;
    }
    return ptr;
}

template <>
VkQueueFamilyProperties* CommandRecorder::CopyArray<VkQueueFamilyProperties>(const VkQueueFamilyProperties* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyProperties*>(m_allocator.Alloc(sizeof(VkQueueFamilyProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].queueFlags = src[start_index + i].queueFlags;
        ptr[i].queueCount = src[start_index + i].queueCount;
        ptr[i].timestampValidBits = src[start_index + i].timestampValidBits;
        ptr[i].minImageTransferGranularity = src[start_index + i].minImageTransferGranularity;
    }
    return ptr;
}

template <>
VkDeviceQueueCreateInfo* CommandRecorder::CopyArray<VkDeviceQueueCreateInfo>(const VkDeviceQueueCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceQueueCreateInfo*>(m_allocator.Alloc(sizeof(VkDeviceQueueCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
        ptr[i].queueCount = src[start_index + i].queueCount;
        ptr[i].pQueuePriorities = nullptr;
        if (src[start_index + i].pQueuePriorities) {
            ptr[i].pQueuePriorities = CopyArray<>(src[start_index + i].pQueuePriorities, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDeviceCreateInfo* CommandRecorder::CopyArray<VkDeviceCreateInfo>(const VkDeviceCreateInfo* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceCreateInfo*>(m_allocator.Alloc(sizeof(VkDeviceCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].queueCreateInfoCount = src[start_index + i].queueCreateInfoCount;
        ptr[i].pQueueCreateInfos = nullptr;
        if (src[start_index + i].pQueueCreateInfos) {
            ptr[i].pQueueCreateInfos = CopyArray<>(src[start_index + i].pQueueCreateInfos, 0, 1);
        }
        ptr[i].enabledLayerCount = src[start_index + i].enabledLayerCount;
        ptr[i].ppEnabledLayerNames = nullptr;
        if (src[start_index + i].ppEnabledLayerNames) {
            ptr[i].ppEnabledLayerNames = CopyArray<>(src[start_index + i].ppEnabledLayerNames, 0, 1);
        }
        ptr[i].enabledExtensionCount = src[start_index + i].enabledExtensionCount;
        ptr[i].ppEnabledExtensionNames = nullptr;
        if (src[start_index + i].ppEnabledExtensionNames) {
            ptr[i].ppEnabledExtensionNames = CopyArray<>(src[start_index + i].ppEnabledExtensionNames, 0, 1);
        }
        ptr[i].pEnabledFeatures = src[start_index + i].pEnabledFeatures;
    }
    return ptr;
}

template <>
VkExtensionProperties* CommandRecorder::CopyArray<VkExtensionProperties>(const VkExtensionProperties* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExtensionProperties*>(m_allocator.Alloc(sizeof(VkExtensionProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        std::memcpy(ptr[i].extensionName, src[start_index + i].extensionName,
                    sizeof(src[start_index + i].extensionName));
        ptr[i].specVersion = src[start_index + i].specVersion;
    }
    return ptr;
}

template <>
VkLayerProperties* CommandRecorder::CopyArray<VkLayerProperties>(const VkLayerProperties* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkLayerProperties*>(m_allocator.Alloc(sizeof(VkLayerProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        std::memcpy(ptr[i].layerName, src[start_index + i].layerName, sizeof(src[start_index + i].layerName));
        ptr[i].specVersion = src[start_index + i].specVersion;
        ptr[i].implementationVersion = src[start_index + i].implementationVersion;
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
    }
    return ptr;
}

template <>
VkSubmitInfo* CommandRecorder::CopyArray<VkSubmitInfo>(const VkSubmitInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubmitInfo*>(m_allocator.Alloc(sizeof(VkSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
        ptr[i].pWaitSemaphores = nullptr;
        if (src[start_index + i].pWaitSemaphores) {
            ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
        }
        ptr[i].pWaitDstStageMask = nullptr;
        if (src[start_index + i].pWaitDstStageMask) {
            ptr[i].pWaitDstStageMask = CopyArray<>(src[start_index + i].pWaitDstStageMask, 0, 1);
        }
        ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
        ptr[i].pCommandBuffers = nullptr;
        if (src[start_index + i].pCommandBuffers) {
            ptr[i].pCommandBuffers = CopyArray<>(src[start_index + i].pCommandBuffers, 0, 1);
        }
        ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
        ptr[i].pSignalSemaphores = nullptr;
        if (src[start_index + i].pSignalSemaphores) {
            ptr[i].pSignalSemaphores = CopyArray<>(src[start_index + i].pSignalSemaphores, 0, 1);
        }
    }
    return ptr;
}

template <>
VkMappedMemoryRange* CommandRecorder::CopyArray<VkMappedMemoryRange>(const VkMappedMemoryRange* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMappedMemoryRange*>(m_allocator.Alloc(sizeof(VkMappedMemoryRange) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkMemoryAllocateInfo* CommandRecorder::CopyArray<VkMemoryAllocateInfo>(const VkMemoryAllocateInfo* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryAllocateInfo*>(m_allocator.Alloc(sizeof(VkMemoryAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].allocationSize = src[start_index + i].allocationSize;
        ptr[i].memoryTypeIndex = src[start_index + i].memoryTypeIndex;
    }
    return ptr;
}

template <>
VkMemoryRequirements* CommandRecorder::CopyArray<VkMemoryRequirements>(const VkMemoryRequirements* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryRequirements*>(m_allocator.Alloc(sizeof(VkMemoryRequirements) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].size = src[start_index + i].size;
        ptr[i].alignment = src[start_index + i].alignment;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}

template <>
VkSparseMemoryBind* CommandRecorder::CopyArray<VkSparseMemoryBind>(const VkSparseMemoryBind* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseMemoryBind*>(m_allocator.Alloc(sizeof(VkSparseMemoryBind) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].resourceOffset = src[start_index + i].resourceOffset;
        ptr[i].size = src[start_index + i].size;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkSparseBufferMemoryBindInfo* CommandRecorder::CopyArray<VkSparseBufferMemoryBindInfo>(
    const VkSparseBufferMemoryBindInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseBufferMemoryBindInfo*>(
        m_allocator.Alloc(sizeof(VkSparseBufferMemoryBindInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].bindCount = src[start_index + i].bindCount;
        ptr[i].pBinds = nullptr;
        if (src[start_index + i].pBinds) {
            ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSparseImageOpaqueMemoryBindInfo* CommandRecorder::CopyArray<VkSparseImageOpaqueMemoryBindInfo>(
    const VkSparseImageOpaqueMemoryBindInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageOpaqueMemoryBindInfo*>(
        m_allocator.Alloc(sizeof(VkSparseImageOpaqueMemoryBindInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].image = src[start_index + i].image;
        ptr[i].bindCount = src[start_index + i].bindCount;
        ptr[i].pBinds = nullptr;
        if (src[start_index + i].pBinds) {
            ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageSubresource* CommandRecorder::CopyArray<VkImageSubresource>(const VkImageSubresource* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSubresource*>(m_allocator.Alloc(sizeof(VkImageSubresource) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].aspectMask = src[start_index + i].aspectMask;
        ptr[i].mipLevel = src[start_index + i].mipLevel;
        ptr[i].arrayLayer = src[start_index + i].arrayLayer;
    }
    return ptr;
}

template <>
VkSparseImageMemoryBind* CommandRecorder::CopyArray<VkSparseImageMemoryBind>(const VkSparseImageMemoryBind* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageMemoryBind*>(m_allocator.Alloc(sizeof(VkSparseImageMemoryBind) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].subresource = src[start_index + i].subresource;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].extent = src[start_index + i].extent;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkSparseImageMemoryBindInfo* CommandRecorder::CopyArray<VkSparseImageMemoryBindInfo>(
    const VkSparseImageMemoryBindInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSparseImageMemoryBindInfo*>(m_allocator.Alloc(sizeof(VkSparseImageMemoryBindInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].image = src[start_index + i].image;
        ptr[i].bindCount = src[start_index + i].bindCount;
        ptr[i].pBinds = nullptr;
        if (src[start_index + i].pBinds) {
            ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBindSparseInfo* CommandRecorder::CopyArray<VkBindSparseInfo>(const VkBindSparseInfo* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkBindSparseInfo*>(m_allocator.Alloc(sizeof(VkBindSparseInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
        ptr[i].pWaitSemaphores = nullptr;
        if (src[start_index + i].pWaitSemaphores) {
            ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
        }
        ptr[i].bufferBindCount = src[start_index + i].bufferBindCount;
        ptr[i].pBufferBinds = nullptr;
        if (src[start_index + i].pBufferBinds) {
            ptr[i].pBufferBinds = CopyArray<>(src[start_index + i].pBufferBinds, 0, 1);
        }
        ptr[i].imageOpaqueBindCount = src[start_index + i].imageOpaqueBindCount;
        ptr[i].pImageOpaqueBinds = nullptr;
        if (src[start_index + i].pImageOpaqueBinds) {
            ptr[i].pImageOpaqueBinds = CopyArray<>(src[start_index + i].pImageOpaqueBinds, 0, 1);
        }
        ptr[i].imageBindCount = src[start_index + i].imageBindCount;
        ptr[i].pImageBinds = nullptr;
        if (src[start_index + i].pImageBinds) {
            ptr[i].pImageBinds = CopyArray<>(src[start_index + i].pImageBinds, 0, 1);
        }
        ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
        ptr[i].pSignalSemaphores = nullptr;
        if (src[start_index + i].pSignalSemaphores) {
            ptr[i].pSignalSemaphores = CopyArray<>(src[start_index + i].pSignalSemaphores, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSparseImageFormatProperties* CommandRecorder::CopyArray<VkSparseImageFormatProperties>(
    const VkSparseImageFormatProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageFormatProperties*>(
        m_allocator.Alloc(sizeof(VkSparseImageFormatProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].aspectMask = src[start_index + i].aspectMask;
        ptr[i].imageGranularity = src[start_index + i].imageGranularity;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkSparseImageMemoryRequirements* CommandRecorder::CopyArray<VkSparseImageMemoryRequirements>(
    const VkSparseImageMemoryRequirements* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageMemoryRequirements*>(
        m_allocator.Alloc(sizeof(VkSparseImageMemoryRequirements) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].formatProperties = src[start_index + i].formatProperties;
        ptr[i].imageMipTailFirstLod = src[start_index + i].imageMipTailFirstLod;
        ptr[i].imageMipTailSize = src[start_index + i].imageMipTailSize;
        ptr[i].imageMipTailOffset = src[start_index + i].imageMipTailOffset;
        ptr[i].imageMipTailStride = src[start_index + i].imageMipTailStride;
    }
    return ptr;
}

template <>
VkFenceCreateInfo* CommandRecorder::CopyArray<VkFenceCreateInfo>(const VkFenceCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkFenceCreateInfo*>(m_allocator.Alloc(sizeof(VkFenceCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkSemaphoreCreateInfo* CommandRecorder::CopyArray<VkSemaphoreCreateInfo>(const VkSemaphoreCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreCreateInfo*>(m_allocator.Alloc(sizeof(VkSemaphoreCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkEventCreateInfo* CommandRecorder::CopyArray<VkEventCreateInfo>(const VkEventCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkEventCreateInfo*>(m_allocator.Alloc(sizeof(VkEventCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkQueryPoolCreateInfo* CommandRecorder::CopyArray<VkQueryPoolCreateInfo>(const VkQueryPoolCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueryPoolCreateInfo*>(m_allocator.Alloc(sizeof(VkQueryPoolCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].queryType = src[start_index + i].queryType;
        ptr[i].queryCount = src[start_index + i].queryCount;
        ptr[i].pipelineStatistics = src[start_index + i].pipelineStatistics;
    }
    return ptr;
}

template <>
VkBufferCreateInfo* CommandRecorder::CopyArray<VkBufferCreateInfo>(const VkBufferCreateInfo* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCreateInfo*>(m_allocator.Alloc(sizeof(VkBufferCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].size = src[start_index + i].size;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].sharingMode = src[start_index + i].sharingMode;
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices) {
            ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBufferViewCreateInfo* CommandRecorder::CopyArray<VkBufferViewCreateInfo>(const VkBufferViewCreateInfo* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferViewCreateInfo*>(m_allocator.Alloc(sizeof(VkBufferViewCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].format = src[start_index + i].format;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].range = src[start_index + i].range;
    }
    return ptr;
}

template <>
VkImageCreateInfo* CommandRecorder::CopyArray<VkImageCreateInfo>(const VkImageCreateInfo* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCreateInfo*>(m_allocator.Alloc(sizeof(VkImageCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].imageType = src[start_index + i].imageType;
        ptr[i].format = src[start_index + i].format;
        ptr[i].extent = src[start_index + i].extent;
        ptr[i].mipLevels = src[start_index + i].mipLevels;
        ptr[i].arrayLayers = src[start_index + i].arrayLayers;
        ptr[i].samples = src[start_index + i].samples;
        ptr[i].tiling = src[start_index + i].tiling;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].sharingMode = src[start_index + i].sharingMode;
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices) {
            ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
        }
        ptr[i].initialLayout = src[start_index + i].initialLayout;
    }
    return ptr;
}

template <>
VkSubresourceLayout* CommandRecorder::CopyArray<VkSubresourceLayout>(const VkSubresourceLayout* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubresourceLayout*>(m_allocator.Alloc(sizeof(VkSubresourceLayout) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
        ptr[i].rowPitch = src[start_index + i].rowPitch;
        ptr[i].arrayPitch = src[start_index + i].arrayPitch;
        ptr[i].depthPitch = src[start_index + i].depthPitch;
    }
    return ptr;
}

template <>
VkComponentMapping* CommandRecorder::CopyArray<VkComponentMapping>(const VkComponentMapping* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkComponentMapping*>(m_allocator.Alloc(sizeof(VkComponentMapping) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].r = src[start_index + i].r;
        ptr[i].g = src[start_index + i].g;
        ptr[i].b = src[start_index + i].b;
        ptr[i].a = src[start_index + i].a;
    }
    return ptr;
}

template <>
VkImageViewCreateInfo* CommandRecorder::CopyArray<VkImageViewCreateInfo>(const VkImageViewCreateInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewCreateInfo*>(m_allocator.Alloc(sizeof(VkImageViewCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].image = src[start_index + i].image;
        ptr[i].viewType = src[start_index + i].viewType;
        ptr[i].format = src[start_index + i].format;
        ptr[i].components = src[start_index + i].components;
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;
    }
    return ptr;
}

template <>
VkShaderModuleCreateInfo* CommandRecorder::CopyArray<VkShaderModuleCreateInfo>(const VkShaderModuleCreateInfo* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkShaderModuleCreateInfo*>(m_allocator.Alloc(sizeof(VkShaderModuleCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].codeSize = src[start_index + i].codeSize;
        ptr[i].pCode = nullptr;
        if (src[start_index + i].pCode) {
            ptr[i].pCode = CopyArray<>(src[start_index + i].pCode, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineCacheCreateInfo* CommandRecorder::CopyArray<VkPipelineCacheCreateInfo>(const VkPipelineCacheCreateInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPipelineCacheCreateInfo*>(m_allocator.Alloc(sizeof(VkPipelineCacheCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].initialDataSize = src[start_index + i].initialDataSize;
        ptr[i].pInitialData = src[start_index + i].pInitialData;
    }
    return ptr;
}

template <>
VkSpecializationMapEntry* CommandRecorder::CopyArray<VkSpecializationMapEntry>(const VkSpecializationMapEntry* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSpecializationMapEntry*>(m_allocator.Alloc(sizeof(VkSpecializationMapEntry) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].constantID = src[start_index + i].constantID;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkSpecializationInfo* CommandRecorder::CopyArray<VkSpecializationInfo>(const VkSpecializationInfo* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSpecializationInfo*>(m_allocator.Alloc(sizeof(VkSpecializationInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].mapEntryCount = src[start_index + i].mapEntryCount;
        ptr[i].pMapEntries = nullptr;
        if (src[start_index + i].pMapEntries) {
            ptr[i].pMapEntries = CopyArray<>(src[start_index + i].pMapEntries, 0, 1);
        }
        ptr[i].dataSize = src[start_index + i].dataSize;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkPipelineShaderStageCreateInfo* CommandRecorder::CopyArray<VkPipelineShaderStageCreateInfo>(
    const VkPipelineShaderStageCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineShaderStageCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineShaderStageCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stage = src[start_index + i].stage;
        ptr[i].module = src[start_index + i].module;
        ptr[i].pName = nullptr;
        if (src[start_index + i].pName) {
            ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName) + 1);
        }
        ptr[i].pSpecializationInfo = src[start_index + i].pSpecializationInfo;
    }
    return ptr;
}

template <>
VkComputePipelineCreateInfo* CommandRecorder::CopyArray<VkComputePipelineCreateInfo>(
    const VkComputePipelineCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkComputePipelineCreateInfo*>(m_allocator.Alloc(sizeof(VkComputePipelineCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stage = src[start_index + i].stage;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
        ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
    }
    return ptr;
}

template <>
VkVertexInputBindingDescription* CommandRecorder::CopyArray<VkVertexInputBindingDescription>(
    const VkVertexInputBindingDescription* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVertexInputBindingDescription*>(
        m_allocator.Alloc(sizeof(VkVertexInputBindingDescription) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].stride = src[start_index + i].stride;
        ptr[i].inputRate = src[start_index + i].inputRate;
    }
    return ptr;
}

template <>
VkVertexInputAttributeDescription* CommandRecorder::CopyArray<VkVertexInputAttributeDescription>(
    const VkVertexInputAttributeDescription* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVertexInputAttributeDescription*>(
        m_allocator.Alloc(sizeof(VkVertexInputAttributeDescription) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].location = src[start_index + i].location;
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].format = src[start_index + i].format;
        ptr[i].offset = src[start_index + i].offset;
    }
    return ptr;
}

template <>
VkPipelineVertexInputStateCreateInfo* CommandRecorder::CopyArray<VkPipelineVertexInputStateCreateInfo>(
    const VkPipelineVertexInputStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineVertexInputStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineVertexInputStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].vertexBindingDescriptionCount = src[start_index + i].vertexBindingDescriptionCount;
        ptr[i].pVertexBindingDescriptions = nullptr;
        if (src[start_index + i].pVertexBindingDescriptions) {
            ptr[i].pVertexBindingDescriptions = CopyArray<>(src[start_index + i].pVertexBindingDescriptions, 0, 1);
        }
        ptr[i].vertexAttributeDescriptionCount = src[start_index + i].vertexAttributeDescriptionCount;
        ptr[i].pVertexAttributeDescriptions = nullptr;
        if (src[start_index + i].pVertexAttributeDescriptions) {
            ptr[i].pVertexAttributeDescriptions = CopyArray<>(src[start_index + i].pVertexAttributeDescriptions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineInputAssemblyStateCreateInfo* CommandRecorder::CopyArray<VkPipelineInputAssemblyStateCreateInfo>(
    const VkPipelineInputAssemblyStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineInputAssemblyStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineInputAssemblyStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].topology = src[start_index + i].topology;
        ptr[i].primitiveRestartEnable = src[start_index + i].primitiveRestartEnable;
    }
    return ptr;
}

template <>
VkPipelineTessellationStateCreateInfo* CommandRecorder::CopyArray<VkPipelineTessellationStateCreateInfo>(
    const VkPipelineTessellationStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineTessellationStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineTessellationStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].patchControlPoints = src[start_index + i].patchControlPoints;
    }
    return ptr;
}

template <>
VkViewport* CommandRecorder::CopyArray<VkViewport>(const VkViewport* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkViewport*>(m_allocator.Alloc(sizeof(VkViewport) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].minDepth = src[start_index + i].minDepth;
        ptr[i].maxDepth = src[start_index + i].maxDepth;
    }
    return ptr;
}

template <>
VkPipelineViewportStateCreateInfo* CommandRecorder::CopyArray<VkPipelineViewportStateCreateInfo>(
    const VkPipelineViewportStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].viewportCount = src[start_index + i].viewportCount;
        ptr[i].pViewports = nullptr;
        if (src[start_index + i].pViewports) {
            ptr[i].pViewports = CopyArray<>(src[start_index + i].pViewports, 0, 1);
        }
        ptr[i].scissorCount = src[start_index + i].scissorCount;
        ptr[i].pScissors = nullptr;
        if (src[start_index + i].pScissors) {
            ptr[i].pScissors = CopyArray<>(src[start_index + i].pScissors, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineRasterizationStateCreateInfo* CommandRecorder::CopyArray<VkPipelineRasterizationStateCreateInfo>(
    const VkPipelineRasterizationStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].depthClampEnable = src[start_index + i].depthClampEnable;
        ptr[i].rasterizerDiscardEnable = src[start_index + i].rasterizerDiscardEnable;
        ptr[i].polygonMode = src[start_index + i].polygonMode;
        ptr[i].cullMode = src[start_index + i].cullMode;
        ptr[i].frontFace = src[start_index + i].frontFace;
        ptr[i].depthBiasEnable = src[start_index + i].depthBiasEnable;
        ptr[i].depthBiasConstantFactor = src[start_index + i].depthBiasConstantFactor;
        ptr[i].depthBiasClamp = src[start_index + i].depthBiasClamp;
        ptr[i].depthBiasSlopeFactor = src[start_index + i].depthBiasSlopeFactor;
        ptr[i].lineWidth = src[start_index + i].lineWidth;
    }
    return ptr;
}

template <>
VkPipelineMultisampleStateCreateInfo* CommandRecorder::CopyArray<VkPipelineMultisampleStateCreateInfo>(
    const VkPipelineMultisampleStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineMultisampleStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineMultisampleStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].rasterizationSamples = src[start_index + i].rasterizationSamples;
        ptr[i].sampleShadingEnable = src[start_index + i].sampleShadingEnable;
        ptr[i].minSampleShading = src[start_index + i].minSampleShading;
        ptr[i].pSampleMask = nullptr;
        if (src[start_index + i].pSampleMask) {
            ptr[i].pSampleMask = CopyArray<>(src[start_index + i].pSampleMask, 0, 1);
        }
        ptr[i].alphaToCoverageEnable = src[start_index + i].alphaToCoverageEnable;
        ptr[i].alphaToOneEnable = src[start_index + i].alphaToOneEnable;
    }
    return ptr;
}

template <>
VkStencilOpState* CommandRecorder::CopyArray<VkStencilOpState>(const VkStencilOpState* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkStencilOpState*>(m_allocator.Alloc(sizeof(VkStencilOpState) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].failOp = src[start_index + i].failOp;
        ptr[i].passOp = src[start_index + i].passOp;
        ptr[i].depthFailOp = src[start_index + i].depthFailOp;
        ptr[i].compareOp = src[start_index + i].compareOp;
        ptr[i].compareMask = src[start_index + i].compareMask;
        ptr[i].writeMask = src[start_index + i].writeMask;
        ptr[i].reference = src[start_index + i].reference;
    }
    return ptr;
}

template <>
VkPipelineDepthStencilStateCreateInfo* CommandRecorder::CopyArray<VkPipelineDepthStencilStateCreateInfo>(
    const VkPipelineDepthStencilStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineDepthStencilStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineDepthStencilStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].depthTestEnable = src[start_index + i].depthTestEnable;
        ptr[i].depthWriteEnable = src[start_index + i].depthWriteEnable;
        ptr[i].depthCompareOp = src[start_index + i].depthCompareOp;
        ptr[i].depthBoundsTestEnable = src[start_index + i].depthBoundsTestEnable;
        ptr[i].stencilTestEnable = src[start_index + i].stencilTestEnable;
        ptr[i].front = src[start_index + i].front;
        ptr[i].back = src[start_index + i].back;
        ptr[i].minDepthBounds = src[start_index + i].minDepthBounds;
        ptr[i].maxDepthBounds = src[start_index + i].maxDepthBounds;
    }
    return ptr;
}

template <>
VkPipelineColorBlendAttachmentState* CommandRecorder::CopyArray<VkPipelineColorBlendAttachmentState>(
    const VkPipelineColorBlendAttachmentState* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineColorBlendAttachmentState*>(
        m_allocator.Alloc(sizeof(VkPipelineColorBlendAttachmentState) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].blendEnable = src[start_index + i].blendEnable;
        ptr[i].srcColorBlendFactor = src[start_index + i].srcColorBlendFactor;
        ptr[i].dstColorBlendFactor = src[start_index + i].dstColorBlendFactor;
        ptr[i].colorBlendOp = src[start_index + i].colorBlendOp;
        ptr[i].srcAlphaBlendFactor = src[start_index + i].srcAlphaBlendFactor;
        ptr[i].dstAlphaBlendFactor = src[start_index + i].dstAlphaBlendFactor;
        ptr[i].alphaBlendOp = src[start_index + i].alphaBlendOp;
        ptr[i].colorWriteMask = src[start_index + i].colorWriteMask;
    }
    return ptr;
}

template <>
VkPipelineColorBlendStateCreateInfo* CommandRecorder::CopyArray<VkPipelineColorBlendStateCreateInfo>(
    const VkPipelineColorBlendStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineColorBlendStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineColorBlendStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].logicOpEnable = src[start_index + i].logicOpEnable;
        ptr[i].logicOp = src[start_index + i].logicOp;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments) {
            ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
        }
        std::memcpy(ptr[i].blendConstants, src[start_index + i].blendConstants,
                    sizeof(src[start_index + i].blendConstants));
    }
    return ptr;
}

template <>
VkPipelineDynamicStateCreateInfo* CommandRecorder::CopyArray<VkPipelineDynamicStateCreateInfo>(
    const VkPipelineDynamicStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineDynamicStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineDynamicStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].dynamicStateCount = src[start_index + i].dynamicStateCount;
        ptr[i].pDynamicStates = nullptr;
        if (src[start_index + i].pDynamicStates) {
            ptr[i].pDynamicStates = CopyArray<>(src[start_index + i].pDynamicStates, 0, 1);
        }
    }
    return ptr;
}

template <>
VkGraphicsPipelineCreateInfo* CommandRecorder::CopyArray<VkGraphicsPipelineCreateInfo>(
    const VkGraphicsPipelineCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGraphicsPipelineCreateInfo*>(
        m_allocator.Alloc(sizeof(VkGraphicsPipelineCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stageCount = src[start_index + i].stageCount;
        ptr[i].pStages = nullptr;
        if (src[start_index + i].pStages) {
            ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
        }
        ptr[i].pVertexInputState = src[start_index + i].pVertexInputState;
        ptr[i].pInputAssemblyState = src[start_index + i].pInputAssemblyState;
        ptr[i].pTessellationState = src[start_index + i].pTessellationState;
        ptr[i].pViewportState = src[start_index + i].pViewportState;
        ptr[i].pRasterizationState = src[start_index + i].pRasterizationState;
        ptr[i].pMultisampleState = src[start_index + i].pMultisampleState;
        ptr[i].pDepthStencilState = src[start_index + i].pDepthStencilState;
        ptr[i].pColorBlendState = src[start_index + i].pColorBlendState;
        ptr[i].pDynamicState = src[start_index + i].pDynamicState;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].renderPass = src[start_index + i].renderPass;
        ptr[i].subpass = src[start_index + i].subpass;
        ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
        ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
    }
    return ptr;
}

template <>
VkPushConstantRange* CommandRecorder::CopyArray<VkPushConstantRange>(const VkPushConstantRange* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPushConstantRange*>(m_allocator.Alloc(sizeof(VkPushConstantRange) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkPipelineLayoutCreateInfo* CommandRecorder::CopyArray<VkPipelineLayoutCreateInfo>(
    const VkPipelineLayoutCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPipelineLayoutCreateInfo*>(m_allocator.Alloc(sizeof(VkPipelineLayoutCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].setLayoutCount = src[start_index + i].setLayoutCount;
        ptr[i].pSetLayouts = nullptr;
        if (src[start_index + i].pSetLayouts) {
            ptr[i].pSetLayouts = CopyArray<>(src[start_index + i].pSetLayouts, 0, 1);
        }
        ptr[i].pushConstantRangeCount = src[start_index + i].pushConstantRangeCount;
        ptr[i].pPushConstantRanges = nullptr;
        if (src[start_index + i].pPushConstantRanges) {
            ptr[i].pPushConstantRanges = CopyArray<>(src[start_index + i].pPushConstantRanges, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSamplerCreateInfo* CommandRecorder::CopyArray<VkSamplerCreateInfo>(const VkSamplerCreateInfo* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerCreateInfo*>(m_allocator.Alloc(sizeof(VkSamplerCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].magFilter = src[start_index + i].magFilter;
        ptr[i].minFilter = src[start_index + i].minFilter;
        ptr[i].mipmapMode = src[start_index + i].mipmapMode;
        ptr[i].addressModeU = src[start_index + i].addressModeU;
        ptr[i].addressModeV = src[start_index + i].addressModeV;
        ptr[i].addressModeW = src[start_index + i].addressModeW;
        ptr[i].mipLodBias = src[start_index + i].mipLodBias;
        ptr[i].anisotropyEnable = src[start_index + i].anisotropyEnable;
        ptr[i].maxAnisotropy = src[start_index + i].maxAnisotropy;
        ptr[i].compareEnable = src[start_index + i].compareEnable;
        ptr[i].compareOp = src[start_index + i].compareOp;
        ptr[i].minLod = src[start_index + i].minLod;
        ptr[i].maxLod = src[start_index + i].maxLod;
        ptr[i].borderColor = src[start_index + i].borderColor;
        ptr[i].unnormalizedCoordinates = src[start_index + i].unnormalizedCoordinates;
    }
    return ptr;
}

template <>
VkCopyDescriptorSet* CommandRecorder::CopyArray<VkCopyDescriptorSet>(const VkCopyDescriptorSet* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyDescriptorSet*>(m_allocator.Alloc(sizeof(VkCopyDescriptorSet) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcSet = src[start_index + i].srcSet;
        ptr[i].srcBinding = src[start_index + i].srcBinding;
        ptr[i].srcArrayElement = src[start_index + i].srcArrayElement;
        ptr[i].dstSet = src[start_index + i].dstSet;
        ptr[i].dstBinding = src[start_index + i].dstBinding;
        ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;
    }
    return ptr;
}

template <>
VkDescriptorBufferInfo* CommandRecorder::CopyArray<VkDescriptorBufferInfo>(const VkDescriptorBufferInfo* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorBufferInfo*>(m_allocator.Alloc(sizeof(VkDescriptorBufferInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].range = src[start_index + i].range;
    }
    return ptr;
}

template <>
VkDescriptorImageInfo* CommandRecorder::CopyArray<VkDescriptorImageInfo>(const VkDescriptorImageInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorImageInfo*>(m_allocator.Alloc(sizeof(VkDescriptorImageInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sampler = src[start_index + i].sampler;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].imageLayout = src[start_index + i].imageLayout;
    }
    return ptr;
}

template <>
VkDescriptorPoolSize* CommandRecorder::CopyArray<VkDescriptorPoolSize>(const VkDescriptorPoolSize* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorPoolSize*>(m_allocator.Alloc(sizeof(VkDescriptorPoolSize) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].type = src[start_index + i].type;
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;
    }
    return ptr;
}

template <>
VkDescriptorPoolCreateInfo* CommandRecorder::CopyArray<VkDescriptorPoolCreateInfo>(
    const VkDescriptorPoolCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDescriptorPoolCreateInfo*>(m_allocator.Alloc(sizeof(VkDescriptorPoolCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].maxSets = src[start_index + i].maxSets;
        ptr[i].poolSizeCount = src[start_index + i].poolSizeCount;
        ptr[i].pPoolSizes = nullptr;
        if (src[start_index + i].pPoolSizes) {
            ptr[i].pPoolSizes = CopyArray<>(src[start_index + i].pPoolSizes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDescriptorSetAllocateInfo* CommandRecorder::CopyArray<VkDescriptorSetAllocateInfo>(
    const VkDescriptorSetAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDescriptorSetAllocateInfo*>(m_allocator.Alloc(sizeof(VkDescriptorSetAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorPool = src[start_index + i].descriptorPool;
        ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;
        ptr[i].pSetLayouts = nullptr;
        if (src[start_index + i].pSetLayouts) {
            ptr[i].pSetLayouts = CopyArray<>(src[start_index + i].pSetLayouts, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDescriptorSetLayoutBinding* CommandRecorder::CopyArray<VkDescriptorSetLayoutBinding>(
    const VkDescriptorSetLayoutBinding* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutBinding*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetLayoutBinding) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].descriptorType = src[start_index + i].descriptorType;
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].pImmutableSamplers = nullptr;
        if (src[start_index + i].pImmutableSamplers) {
            ptr[i].pImmutableSamplers = CopyArray<>(src[start_index + i].pImmutableSamplers, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDescriptorSetLayoutCreateInfo* CommandRecorder::CopyArray<VkDescriptorSetLayoutCreateInfo>(
    const VkDescriptorSetLayoutCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetLayoutCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].bindingCount = src[start_index + i].bindingCount;
        ptr[i].pBindings = nullptr;
        if (src[start_index + i].pBindings) {
            ptr[i].pBindings = CopyArray<>(src[start_index + i].pBindings, 0, 1);
        }
    }
    return ptr;
}

template <>
VkWriteDescriptorSet* CommandRecorder::CopyArray<VkWriteDescriptorSet>(const VkWriteDescriptorSet* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWriteDescriptorSet*>(m_allocator.Alloc(sizeof(VkWriteDescriptorSet) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dstSet = src[start_index + i].dstSet;
        ptr[i].dstBinding = src[start_index + i].dstBinding;
        ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;
        ptr[i].descriptorType = src[start_index + i].descriptorType;
        ptr[i].pImageInfo = nullptr;
        if (src[start_index + i].pImageInfo) {
            ptr[i].pImageInfo = CopyArray<>(src[start_index + i].pImageInfo, 0, 1);
        }
        ptr[i].pBufferInfo = nullptr;
        if (src[start_index + i].pBufferInfo) {
            ptr[i].pBufferInfo = CopyArray<>(src[start_index + i].pBufferInfo, 0, 1);
        }
        ptr[i].pTexelBufferView = nullptr;
        if (src[start_index + i].pTexelBufferView) {
            ptr[i].pTexelBufferView = CopyArray<>(src[start_index + i].pTexelBufferView, 0, 1);
        }
    }
    return ptr;
}

template <>
VkAttachmentDescription* CommandRecorder::CopyArray<VkAttachmentDescription>(const VkAttachmentDescription* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentDescription*>(m_allocator.Alloc(sizeof(VkAttachmentDescription) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].format = src[start_index + i].format;
        ptr[i].samples = src[start_index + i].samples;
        ptr[i].loadOp = src[start_index + i].loadOp;
        ptr[i].storeOp = src[start_index + i].storeOp;
        ptr[i].stencilLoadOp = src[start_index + i].stencilLoadOp;
        ptr[i].stencilStoreOp = src[start_index + i].stencilStoreOp;
        ptr[i].initialLayout = src[start_index + i].initialLayout;
        ptr[i].finalLayout = src[start_index + i].finalLayout;
    }
    return ptr;
}

template <>
VkAttachmentReference* CommandRecorder::CopyArray<VkAttachmentReference>(const VkAttachmentReference* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentReference*>(m_allocator.Alloc(sizeof(VkAttachmentReference) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].attachment = src[start_index + i].attachment;
        ptr[i].layout = src[start_index + i].layout;
    }
    return ptr;
}

template <>
VkFramebufferCreateInfo* CommandRecorder::CopyArray<VkFramebufferCreateInfo>(const VkFramebufferCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFramebufferCreateInfo*>(m_allocator.Alloc(sizeof(VkFramebufferCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].renderPass = src[start_index + i].renderPass;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments) {
            ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
        }
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].layers = src[start_index + i].layers;
    }
    return ptr;
}

template <>
VkSubpassDescription* CommandRecorder::CopyArray<VkSubpassDescription>(const VkSubpassDescription* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassDescription*>(m_allocator.Alloc(sizeof(VkSubpassDescription) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].inputAttachmentCount = src[start_index + i].inputAttachmentCount;
        ptr[i].pInputAttachments = nullptr;
        if (src[start_index + i].pInputAttachments) {
            ptr[i].pInputAttachments = CopyArray<>(src[start_index + i].pInputAttachments, 0, 1);
        }
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachments = nullptr;
        if (src[start_index + i].pColorAttachments) {
            ptr[i].pColorAttachments = CopyArray<>(src[start_index + i].pColorAttachments, 0, 1);
        }
        ptr[i].pResolveAttachments = nullptr;
        if (src[start_index + i].pResolveAttachments) {
            ptr[i].pResolveAttachments = CopyArray<>(src[start_index + i].pResolveAttachments, 0, 1);
        }
        ptr[i].pDepthStencilAttachment = src[start_index + i].pDepthStencilAttachment;
        ptr[i].preserveAttachmentCount = src[start_index + i].preserveAttachmentCount;
        ptr[i].pPreserveAttachments = nullptr;
        if (src[start_index + i].pPreserveAttachments) {
            ptr[i].pPreserveAttachments = CopyArray<>(src[start_index + i].pPreserveAttachments, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSubpassDependency* CommandRecorder::CopyArray<VkSubpassDependency>(const VkSubpassDependency* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassDependency*>(m_allocator.Alloc(sizeof(VkSubpassDependency) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcSubpass = src[start_index + i].srcSubpass;
        ptr[i].dstSubpass = src[start_index + i].dstSubpass;
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
    }
    return ptr;
}

template <>
VkRenderPassCreateInfo* CommandRecorder::CopyArray<VkRenderPassCreateInfo>(const VkRenderPassCreateInfo* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassCreateInfo*>(m_allocator.Alloc(sizeof(VkRenderPassCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments) {
            ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
        }
        ptr[i].subpassCount = src[start_index + i].subpassCount;
        ptr[i].pSubpasses = nullptr;
        if (src[start_index + i].pSubpasses) {
            ptr[i].pSubpasses = CopyArray<>(src[start_index + i].pSubpasses, 0, 1);
        }
        ptr[i].dependencyCount = src[start_index + i].dependencyCount;
        ptr[i].pDependencies = nullptr;
        if (src[start_index + i].pDependencies) {
            ptr[i].pDependencies = CopyArray<>(src[start_index + i].pDependencies, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCommandPoolCreateInfo* CommandRecorder::CopyArray<VkCommandPoolCreateInfo>(const VkCommandPoolCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandPoolCreateInfo*>(m_allocator.Alloc(sizeof(VkCommandPoolCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
    }
    return ptr;
}

template <>
VkCommandBufferAllocateInfo* CommandRecorder::CopyArray<VkCommandBufferAllocateInfo>(
    const VkCommandBufferAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCommandBufferAllocateInfo*>(m_allocator.Alloc(sizeof(VkCommandBufferAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].commandPool = src[start_index + i].commandPool;
        ptr[i].level = src[start_index + i].level;
        ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
    }
    return ptr;
}

template <>
VkCommandBufferInheritanceInfo* CommandRecorder::CopyArray<VkCommandBufferInheritanceInfo>(
    const VkCommandBufferInheritanceInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceInfo*>(
        m_allocator.Alloc(sizeof(VkCommandBufferInheritanceInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].renderPass = src[start_index + i].renderPass;
        ptr[i].subpass = src[start_index + i].subpass;
        ptr[i].framebuffer = src[start_index + i].framebuffer;
        ptr[i].occlusionQueryEnable = src[start_index + i].occlusionQueryEnable;
        ptr[i].queryFlags = src[start_index + i].queryFlags;
        ptr[i].pipelineStatistics = src[start_index + i].pipelineStatistics;
    }
    return ptr;
}

template <>
VkCommandBufferBeginInfo* CommandRecorder::CopyArray<VkCommandBufferBeginInfo>(const VkCommandBufferBeginInfo* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferBeginInfo*>(m_allocator.Alloc(sizeof(VkCommandBufferBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pInheritanceInfo = src[start_index + i].pInheritanceInfo;
    }
    return ptr;
}

template <>
VkBufferCopy* CommandRecorder::CopyArray<VkBufferCopy>(const VkBufferCopy* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCopy*>(m_allocator.Alloc(sizeof(VkBufferCopy) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkImageSubresourceLayers* CommandRecorder::CopyArray<VkImageSubresourceLayers>(const VkImageSubresourceLayers* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSubresourceLayers*>(m_allocator.Alloc(sizeof(VkImageSubresourceLayers) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].aspectMask = src[start_index + i].aspectMask;
        ptr[i].mipLevel = src[start_index + i].mipLevel;
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
        ptr[i].layerCount = src[start_index + i].layerCount;
    }
    return ptr;
}

template <>
VkBufferImageCopy* CommandRecorder::CopyArray<VkBufferImageCopy>(const VkBufferImageCopy* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferImageCopy*>(m_allocator.Alloc(sizeof(VkBufferImageCopy) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].bufferOffset = src[start_index + i].bufferOffset;
        ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;
        ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
        ptr[i].imageOffset = src[start_index + i].imageOffset;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkClearColorValue* CommandRecorder::CopyArray<VkClearColorValue>(const VkClearColorValue* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkClearColorValue*>(m_allocator.Alloc(sizeof(VkClearColorValue) * count));
    for (uint64_t i = 0; i < count; ++i) {
        std::memcpy(ptr[i].float32, src[start_index + i].float32, sizeof(src[start_index + i].float32));
        std::memcpy(ptr[i].int32, src[start_index + i].int32, sizeof(src[start_index + i].int32));
        std::memcpy(ptr[i].uint32, src[start_index + i].uint32, sizeof(src[start_index + i].uint32));
    }
    return ptr;
}

template <>
VkClearDepthStencilValue* CommandRecorder::CopyArray<VkClearDepthStencilValue>(const VkClearDepthStencilValue* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkClearDepthStencilValue*>(m_allocator.Alloc(sizeof(VkClearDepthStencilValue) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].depth = src[start_index + i].depth;
        ptr[i].stencil = src[start_index + i].stencil;
    }
    return ptr;
}

template <>
VkClearValue* CommandRecorder::CopyArray<VkClearValue>(const VkClearValue* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkClearValue*>(m_allocator.Alloc(sizeof(VkClearValue) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].color = src[start_index + i].color;
        ptr[i].depthStencil = src[start_index + i].depthStencil;
    }
    return ptr;
}

template <>
VkClearAttachment* CommandRecorder::CopyArray<VkClearAttachment>(const VkClearAttachment* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkClearAttachment*>(m_allocator.Alloc(sizeof(VkClearAttachment) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].aspectMask = src[start_index + i].aspectMask;
        ptr[i].colorAttachment = src[start_index + i].colorAttachment;
        ptr[i].clearValue = src[start_index + i].clearValue;
    }
    return ptr;
}

template <>
VkClearRect* CommandRecorder::CopyArray<VkClearRect>(const VkClearRect* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkClearRect*>(m_allocator.Alloc(sizeof(VkClearRect) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].rect = src[start_index + i].rect;
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
        ptr[i].layerCount = src[start_index + i].layerCount;
    }
    return ptr;
}

template <>
VkImageBlit* CommandRecorder::CopyArray<VkImageBlit>(const VkImageBlit* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageBlit*>(m_allocator.Alloc(sizeof(VkImageBlit) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        std::memcpy(ptr[i].srcOffsets, src[start_index + i].srcOffsets, sizeof(src[start_index + i].srcOffsets));
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        std::memcpy(ptr[i].dstOffsets, src[start_index + i].dstOffsets, sizeof(src[start_index + i].dstOffsets));
    }
    return ptr;
}

template <>
VkImageCopy* CommandRecorder::CopyArray<VkImageCopy>(const VkImageCopy* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCopy*>(m_allocator.Alloc(sizeof(VkImageCopy) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].extent = src[start_index + i].extent;
    }
    return ptr;
}

template <>
VkImageResolve* CommandRecorder::CopyArray<VkImageResolve>(const VkImageResolve* src, uint64_t start_index,
                                                           uint64_t count) {
    auto ptr = reinterpret_cast<VkImageResolve*>(m_allocator.Alloc(sizeof(VkImageResolve) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].extent = src[start_index + i].extent;
    }
    return ptr;
}

template <>
VkRenderPassBeginInfo* CommandRecorder::CopyArray<VkRenderPassBeginInfo>(const VkRenderPassBeginInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassBeginInfo*>(m_allocator.Alloc(sizeof(VkRenderPassBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].renderPass = src[start_index + i].renderPass;
        ptr[i].framebuffer = src[start_index + i].framebuffer;
        ptr[i].renderArea = src[start_index + i].renderArea;
        ptr[i].clearValueCount = src[start_index + i].clearValueCount;
        ptr[i].pClearValues = nullptr;
        if (src[start_index + i].pClearValues) {
            ptr[i].pClearValues = CopyArray<>(src[start_index + i].pClearValues, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubgroupProperties* CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupProperties>(
    const VkPhysicalDeviceSubgroupProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subgroupSize = src[start_index + i].subgroupSize;
        ptr[i].supportedStages = src[start_index + i].supportedStages;
        ptr[i].supportedOperations = src[start_index + i].supportedOperations;
        ptr[i].quadOperationsInAllStages = src[start_index + i].quadOperationsInAllStages;
    }
    return ptr;
}

template <>
VkBindBufferMemoryInfo* CommandRecorder::CopyArray<VkBindBufferMemoryInfo>(const VkBindBufferMemoryInfo* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindBufferMemoryInfo*>(m_allocator.Alloc(sizeof(VkBindBufferMemoryInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
    }
    return ptr;
}

template <>
VkBindImageMemoryInfo* CommandRecorder::CopyArray<VkBindImageMemoryInfo>(const VkBindImageMemoryInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindImageMemoryInfo*>(m_allocator.Alloc(sizeof(VkBindImageMemoryInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
    }
    return ptr;
}

template <>
VkPhysicalDevice16BitStorageFeatures* CommandRecorder::CopyArray<VkPhysicalDevice16BitStorageFeatures>(
    const VkPhysicalDevice16BitStorageFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevice16BitStorageFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevice16BitStorageFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].storageBuffer16BitAccess = src[start_index + i].storageBuffer16BitAccess;
        ptr[i].uniformAndStorageBuffer16BitAccess = src[start_index + i].uniformAndStorageBuffer16BitAccess;
        ptr[i].storagePushConstant16 = src[start_index + i].storagePushConstant16;
        ptr[i].storageInputOutput16 = src[start_index + i].storageInputOutput16;
    }
    return ptr;
}

template <>
VkMemoryDedicatedRequirements* CommandRecorder::CopyArray<VkMemoryDedicatedRequirements>(
    const VkMemoryDedicatedRequirements* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryDedicatedRequirements*>(
        m_allocator.Alloc(sizeof(VkMemoryDedicatedRequirements) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].prefersDedicatedAllocation = src[start_index + i].prefersDedicatedAllocation;
        ptr[i].requiresDedicatedAllocation = src[start_index + i].requiresDedicatedAllocation;
    }
    return ptr;
}

template <>
VkMemoryDedicatedAllocateInfo* CommandRecorder::CopyArray<VkMemoryDedicatedAllocateInfo>(
    const VkMemoryDedicatedAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryDedicatedAllocateInfo*>(
        m_allocator.Alloc(sizeof(VkMemoryDedicatedAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkMemoryAllocateFlagsInfo* CommandRecorder::CopyArray<VkMemoryAllocateFlagsInfo>(const VkMemoryAllocateFlagsInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMemoryAllocateFlagsInfo*>(m_allocator.Alloc(sizeof(VkMemoryAllocateFlagsInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].deviceMask = src[start_index + i].deviceMask;
    }
    return ptr;
}

template <>
VkDeviceGroupRenderPassBeginInfo* CommandRecorder::CopyArray<VkDeviceGroupRenderPassBeginInfo>(
    const VkDeviceGroupRenderPassBeginInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupRenderPassBeginInfo*>(
        m_allocator.Alloc(sizeof(VkDeviceGroupRenderPassBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceMask = src[start_index + i].deviceMask;
        ptr[i].deviceRenderAreaCount = src[start_index + i].deviceRenderAreaCount;
        ptr[i].pDeviceRenderAreas = nullptr;
        if (src[start_index + i].pDeviceRenderAreas) {
            ptr[i].pDeviceRenderAreas = CopyArray<>(src[start_index + i].pDeviceRenderAreas, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDeviceGroupCommandBufferBeginInfo* CommandRecorder::CopyArray<VkDeviceGroupCommandBufferBeginInfo>(
    const VkDeviceGroupCommandBufferBeginInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo*>(
        m_allocator.Alloc(sizeof(VkDeviceGroupCommandBufferBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceMask = src[start_index + i].deviceMask;
    }
    return ptr;
}

template <>
VkDeviceGroupSubmitInfo* CommandRecorder::CopyArray<VkDeviceGroupSubmitInfo>(const VkDeviceGroupSubmitInfo* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupSubmitInfo*>(m_allocator.Alloc(sizeof(VkDeviceGroupSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
        ptr[i].pWaitSemaphoreDeviceIndices = nullptr;
        if (src[start_index + i].pWaitSemaphoreDeviceIndices) {
            ptr[i].pWaitSemaphoreDeviceIndices = CopyArray<>(src[start_index + i].pWaitSemaphoreDeviceIndices, 0, 1);
        }
        ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
        ptr[i].pCommandBufferDeviceMasks = nullptr;
        if (src[start_index + i].pCommandBufferDeviceMasks) {
            ptr[i].pCommandBufferDeviceMasks = CopyArray<>(src[start_index + i].pCommandBufferDeviceMasks, 0, 1);
        }
        ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
        ptr[i].pSignalSemaphoreDeviceIndices = nullptr;
        if (src[start_index + i].pSignalSemaphoreDeviceIndices) {
            ptr[i].pSignalSemaphoreDeviceIndices =
                CopyArray<>(src[start_index + i].pSignalSemaphoreDeviceIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDeviceGroupBindSparseInfo* CommandRecorder::CopyArray<VkDeviceGroupBindSparseInfo>(
    const VkDeviceGroupBindSparseInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDeviceGroupBindSparseInfo*>(m_allocator.Alloc(sizeof(VkDeviceGroupBindSparseInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].resourceDeviceIndex = src[start_index + i].resourceDeviceIndex;
        ptr[i].memoryDeviceIndex = src[start_index + i].memoryDeviceIndex;
    }
    return ptr;
}

template <>
VkBindBufferMemoryDeviceGroupInfo* CommandRecorder::CopyArray<VkBindBufferMemoryDeviceGroupInfo>(
    const VkBindBufferMemoryDeviceGroupInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo*>(
        m_allocator.Alloc(sizeof(VkBindBufferMemoryDeviceGroupInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceIndexCount = src[start_index + i].deviceIndexCount;
        ptr[i].pDeviceIndices = nullptr;
        if (src[start_index + i].pDeviceIndices) {
            ptr[i].pDeviceIndices = CopyArray<>(src[start_index + i].pDeviceIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBindImageMemoryDeviceGroupInfo* CommandRecorder::CopyArray<VkBindImageMemoryDeviceGroupInfo>(
    const VkBindImageMemoryDeviceGroupInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindImageMemoryDeviceGroupInfo*>(
        m_allocator.Alloc(sizeof(VkBindImageMemoryDeviceGroupInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceIndexCount = src[start_index + i].deviceIndexCount;
        ptr[i].pDeviceIndices = nullptr;
        if (src[start_index + i].pDeviceIndices) {
            ptr[i].pDeviceIndices = CopyArray<>(src[start_index + i].pDeviceIndices, 0, 1);
        }
        ptr[i].splitInstanceBindRegionCount = src[start_index + i].splitInstanceBindRegionCount;
        ptr[i].pSplitInstanceBindRegions = nullptr;
        if (src[start_index + i].pSplitInstanceBindRegions) {
            ptr[i].pSplitInstanceBindRegions = CopyArray<>(src[start_index + i].pSplitInstanceBindRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceGroupProperties* CommandRecorder::CopyArray<VkPhysicalDeviceGroupProperties>(
    const VkPhysicalDeviceGroupProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceGroupProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceGroupProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].physicalDeviceCount = src[start_index + i].physicalDeviceCount;
        std::memcpy(ptr[i].physicalDevices, src[start_index + i].physicalDevices,
                    sizeof(src[start_index + i].physicalDevices));
        ptr[i].subsetAllocation = src[start_index + i].subsetAllocation;
    }
    return ptr;
}

template <>
VkDeviceGroupDeviceCreateInfo* CommandRecorder::CopyArray<VkDeviceGroupDeviceCreateInfo>(
    const VkDeviceGroupDeviceCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupDeviceCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDeviceGroupDeviceCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].physicalDeviceCount = src[start_index + i].physicalDeviceCount;
        ptr[i].pPhysicalDevices = nullptr;
        if (src[start_index + i].pPhysicalDevices) {
            ptr[i].pPhysicalDevices = CopyArray<>(src[start_index + i].pPhysicalDevices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBufferMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkBufferMemoryRequirementsInfo2>(
    const VkBufferMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferMemoryRequirementsInfo2*>(
        m_allocator.Alloc(sizeof(VkBufferMemoryRequirementsInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkImageMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkImageMemoryRequirementsInfo2>(
    const VkImageMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageMemoryRequirementsInfo2*>(
        m_allocator.Alloc(sizeof(VkImageMemoryRequirementsInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
    }
    return ptr;
}

template <>
VkImageSparseMemoryRequirementsInfo2* CommandRecorder::CopyArray<VkImageSparseMemoryRequirementsInfo2>(
    const VkImageSparseMemoryRequirementsInfo2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSparseMemoryRequirementsInfo2*>(
        m_allocator.Alloc(sizeof(VkImageSparseMemoryRequirementsInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
    }
    return ptr;
}

template <>
VkMemoryRequirements2* CommandRecorder::CopyArray<VkMemoryRequirements2>(const VkMemoryRequirements2* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryRequirements2*>(m_allocator.Alloc(sizeof(VkMemoryRequirements2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryRequirements = src[start_index + i].memoryRequirements;
    }
    return ptr;
}

template <>
VkSparseImageMemoryRequirements2* CommandRecorder::CopyArray<VkSparseImageMemoryRequirements2>(
    const VkSparseImageMemoryRequirements2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageMemoryRequirements2*>(
        m_allocator.Alloc(sizeof(VkSparseImageMemoryRequirements2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryRequirements = src[start_index + i].memoryRequirements;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFeatures2* CommandRecorder::CopyArray<VkPhysicalDeviceFeatures2>(const VkPhysicalDeviceFeatures2* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPhysicalDeviceFeatures2*>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFeatures2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].features = src[start_index + i].features;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProperties2* CommandRecorder::CopyArray<VkPhysicalDeviceProperties2>(
    const VkPhysicalDeviceProperties2* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPhysicalDeviceProperties2*>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].properties = src[start_index + i].properties;
    }
    return ptr;
}

template <>
VkFormatProperties2* CommandRecorder::CopyArray<VkFormatProperties2>(const VkFormatProperties2* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFormatProperties2*>(m_allocator.Alloc(sizeof(VkFormatProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].formatProperties = src[start_index + i].formatProperties;
    }
    return ptr;
}

template <>
VkImageFormatProperties2* CommandRecorder::CopyArray<VkImageFormatProperties2>(const VkImageFormatProperties2* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageFormatProperties2*>(m_allocator.Alloc(sizeof(VkImageFormatProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageFormatProperties = src[start_index + i].imageFormatProperties;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageFormatInfo2* CommandRecorder::CopyArray<VkPhysicalDeviceImageFormatInfo2>(
    const VkPhysicalDeviceImageFormatInfo2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageFormatInfo2*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageFormatInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].type = src[start_index + i].type;
        ptr[i].tiling = src[start_index + i].tiling;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkQueueFamilyProperties2* CommandRecorder::CopyArray<VkQueueFamilyProperties2>(const VkQueueFamilyProperties2* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyProperties2*>(m_allocator.Alloc(sizeof(VkQueueFamilyProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queueFamilyProperties = src[start_index + i].queueFamilyProperties;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryProperties2* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties2>(
    const VkPhysicalDeviceMemoryProperties2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryProperties = src[start_index + i].memoryProperties;
    }
    return ptr;
}

template <>
VkSparseImageFormatProperties2* CommandRecorder::CopyArray<VkSparseImageFormatProperties2>(
    const VkSparseImageFormatProperties2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSparseImageFormatProperties2*>(
        m_allocator.Alloc(sizeof(VkSparseImageFormatProperties2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].properties = src[start_index + i].properties;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSparseImageFormatInfo2* CommandRecorder::CopyArray<VkPhysicalDeviceSparseImageFormatInfo2>(
    const VkPhysicalDeviceSparseImageFormatInfo2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSparseImageFormatInfo2*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSparseImageFormatInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].type = src[start_index + i].type;
        ptr[i].samples = src[start_index + i].samples;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].tiling = src[start_index + i].tiling;
    }
    return ptr;
}

template <>
VkPhysicalDevicePointClippingProperties* CommandRecorder::CopyArray<VkPhysicalDevicePointClippingProperties>(
    const VkPhysicalDevicePointClippingProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePointClippingProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePointClippingProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pointClippingBehavior = src[start_index + i].pointClippingBehavior;
    }
    return ptr;
}

template <>
VkInputAttachmentAspectReference* CommandRecorder::CopyArray<VkInputAttachmentAspectReference>(
    const VkInputAttachmentAspectReference* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkInputAttachmentAspectReference*>(
        m_allocator.Alloc(sizeof(VkInputAttachmentAspectReference) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].subpass = src[start_index + i].subpass;
        ptr[i].inputAttachmentIndex = src[start_index + i].inputAttachmentIndex;
        ptr[i].aspectMask = src[start_index + i].aspectMask;
    }
    return ptr;
}

template <>
VkRenderPassInputAttachmentAspectCreateInfo* CommandRecorder::CopyArray<VkRenderPassInputAttachmentAspectCreateInfo>(
    const VkRenderPassInputAttachmentAspectCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo*>(
        m_allocator.Alloc(sizeof(VkRenderPassInputAttachmentAspectCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].aspectReferenceCount = src[start_index + i].aspectReferenceCount;
        ptr[i].pAspectReferences = nullptr;
        if (src[start_index + i].pAspectReferences) {
            ptr[i].pAspectReferences = CopyArray<>(src[start_index + i].pAspectReferences, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageViewUsageCreateInfo* CommandRecorder::CopyArray<VkImageViewUsageCreateInfo>(
    const VkImageViewUsageCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImageViewUsageCreateInfo*>(m_allocator.Alloc(sizeof(VkImageViewUsageCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].usage = src[start_index + i].usage;
    }
    return ptr;
}

template <>
VkPipelineTessellationDomainOriginStateCreateInfo*
CommandRecorder::CopyArray<VkPipelineTessellationDomainOriginStateCreateInfo>(
    const VkPipelineTessellationDomainOriginStateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineTessellationDomainOriginStateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].domainOrigin = src[start_index + i].domainOrigin;
    }
    return ptr;
}

template <>
VkRenderPassMultiviewCreateInfo* CommandRecorder::CopyArray<VkRenderPassMultiviewCreateInfo>(
    const VkRenderPassMultiviewCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassMultiviewCreateInfo*>(
        m_allocator.Alloc(sizeof(VkRenderPassMultiviewCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subpassCount = src[start_index + i].subpassCount;
        ptr[i].pViewMasks = nullptr;
        if (src[start_index + i].pViewMasks) {
            ptr[i].pViewMasks = CopyArray<>(src[start_index + i].pViewMasks, 0, 1);
        }
        ptr[i].dependencyCount = src[start_index + i].dependencyCount;
        ptr[i].pViewOffsets = nullptr;
        if (src[start_index + i].pViewOffsets) {
            ptr[i].pViewOffsets = CopyArray<>(src[start_index + i].pViewOffsets, 0, 1);
        }
        ptr[i].correlationMaskCount = src[start_index + i].correlationMaskCount;
        ptr[i].pCorrelationMasks = nullptr;
        if (src[start_index + i].pCorrelationMasks) {
            ptr[i].pCorrelationMasks = CopyArray<>(src[start_index + i].pCorrelationMasks, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiviewFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewFeatures>(
    const VkPhysicalDeviceMultiviewFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multiview = src[start_index + i].multiview;
        ptr[i].multiviewGeometryShader = src[start_index + i].multiviewGeometryShader;
        ptr[i].multiviewTessellationShader = src[start_index + i].multiviewTessellationShader;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiviewProperties* CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewProperties>(
    const VkPhysicalDeviceMultiviewProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxMultiviewViewCount = src[start_index + i].maxMultiviewViewCount;
        ptr[i].maxMultiviewInstanceIndex = src[start_index + i].maxMultiviewInstanceIndex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVariablePointersFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceVariablePointersFeatures>(
    const VkPhysicalDeviceVariablePointersFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVariablePointersFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].variablePointersStorageBuffer = src[start_index + i].variablePointersStorageBuffer;
        ptr[i].variablePointers = src[start_index + i].variablePointers;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProtectedMemoryFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryFeatures>(
    const VkPhysicalDeviceProtectedMemoryFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceProtectedMemoryFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].protectedMemory = src[start_index + i].protectedMemory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProtectedMemoryProperties* CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryProperties>(
    const VkPhysicalDeviceProtectedMemoryProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceProtectedMemoryProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].protectedNoFault = src[start_index + i].protectedNoFault;
    }
    return ptr;
}

template <>
VkDeviceQueueInfo2* CommandRecorder::CopyArray<VkDeviceQueueInfo2>(const VkDeviceQueueInfo2* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceQueueInfo2*>(m_allocator.Alloc(sizeof(VkDeviceQueueInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
        ptr[i].queueIndex = src[start_index + i].queueIndex;
    }
    return ptr;
}

template <>
VkProtectedSubmitInfo* CommandRecorder::CopyArray<VkProtectedSubmitInfo>(const VkProtectedSubmitInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkProtectedSubmitInfo*>(m_allocator.Alloc(sizeof(VkProtectedSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].protectedSubmit = src[start_index + i].protectedSubmit;
    }
    return ptr;
}

template <>
VkSamplerYcbcrConversionCreateInfo* CommandRecorder::CopyArray<VkSamplerYcbcrConversionCreateInfo>(
    const VkSamplerYcbcrConversionCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerYcbcrConversionCreateInfo*>(
        m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].ycbcrModel = src[start_index + i].ycbcrModel;
        ptr[i].ycbcrRange = src[start_index + i].ycbcrRange;
        ptr[i].components = src[start_index + i].components;
        ptr[i].xChromaOffset = src[start_index + i].xChromaOffset;
        ptr[i].yChromaOffset = src[start_index + i].yChromaOffset;
        ptr[i].chromaFilter = src[start_index + i].chromaFilter;
        ptr[i].forceExplicitReconstruction = src[start_index + i].forceExplicitReconstruction;
    }
    return ptr;
}

template <>
VkSamplerYcbcrConversionInfo* CommandRecorder::CopyArray<VkSamplerYcbcrConversionInfo>(
    const VkSamplerYcbcrConversionInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerYcbcrConversionInfo*>(
        m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].conversion = src[start_index + i].conversion;
    }
    return ptr;
}

template <>
VkBindImagePlaneMemoryInfo* CommandRecorder::CopyArray<VkBindImagePlaneMemoryInfo>(
    const VkBindImagePlaneMemoryInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkBindImagePlaneMemoryInfo*>(m_allocator.Alloc(sizeof(VkBindImagePlaneMemoryInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].planeAspect = src[start_index + i].planeAspect;
    }
    return ptr;
}

template <>
VkImagePlaneMemoryRequirementsInfo* CommandRecorder::CopyArray<VkImagePlaneMemoryRequirementsInfo>(
    const VkImagePlaneMemoryRequirementsInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImagePlaneMemoryRequirementsInfo*>(
        m_allocator.Alloc(sizeof(VkImagePlaneMemoryRequirementsInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].planeAspect = src[start_index + i].planeAspect;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSamplerYcbcrConversionFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(
    const VkPhysicalDeviceSamplerYcbcrConversionFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].samplerYcbcrConversion = src[start_index + i].samplerYcbcrConversion;
    }
    return ptr;
}

template <>
VkSamplerYcbcrConversionImageFormatProperties*
CommandRecorder::CopyArray<VkSamplerYcbcrConversionImageFormatProperties>(
    const VkSamplerYcbcrConversionImageFormatProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties*>(
        m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionImageFormatProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].combinedImageSamplerDescriptorCount = src[start_index + i].combinedImageSamplerDescriptorCount;
    }
    return ptr;
}

template <>
VkDescriptorUpdateTemplateEntry* CommandRecorder::CopyArray<VkDescriptorUpdateTemplateEntry>(
    const VkDescriptorUpdateTemplateEntry* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorUpdateTemplateEntry*>(
        m_allocator.Alloc(sizeof(VkDescriptorUpdateTemplateEntry) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].dstBinding = src[start_index + i].dstBinding;
        ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
        ptr[i].descriptorCount = src[start_index + i].descriptorCount;
        ptr[i].descriptorType = src[start_index + i].descriptorType;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].stride = src[start_index + i].stride;
    }
    return ptr;
}

template <>
VkDescriptorUpdateTemplateCreateInfo* CommandRecorder::CopyArray<VkDescriptorUpdateTemplateCreateInfo>(
    const VkDescriptorUpdateTemplateCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorUpdateTemplateCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDescriptorUpdateTemplateCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].descriptorUpdateEntryCount = src[start_index + i].descriptorUpdateEntryCount;
        ptr[i].pDescriptorUpdateEntries = nullptr;
        if (src[start_index + i].pDescriptorUpdateEntries) {
            ptr[i].pDescriptorUpdateEntries = CopyArray<>(src[start_index + i].pDescriptorUpdateEntries, 0, 1);
        }
        ptr[i].templateType = src[start_index + i].templateType;
        ptr[i].descriptorSetLayout = src[start_index + i].descriptorSetLayout;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].pipelineLayout = src[start_index + i].pipelineLayout;
        ptr[i].set = src[start_index + i].set;
    }
    return ptr;
}

template <>
VkExternalMemoryProperties* CommandRecorder::CopyArray<VkExternalMemoryProperties>(
    const VkExternalMemoryProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExternalMemoryProperties*>(m_allocator.Alloc(sizeof(VkExternalMemoryProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].externalMemoryFeatures = src[start_index + i].externalMemoryFeatures;
        ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
        ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalImageFormatInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalImageFormatInfo>(
    const VkPhysicalDeviceExternalImageFormatInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalImageFormatInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkExternalImageFormatProperties* CommandRecorder::CopyArray<VkExternalImageFormatProperties>(
    const VkExternalImageFormatProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalImageFormatProperties*>(
        m_allocator.Alloc(sizeof(VkExternalImageFormatProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalMemoryProperties = src[start_index + i].externalMemoryProperties;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalBufferInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalBufferInfo>(
    const VkPhysicalDeviceExternalBufferInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalBufferInfo*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalBufferInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkExternalBufferProperties* CommandRecorder::CopyArray<VkExternalBufferProperties>(
    const VkExternalBufferProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExternalBufferProperties*>(m_allocator.Alloc(sizeof(VkExternalBufferProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalMemoryProperties = src[start_index + i].externalMemoryProperties;
    }
    return ptr;
}

template <>
VkPhysicalDeviceIDProperties* CommandRecorder::CopyArray<VkPhysicalDeviceIDProperties>(
    const VkPhysicalDeviceIDProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceIDProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceIDProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].deviceUUID, src[start_index + i].deviceUUID, sizeof(src[start_index + i].deviceUUID));
        std::memcpy(ptr[i].driverUUID, src[start_index + i].driverUUID, sizeof(src[start_index + i].driverUUID));
        std::memcpy(ptr[i].deviceLUID, src[start_index + i].deviceLUID, sizeof(src[start_index + i].deviceLUID));
        ptr[i].deviceNodeMask = src[start_index + i].deviceNodeMask;
        ptr[i].deviceLUIDValid = src[start_index + i].deviceLUIDValid;
    }
    return ptr;
}

template <>
VkExternalMemoryImageCreateInfo* CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfo>(
    const VkExternalMemoryImageCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalMemoryImageCreateInfo*>(
        m_allocator.Alloc(sizeof(VkExternalMemoryImageCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkExternalMemoryBufferCreateInfo* CommandRecorder::CopyArray<VkExternalMemoryBufferCreateInfo>(
    const VkExternalMemoryBufferCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalMemoryBufferCreateInfo*>(
        m_allocator.Alloc(sizeof(VkExternalMemoryBufferCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkExportMemoryAllocateInfo* CommandRecorder::CopyArray<VkExportMemoryAllocateInfo>(
    const VkExportMemoryAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportMemoryAllocateInfo*>(m_allocator.Alloc(sizeof(VkExportMemoryAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalFenceInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalFenceInfo>(
    const VkPhysicalDeviceExternalFenceInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalFenceInfo*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalFenceInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkExternalFenceProperties* CommandRecorder::CopyArray<VkExternalFenceProperties>(const VkExternalFenceProperties* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExternalFenceProperties*>(m_allocator.Alloc(sizeof(VkExternalFenceProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
        ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
        ptr[i].externalFenceFeatures = src[start_index + i].externalFenceFeatures;
    }
    return ptr;
}

template <>
VkExportFenceCreateInfo* CommandRecorder::CopyArray<VkExportFenceCreateInfo>(const VkExportFenceCreateInfo* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportFenceCreateInfo*>(m_allocator.Alloc(sizeof(VkExportFenceCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkExportSemaphoreCreateInfo* CommandRecorder::CopyArray<VkExportSemaphoreCreateInfo>(
    const VkExportSemaphoreCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportSemaphoreCreateInfo*>(m_allocator.Alloc(sizeof(VkExportSemaphoreCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalSemaphoreInfo* CommandRecorder::CopyArray<VkPhysicalDeviceExternalSemaphoreInfo>(
    const VkPhysicalDeviceExternalSemaphoreInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalSemaphoreInfo*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalSemaphoreInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkExternalSemaphoreProperties* CommandRecorder::CopyArray<VkExternalSemaphoreProperties>(
    const VkExternalSemaphoreProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalSemaphoreProperties*>(
        m_allocator.Alloc(sizeof(VkExternalSemaphoreProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
        ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
        ptr[i].externalSemaphoreFeatures = src[start_index + i].externalSemaphoreFeatures;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance3Properties* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance3Properties>(
    const VkPhysicalDeviceMaintenance3Properties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance3Properties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance3Properties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxPerSetDescriptors = src[start_index + i].maxPerSetDescriptors;
        ptr[i].maxMemoryAllocationSize = src[start_index + i].maxMemoryAllocationSize;
    }
    return ptr;
}

template <>
VkDescriptorSetLayoutSupport* CommandRecorder::CopyArray<VkDescriptorSetLayoutSupport>(
    const VkDescriptorSetLayoutSupport* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutSupport*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetLayoutSupport) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supported = src[start_index + i].supported;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderDrawParametersFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceShaderDrawParametersFeatures>(
    const VkPhysicalDeviceShaderDrawParametersFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderDrawParametersFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderDrawParameters = src[start_index + i].shaderDrawParameters;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan11Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Features>(
    const VkPhysicalDeviceVulkan11Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan11Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan11Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].storageBuffer16BitAccess = src[start_index + i].storageBuffer16BitAccess;
        ptr[i].uniformAndStorageBuffer16BitAccess = src[start_index + i].uniformAndStorageBuffer16BitAccess;
        ptr[i].storagePushConstant16 = src[start_index + i].storagePushConstant16;
        ptr[i].storageInputOutput16 = src[start_index + i].storageInputOutput16;
        ptr[i].multiview = src[start_index + i].multiview;
        ptr[i].multiviewGeometryShader = src[start_index + i].multiviewGeometryShader;
        ptr[i].multiviewTessellationShader = src[start_index + i].multiviewTessellationShader;
        ptr[i].variablePointersStorageBuffer = src[start_index + i].variablePointersStorageBuffer;
        ptr[i].variablePointers = src[start_index + i].variablePointers;
        ptr[i].protectedMemory = src[start_index + i].protectedMemory;
        ptr[i].samplerYcbcrConversion = src[start_index + i].samplerYcbcrConversion;
        ptr[i].shaderDrawParameters = src[start_index + i].shaderDrawParameters;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan11Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Properties>(
    const VkPhysicalDeviceVulkan11Properties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan11Properties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan11Properties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].deviceUUID, src[start_index + i].deviceUUID, sizeof(src[start_index + i].deviceUUID));
        std::memcpy(ptr[i].driverUUID, src[start_index + i].driverUUID, sizeof(src[start_index + i].driverUUID));
        std::memcpy(ptr[i].deviceLUID, src[start_index + i].deviceLUID, sizeof(src[start_index + i].deviceLUID));
        ptr[i].deviceNodeMask = src[start_index + i].deviceNodeMask;
        ptr[i].deviceLUIDValid = src[start_index + i].deviceLUIDValid;
        ptr[i].subgroupSize = src[start_index + i].subgroupSize;
        ptr[i].subgroupSupportedStages = src[start_index + i].subgroupSupportedStages;
        ptr[i].subgroupSupportedOperations = src[start_index + i].subgroupSupportedOperations;
        ptr[i].subgroupQuadOperationsInAllStages = src[start_index + i].subgroupQuadOperationsInAllStages;
        ptr[i].pointClippingBehavior = src[start_index + i].pointClippingBehavior;
        ptr[i].maxMultiviewViewCount = src[start_index + i].maxMultiviewViewCount;
        ptr[i].maxMultiviewInstanceIndex = src[start_index + i].maxMultiviewInstanceIndex;
        ptr[i].protectedNoFault = src[start_index + i].protectedNoFault;
        ptr[i].maxPerSetDescriptors = src[start_index + i].maxPerSetDescriptors;
        ptr[i].maxMemoryAllocationSize = src[start_index + i].maxMemoryAllocationSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan12Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Features>(
    const VkPhysicalDeviceVulkan12Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan12Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan12Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].samplerMirrorClampToEdge = src[start_index + i].samplerMirrorClampToEdge;
        ptr[i].drawIndirectCount = src[start_index + i].drawIndirectCount;
        ptr[i].storageBuffer8BitAccess = src[start_index + i].storageBuffer8BitAccess;
        ptr[i].uniformAndStorageBuffer8BitAccess = src[start_index + i].uniformAndStorageBuffer8BitAccess;
        ptr[i].storagePushConstant8 = src[start_index + i].storagePushConstant8;
        ptr[i].shaderBufferInt64Atomics = src[start_index + i].shaderBufferInt64Atomics;
        ptr[i].shaderSharedInt64Atomics = src[start_index + i].shaderSharedInt64Atomics;
        ptr[i].shaderFloat16 = src[start_index + i].shaderFloat16;
        ptr[i].shaderInt8 = src[start_index + i].shaderInt8;
        ptr[i].descriptorIndexing = src[start_index + i].descriptorIndexing;
        ptr[i].shaderInputAttachmentArrayDynamicIndexing =
            src[start_index + i].shaderInputAttachmentArrayDynamicIndexing;
        ptr[i].shaderUniformTexelBufferArrayDynamicIndexing =
            src[start_index + i].shaderUniformTexelBufferArrayDynamicIndexing;
        ptr[i].shaderStorageTexelBufferArrayDynamicIndexing =
            src[start_index + i].shaderStorageTexelBufferArrayDynamicIndexing;
        ptr[i].shaderUniformBufferArrayNonUniformIndexing =
            src[start_index + i].shaderUniformBufferArrayNonUniformIndexing;
        ptr[i].shaderSampledImageArrayNonUniformIndexing =
            src[start_index + i].shaderSampledImageArrayNonUniformIndexing;
        ptr[i].shaderStorageBufferArrayNonUniformIndexing =
            src[start_index + i].shaderStorageBufferArrayNonUniformIndexing;
        ptr[i].shaderStorageImageArrayNonUniformIndexing =
            src[start_index + i].shaderStorageImageArrayNonUniformIndexing;
        ptr[i].shaderInputAttachmentArrayNonUniformIndexing =
            src[start_index + i].shaderInputAttachmentArrayNonUniformIndexing;
        ptr[i].shaderUniformTexelBufferArrayNonUniformIndexing =
            src[start_index + i].shaderUniformTexelBufferArrayNonUniformIndexing;
        ptr[i].shaderStorageTexelBufferArrayNonUniformIndexing =
            src[start_index + i].shaderStorageTexelBufferArrayNonUniformIndexing;
        ptr[i].descriptorBindingUniformBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingUniformBufferUpdateAfterBind;
        ptr[i].descriptorBindingSampledImageUpdateAfterBind =
            src[start_index + i].descriptorBindingSampledImageUpdateAfterBind;
        ptr[i].descriptorBindingStorageImageUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageImageUpdateAfterBind;
        ptr[i].descriptorBindingStorageBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageBufferUpdateAfterBind;
        ptr[i].descriptorBindingUniformTexelBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingUniformTexelBufferUpdateAfterBind;
        ptr[i].descriptorBindingStorageTexelBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageTexelBufferUpdateAfterBind;
        ptr[i].descriptorBindingUpdateUnusedWhilePending =
            src[start_index + i].descriptorBindingUpdateUnusedWhilePending;
        ptr[i].descriptorBindingPartiallyBound = src[start_index + i].descriptorBindingPartiallyBound;
        ptr[i].descriptorBindingVariableDescriptorCount = src[start_index + i].descriptorBindingVariableDescriptorCount;
        ptr[i].runtimeDescriptorArray = src[start_index + i].runtimeDescriptorArray;
        ptr[i].samplerFilterMinmax = src[start_index + i].samplerFilterMinmax;
        ptr[i].scalarBlockLayout = src[start_index + i].scalarBlockLayout;
        ptr[i].imagelessFramebuffer = src[start_index + i].imagelessFramebuffer;
        ptr[i].uniformBufferStandardLayout = src[start_index + i].uniformBufferStandardLayout;
        ptr[i].shaderSubgroupExtendedTypes = src[start_index + i].shaderSubgroupExtendedTypes;
        ptr[i].separateDepthStencilLayouts = src[start_index + i].separateDepthStencilLayouts;
        ptr[i].hostQueryReset = src[start_index + i].hostQueryReset;
        ptr[i].timelineSemaphore = src[start_index + i].timelineSemaphore;
        ptr[i].bufferDeviceAddress = src[start_index + i].bufferDeviceAddress;
        ptr[i].bufferDeviceAddressCaptureReplay = src[start_index + i].bufferDeviceAddressCaptureReplay;
        ptr[i].bufferDeviceAddressMultiDevice = src[start_index + i].bufferDeviceAddressMultiDevice;
        ptr[i].vulkanMemoryModel = src[start_index + i].vulkanMemoryModel;
        ptr[i].vulkanMemoryModelDeviceScope = src[start_index + i].vulkanMemoryModelDeviceScope;
        ptr[i].vulkanMemoryModelAvailabilityVisibilityChains =
            src[start_index + i].vulkanMemoryModelAvailabilityVisibilityChains;
        ptr[i].shaderOutputViewportIndex = src[start_index + i].shaderOutputViewportIndex;
        ptr[i].shaderOutputLayer = src[start_index + i].shaderOutputLayer;
        ptr[i].subgroupBroadcastDynamicId = src[start_index + i].subgroupBroadcastDynamicId;
    }
    return ptr;
}

template <>
VkConformanceVersion* CommandRecorder::CopyArray<VkConformanceVersion>(const VkConformanceVersion* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkConformanceVersion*>(m_allocator.Alloc(sizeof(VkConformanceVersion) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].major = src[start_index + i].major;
        ptr[i].minor = src[start_index + i].minor;
        ptr[i].subminor = src[start_index + i].subminor;
        ptr[i].patch = src[start_index + i].patch;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan12Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Properties>(
    const VkPhysicalDeviceVulkan12Properties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan12Properties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan12Properties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].driverID = src[start_index + i].driverID;
        std::memcpy(ptr[i].driverName, src[start_index + i].driverName, sizeof(src[start_index + i].driverName));
        std::memcpy(ptr[i].driverInfo, src[start_index + i].driverInfo, sizeof(src[start_index + i].driverInfo));
        ptr[i].conformanceVersion = src[start_index + i].conformanceVersion;
        ptr[i].denormBehaviorIndependence = src[start_index + i].denormBehaviorIndependence;
        ptr[i].roundingModeIndependence = src[start_index + i].roundingModeIndependence;
        ptr[i].shaderSignedZeroInfNanPreserveFloat16 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat16;
        ptr[i].shaderSignedZeroInfNanPreserveFloat32 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat32;
        ptr[i].shaderSignedZeroInfNanPreserveFloat64 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat64;
        ptr[i].shaderDenormPreserveFloat16 = src[start_index + i].shaderDenormPreserveFloat16;
        ptr[i].shaderDenormPreserveFloat32 = src[start_index + i].shaderDenormPreserveFloat32;
        ptr[i].shaderDenormPreserveFloat64 = src[start_index + i].shaderDenormPreserveFloat64;
        ptr[i].shaderDenormFlushToZeroFloat16 = src[start_index + i].shaderDenormFlushToZeroFloat16;
        ptr[i].shaderDenormFlushToZeroFloat32 = src[start_index + i].shaderDenormFlushToZeroFloat32;
        ptr[i].shaderDenormFlushToZeroFloat64 = src[start_index + i].shaderDenormFlushToZeroFloat64;
        ptr[i].shaderRoundingModeRTEFloat16 = src[start_index + i].shaderRoundingModeRTEFloat16;
        ptr[i].shaderRoundingModeRTEFloat32 = src[start_index + i].shaderRoundingModeRTEFloat32;
        ptr[i].shaderRoundingModeRTEFloat64 = src[start_index + i].shaderRoundingModeRTEFloat64;
        ptr[i].shaderRoundingModeRTZFloat16 = src[start_index + i].shaderRoundingModeRTZFloat16;
        ptr[i].shaderRoundingModeRTZFloat32 = src[start_index + i].shaderRoundingModeRTZFloat32;
        ptr[i].shaderRoundingModeRTZFloat64 = src[start_index + i].shaderRoundingModeRTZFloat64;
        ptr[i].maxUpdateAfterBindDescriptorsInAllPools = src[start_index + i].maxUpdateAfterBindDescriptorsInAllPools;
        ptr[i].shaderUniformBufferArrayNonUniformIndexingNative =
            src[start_index + i].shaderUniformBufferArrayNonUniformIndexingNative;
        ptr[i].shaderSampledImageArrayNonUniformIndexingNative =
            src[start_index + i].shaderSampledImageArrayNonUniformIndexingNative;
        ptr[i].shaderStorageBufferArrayNonUniformIndexingNative =
            src[start_index + i].shaderStorageBufferArrayNonUniformIndexingNative;
        ptr[i].shaderStorageImageArrayNonUniformIndexingNative =
            src[start_index + i].shaderStorageImageArrayNonUniformIndexingNative;
        ptr[i].shaderInputAttachmentArrayNonUniformIndexingNative =
            src[start_index + i].shaderInputAttachmentArrayNonUniformIndexingNative;
        ptr[i].robustBufferAccessUpdateAfterBind = src[start_index + i].robustBufferAccessUpdateAfterBind;
        ptr[i].quadDivergentImplicitLod = src[start_index + i].quadDivergentImplicitLod;
        ptr[i].maxPerStageDescriptorUpdateAfterBindSamplers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindSamplers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindUniformBuffers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindUniformBuffers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindStorageBuffers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageBuffers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindSampledImages =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindSampledImages;
        ptr[i].maxPerStageDescriptorUpdateAfterBindStorageImages =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageImages;
        ptr[i].maxPerStageDescriptorUpdateAfterBindInputAttachments =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindInputAttachments;
        ptr[i].maxPerStageUpdateAfterBindResources = src[start_index + i].maxPerStageUpdateAfterBindResources;
        ptr[i].maxDescriptorSetUpdateAfterBindSamplers = src[start_index + i].maxDescriptorSetUpdateAfterBindSamplers;
        ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffers =
            src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffers;
        ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic =
            src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffers =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffers;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
        ptr[i].maxDescriptorSetUpdateAfterBindSampledImages =
            src[start_index + i].maxDescriptorSetUpdateAfterBindSampledImages;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageImages =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageImages;
        ptr[i].maxDescriptorSetUpdateAfterBindInputAttachments =
            src[start_index + i].maxDescriptorSetUpdateAfterBindInputAttachments;
        ptr[i].supportedDepthResolveModes = src[start_index + i].supportedDepthResolveModes;
        ptr[i].supportedStencilResolveModes = src[start_index + i].supportedStencilResolveModes;
        ptr[i].independentResolveNone = src[start_index + i].independentResolveNone;
        ptr[i].independentResolve = src[start_index + i].independentResolve;
        ptr[i].filterMinmaxSingleComponentFormats = src[start_index + i].filterMinmaxSingleComponentFormats;
        ptr[i].filterMinmaxImageComponentMapping = src[start_index + i].filterMinmaxImageComponentMapping;
        ptr[i].maxTimelineSemaphoreValueDifference = src[start_index + i].maxTimelineSemaphoreValueDifference;
        ptr[i].framebufferIntegerColorSampleCounts = src[start_index + i].framebufferIntegerColorSampleCounts;
    }
    return ptr;
}

template <>
VkImageFormatListCreateInfo* CommandRecorder::CopyArray<VkImageFormatListCreateInfo>(
    const VkImageFormatListCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImageFormatListCreateInfo*>(m_allocator.Alloc(sizeof(VkImageFormatListCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].viewFormatCount = src[start_index + i].viewFormatCount;
        ptr[i].pViewFormats = nullptr;
        if (src[start_index + i].pViewFormats) {
            ptr[i].pViewFormats = CopyArray<>(src[start_index + i].pViewFormats, 0, 1);
        }
    }
    return ptr;
}

template <>
VkAttachmentDescription2* CommandRecorder::CopyArray<VkAttachmentDescription2>(const VkAttachmentDescription2* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentDescription2*>(m_allocator.Alloc(sizeof(VkAttachmentDescription2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].format = src[start_index + i].format;
        ptr[i].samples = src[start_index + i].samples;
        ptr[i].loadOp = src[start_index + i].loadOp;
        ptr[i].storeOp = src[start_index + i].storeOp;
        ptr[i].stencilLoadOp = src[start_index + i].stencilLoadOp;
        ptr[i].stencilStoreOp = src[start_index + i].stencilStoreOp;
        ptr[i].initialLayout = src[start_index + i].initialLayout;
        ptr[i].finalLayout = src[start_index + i].finalLayout;
    }
    return ptr;
}

template <>
VkAttachmentReference2* CommandRecorder::CopyArray<VkAttachmentReference2>(const VkAttachmentReference2* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentReference2*>(m_allocator.Alloc(sizeof(VkAttachmentReference2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachment = src[start_index + i].attachment;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].aspectMask = src[start_index + i].aspectMask;
    }
    return ptr;
}

template <>
VkSubpassDescription2* CommandRecorder::CopyArray<VkSubpassDescription2>(const VkSubpassDescription2* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassDescription2*>(m_allocator.Alloc(sizeof(VkSubpassDescription2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].viewMask = src[start_index + i].viewMask;
        ptr[i].inputAttachmentCount = src[start_index + i].inputAttachmentCount;
        ptr[i].pInputAttachments = nullptr;
        if (src[start_index + i].pInputAttachments) {
            ptr[i].pInputAttachments = CopyArray<>(src[start_index + i].pInputAttachments, 0, 1);
        }
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachments = nullptr;
        if (src[start_index + i].pColorAttachments) {
            ptr[i].pColorAttachments = CopyArray<>(src[start_index + i].pColorAttachments, 0, 1);
        }
        ptr[i].pResolveAttachments = nullptr;
        if (src[start_index + i].pResolveAttachments) {
            ptr[i].pResolveAttachments = CopyArray<>(src[start_index + i].pResolveAttachments, 0, 1);
        }
        ptr[i].pDepthStencilAttachment = src[start_index + i].pDepthStencilAttachment;
        ptr[i].preserveAttachmentCount = src[start_index + i].preserveAttachmentCount;
        ptr[i].pPreserveAttachments = nullptr;
        if (src[start_index + i].pPreserveAttachments) {
            ptr[i].pPreserveAttachments = CopyArray<>(src[start_index + i].pPreserveAttachments, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSubpassDependency2* CommandRecorder::CopyArray<VkSubpassDependency2>(const VkSubpassDependency2* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassDependency2*>(m_allocator.Alloc(sizeof(VkSubpassDependency2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcSubpass = src[start_index + i].srcSubpass;
        ptr[i].dstSubpass = src[start_index + i].dstSubpass;
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
        ptr[i].viewOffset = src[start_index + i].viewOffset;
    }
    return ptr;
}

template <>
VkRenderPassCreateInfo2* CommandRecorder::CopyArray<VkRenderPassCreateInfo2>(const VkRenderPassCreateInfo2* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassCreateInfo2*>(m_allocator.Alloc(sizeof(VkRenderPassCreateInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments) {
            ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
        }
        ptr[i].subpassCount = src[start_index + i].subpassCount;
        ptr[i].pSubpasses = nullptr;
        if (src[start_index + i].pSubpasses) {
            ptr[i].pSubpasses = CopyArray<>(src[start_index + i].pSubpasses, 0, 1);
        }
        ptr[i].dependencyCount = src[start_index + i].dependencyCount;
        ptr[i].pDependencies = nullptr;
        if (src[start_index + i].pDependencies) {
            ptr[i].pDependencies = CopyArray<>(src[start_index + i].pDependencies, 0, 1);
        }
        ptr[i].correlatedViewMaskCount = src[start_index + i].correlatedViewMaskCount;
        ptr[i].pCorrelatedViewMasks = nullptr;
        if (src[start_index + i].pCorrelatedViewMasks) {
            ptr[i].pCorrelatedViewMasks = CopyArray<>(src[start_index + i].pCorrelatedViewMasks, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSubpassBeginInfo* CommandRecorder::CopyArray<VkSubpassBeginInfo>(const VkSubpassBeginInfo* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassBeginInfo*>(m_allocator.Alloc(sizeof(VkSubpassBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].contents = src[start_index + i].contents;
    }
    return ptr;
}

template <>
VkSubpassEndInfo* CommandRecorder::CopyArray<VkSubpassEndInfo>(const VkSubpassEndInfo* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassEndInfo*>(m_allocator.Alloc(sizeof(VkSubpassEndInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
    }
    return ptr;
}

template <>
VkPhysicalDevice8BitStorageFeatures* CommandRecorder::CopyArray<VkPhysicalDevice8BitStorageFeatures>(
    const VkPhysicalDevice8BitStorageFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevice8BitStorageFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevice8BitStorageFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].storageBuffer8BitAccess = src[start_index + i].storageBuffer8BitAccess;
        ptr[i].uniformAndStorageBuffer8BitAccess = src[start_index + i].uniformAndStorageBuffer8BitAccess;
        ptr[i].storagePushConstant8 = src[start_index + i].storagePushConstant8;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDriverProperties* CommandRecorder::CopyArray<VkPhysicalDeviceDriverProperties>(
    const VkPhysicalDeviceDriverProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDriverProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDriverProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].driverID = src[start_index + i].driverID;
        std::memcpy(ptr[i].driverName, src[start_index + i].driverName, sizeof(src[start_index + i].driverName));
        std::memcpy(ptr[i].driverInfo, src[start_index + i].driverInfo, sizeof(src[start_index + i].driverInfo));
        ptr[i].conformanceVersion = src[start_index + i].conformanceVersion;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderAtomicInt64Features* CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicInt64Features>(
    const VkPhysicalDeviceShaderAtomicInt64Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderAtomicInt64Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderBufferInt64Atomics = src[start_index + i].shaderBufferInt64Atomics;
        ptr[i].shaderSharedInt64Atomics = src[start_index + i].shaderSharedInt64Atomics;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderFloat16Int8Features* CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloat16Int8Features>(
    const VkPhysicalDeviceShaderFloat16Int8Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderFloat16Int8Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderFloat16 = src[start_index + i].shaderFloat16;
        ptr[i].shaderInt8 = src[start_index + i].shaderInt8;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFloatControlsProperties* CommandRecorder::CopyArray<VkPhysicalDeviceFloatControlsProperties>(
    const VkPhysicalDeviceFloatControlsProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFloatControlsProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFloatControlsProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].denormBehaviorIndependence = src[start_index + i].denormBehaviorIndependence;
        ptr[i].roundingModeIndependence = src[start_index + i].roundingModeIndependence;
        ptr[i].shaderSignedZeroInfNanPreserveFloat16 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat16;
        ptr[i].shaderSignedZeroInfNanPreserveFloat32 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat32;
        ptr[i].shaderSignedZeroInfNanPreserveFloat64 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat64;
        ptr[i].shaderDenormPreserveFloat16 = src[start_index + i].shaderDenormPreserveFloat16;
        ptr[i].shaderDenormPreserveFloat32 = src[start_index + i].shaderDenormPreserveFloat32;
        ptr[i].shaderDenormPreserveFloat64 = src[start_index + i].shaderDenormPreserveFloat64;
        ptr[i].shaderDenormFlushToZeroFloat16 = src[start_index + i].shaderDenormFlushToZeroFloat16;
        ptr[i].shaderDenormFlushToZeroFloat32 = src[start_index + i].shaderDenormFlushToZeroFloat32;
        ptr[i].shaderDenormFlushToZeroFloat64 = src[start_index + i].shaderDenormFlushToZeroFloat64;
        ptr[i].shaderRoundingModeRTEFloat16 = src[start_index + i].shaderRoundingModeRTEFloat16;
        ptr[i].shaderRoundingModeRTEFloat32 = src[start_index + i].shaderRoundingModeRTEFloat32;
        ptr[i].shaderRoundingModeRTEFloat64 = src[start_index + i].shaderRoundingModeRTEFloat64;
        ptr[i].shaderRoundingModeRTZFloat16 = src[start_index + i].shaderRoundingModeRTZFloat16;
        ptr[i].shaderRoundingModeRTZFloat32 = src[start_index + i].shaderRoundingModeRTZFloat32;
        ptr[i].shaderRoundingModeRTZFloat64 = src[start_index + i].shaderRoundingModeRTZFloat64;
    }
    return ptr;
}

template <>
VkDescriptorSetLayoutBindingFlagsCreateInfo* CommandRecorder::CopyArray<VkDescriptorSetLayoutBindingFlagsCreateInfo>(
    const VkDescriptorSetLayoutBindingFlagsCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].bindingCount = src[start_index + i].bindingCount;
        ptr[i].pBindingFlags = nullptr;
        if (src[start_index + i].pBindingFlags) {
            ptr[i].pBindingFlags = CopyArray<>(src[start_index + i].pBindingFlags, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorIndexingFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingFeatures>(
    const VkPhysicalDeviceDescriptorIndexingFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorIndexingFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderInputAttachmentArrayDynamicIndexing =
            src[start_index + i].shaderInputAttachmentArrayDynamicIndexing;
        ptr[i].shaderUniformTexelBufferArrayDynamicIndexing =
            src[start_index + i].shaderUniformTexelBufferArrayDynamicIndexing;
        ptr[i].shaderStorageTexelBufferArrayDynamicIndexing =
            src[start_index + i].shaderStorageTexelBufferArrayDynamicIndexing;
        ptr[i].shaderUniformBufferArrayNonUniformIndexing =
            src[start_index + i].shaderUniformBufferArrayNonUniformIndexing;
        ptr[i].shaderSampledImageArrayNonUniformIndexing =
            src[start_index + i].shaderSampledImageArrayNonUniformIndexing;
        ptr[i].shaderStorageBufferArrayNonUniformIndexing =
            src[start_index + i].shaderStorageBufferArrayNonUniformIndexing;
        ptr[i].shaderStorageImageArrayNonUniformIndexing =
            src[start_index + i].shaderStorageImageArrayNonUniformIndexing;
        ptr[i].shaderInputAttachmentArrayNonUniformIndexing =
            src[start_index + i].shaderInputAttachmentArrayNonUniformIndexing;
        ptr[i].shaderUniformTexelBufferArrayNonUniformIndexing =
            src[start_index + i].shaderUniformTexelBufferArrayNonUniformIndexing;
        ptr[i].shaderStorageTexelBufferArrayNonUniformIndexing =
            src[start_index + i].shaderStorageTexelBufferArrayNonUniformIndexing;
        ptr[i].descriptorBindingUniformBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingUniformBufferUpdateAfterBind;
        ptr[i].descriptorBindingSampledImageUpdateAfterBind =
            src[start_index + i].descriptorBindingSampledImageUpdateAfterBind;
        ptr[i].descriptorBindingStorageImageUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageImageUpdateAfterBind;
        ptr[i].descriptorBindingStorageBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageBufferUpdateAfterBind;
        ptr[i].descriptorBindingUniformTexelBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingUniformTexelBufferUpdateAfterBind;
        ptr[i].descriptorBindingStorageTexelBufferUpdateAfterBind =
            src[start_index + i].descriptorBindingStorageTexelBufferUpdateAfterBind;
        ptr[i].descriptorBindingUpdateUnusedWhilePending =
            src[start_index + i].descriptorBindingUpdateUnusedWhilePending;
        ptr[i].descriptorBindingPartiallyBound = src[start_index + i].descriptorBindingPartiallyBound;
        ptr[i].descriptorBindingVariableDescriptorCount = src[start_index + i].descriptorBindingVariableDescriptorCount;
        ptr[i].runtimeDescriptorArray = src[start_index + i].runtimeDescriptorArray;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorIndexingProperties* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingProperties>(
    const VkPhysicalDeviceDescriptorIndexingProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorIndexingProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxUpdateAfterBindDescriptorsInAllPools = src[start_index + i].maxUpdateAfterBindDescriptorsInAllPools;
        ptr[i].shaderUniformBufferArrayNonUniformIndexingNative =
            src[start_index + i].shaderUniformBufferArrayNonUniformIndexingNative;
        ptr[i].shaderSampledImageArrayNonUniformIndexingNative =
            src[start_index + i].shaderSampledImageArrayNonUniformIndexingNative;
        ptr[i].shaderStorageBufferArrayNonUniformIndexingNative =
            src[start_index + i].shaderStorageBufferArrayNonUniformIndexingNative;
        ptr[i].shaderStorageImageArrayNonUniformIndexingNative =
            src[start_index + i].shaderStorageImageArrayNonUniformIndexingNative;
        ptr[i].shaderInputAttachmentArrayNonUniformIndexingNative =
            src[start_index + i].shaderInputAttachmentArrayNonUniformIndexingNative;
        ptr[i].robustBufferAccessUpdateAfterBind = src[start_index + i].robustBufferAccessUpdateAfterBind;
        ptr[i].quadDivergentImplicitLod = src[start_index + i].quadDivergentImplicitLod;
        ptr[i].maxPerStageDescriptorUpdateAfterBindSamplers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindSamplers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindUniformBuffers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindUniformBuffers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindStorageBuffers =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageBuffers;
        ptr[i].maxPerStageDescriptorUpdateAfterBindSampledImages =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindSampledImages;
        ptr[i].maxPerStageDescriptorUpdateAfterBindStorageImages =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageImages;
        ptr[i].maxPerStageDescriptorUpdateAfterBindInputAttachments =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindInputAttachments;
        ptr[i].maxPerStageUpdateAfterBindResources = src[start_index + i].maxPerStageUpdateAfterBindResources;
        ptr[i].maxDescriptorSetUpdateAfterBindSamplers = src[start_index + i].maxDescriptorSetUpdateAfterBindSamplers;
        ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffers =
            src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffers;
        ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic =
            src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffers =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffers;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
        ptr[i].maxDescriptorSetUpdateAfterBindSampledImages =
            src[start_index + i].maxDescriptorSetUpdateAfterBindSampledImages;
        ptr[i].maxDescriptorSetUpdateAfterBindStorageImages =
            src[start_index + i].maxDescriptorSetUpdateAfterBindStorageImages;
        ptr[i].maxDescriptorSetUpdateAfterBindInputAttachments =
            src[start_index + i].maxDescriptorSetUpdateAfterBindInputAttachments;
    }
    return ptr;
}

template <>
VkDescriptorSetVariableDescriptorCountAllocateInfo*
CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountAllocateInfo>(
    const VkDescriptorSetVariableDescriptorCountAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;
        ptr[i].pDescriptorCounts = nullptr;
        if (src[start_index + i].pDescriptorCounts) {
            ptr[i].pDescriptorCounts = CopyArray<>(src[start_index + i].pDescriptorCounts, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDescriptorSetVariableDescriptorCountLayoutSupport*
CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountLayoutSupport>(
    const VkDescriptorSetVariableDescriptorCountLayoutSupport* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxVariableDescriptorCount = src[start_index + i].maxVariableDescriptorCount;
    }
    return ptr;
}

template <>
VkSubpassDescriptionDepthStencilResolve* CommandRecorder::CopyArray<VkSubpassDescriptionDepthStencilResolve>(
    const VkSubpassDescriptionDepthStencilResolve* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassDescriptionDepthStencilResolve*>(
        m_allocator.Alloc(sizeof(VkSubpassDescriptionDepthStencilResolve) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthResolveMode = src[start_index + i].depthResolveMode;
        ptr[i].stencilResolveMode = src[start_index + i].stencilResolveMode;
        ptr[i].pDepthStencilResolveAttachment = src[start_index + i].pDepthStencilResolveAttachment;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDepthStencilResolveProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceDepthStencilResolveProperties>(
    const VkPhysicalDeviceDepthStencilResolveProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthStencilResolveProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportedDepthResolveModes = src[start_index + i].supportedDepthResolveModes;
        ptr[i].supportedStencilResolveModes = src[start_index + i].supportedStencilResolveModes;
        ptr[i].independentResolveNone = src[start_index + i].independentResolveNone;
        ptr[i].independentResolve = src[start_index + i].independentResolve;
    }
    return ptr;
}

template <>
VkPhysicalDeviceScalarBlockLayoutFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceScalarBlockLayoutFeatures>(
    const VkPhysicalDeviceScalarBlockLayoutFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].scalarBlockLayout = src[start_index + i].scalarBlockLayout;
    }
    return ptr;
}

template <>
VkImageStencilUsageCreateInfo* CommandRecorder::CopyArray<VkImageStencilUsageCreateInfo>(
    const VkImageStencilUsageCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageStencilUsageCreateInfo*>(
        m_allocator.Alloc(sizeof(VkImageStencilUsageCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stencilUsage = src[start_index + i].stencilUsage;
    }
    return ptr;
}

template <>
VkSamplerReductionModeCreateInfo* CommandRecorder::CopyArray<VkSamplerReductionModeCreateInfo>(
    const VkSamplerReductionModeCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerReductionModeCreateInfo*>(
        m_allocator.Alloc(sizeof(VkSamplerReductionModeCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].reductionMode = src[start_index + i].reductionMode;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSamplerFilterMinmaxProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceSamplerFilterMinmaxProperties>(
    const VkPhysicalDeviceSamplerFilterMinmaxProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].filterMinmaxSingleComponentFormats = src[start_index + i].filterMinmaxSingleComponentFormats;
        ptr[i].filterMinmaxImageComponentMapping = src[start_index + i].filterMinmaxImageComponentMapping;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkanMemoryModelFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceVulkanMemoryModelFeatures>(
    const VkPhysicalDeviceVulkanMemoryModelFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vulkanMemoryModel = src[start_index + i].vulkanMemoryModel;
        ptr[i].vulkanMemoryModelDeviceScope = src[start_index + i].vulkanMemoryModelDeviceScope;
        ptr[i].vulkanMemoryModelAvailabilityVisibilityChains =
            src[start_index + i].vulkanMemoryModelAvailabilityVisibilityChains;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImagelessFramebufferFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceImagelessFramebufferFeatures>(
    const VkPhysicalDeviceImagelessFramebufferFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImagelessFramebufferFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imagelessFramebuffer = src[start_index + i].imagelessFramebuffer;
    }
    return ptr;
}

template <>
VkFramebufferAttachmentImageInfo* CommandRecorder::CopyArray<VkFramebufferAttachmentImageInfo>(
    const VkFramebufferAttachmentImageInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFramebufferAttachmentImageInfo*>(
        m_allocator.Alloc(sizeof(VkFramebufferAttachmentImageInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].usage = src[start_index + i].usage;
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].layerCount = src[start_index + i].layerCount;
        ptr[i].viewFormatCount = src[start_index + i].viewFormatCount;
        ptr[i].pViewFormats = nullptr;
        if (src[start_index + i].pViewFormats) {
            ptr[i].pViewFormats = CopyArray<>(src[start_index + i].pViewFormats, 0, 1);
        }
    }
    return ptr;
}

template <>
VkFramebufferAttachmentsCreateInfo* CommandRecorder::CopyArray<VkFramebufferAttachmentsCreateInfo>(
    const VkFramebufferAttachmentsCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFramebufferAttachmentsCreateInfo*>(
        m_allocator.Alloc(sizeof(VkFramebufferAttachmentsCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentImageInfoCount = src[start_index + i].attachmentImageInfoCount;
        ptr[i].pAttachmentImageInfos = nullptr;
        if (src[start_index + i].pAttachmentImageInfos) {
            ptr[i].pAttachmentImageInfos = CopyArray<>(src[start_index + i].pAttachmentImageInfos, 0, 1);
        }
    }
    return ptr;
}

template <>
VkRenderPassAttachmentBeginInfo* CommandRecorder::CopyArray<VkRenderPassAttachmentBeginInfo>(
    const VkRenderPassAttachmentBeginInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassAttachmentBeginInfo*>(
        m_allocator.Alloc(sizeof(VkRenderPassAttachmentBeginInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pAttachments = nullptr;
        if (src[start_index + i].pAttachments) {
            ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceUniformBufferStandardLayoutFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(
    const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].uniformBufferStandardLayout = src[start_index + i].uniformBufferStandardLayout;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(
    const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSubgroupExtendedTypes = src[start_index + i].shaderSubgroupExtendedTypes;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(
    const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].separateDepthStencilLayouts = src[start_index + i].separateDepthStencilLayouts;
    }
    return ptr;
}

template <>
VkAttachmentReferenceStencilLayout* CommandRecorder::CopyArray<VkAttachmentReferenceStencilLayout>(
    const VkAttachmentReferenceStencilLayout* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentReferenceStencilLayout*>(
        m_allocator.Alloc(sizeof(VkAttachmentReferenceStencilLayout) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stencilLayout = src[start_index + i].stencilLayout;
    }
    return ptr;
}

template <>
VkAttachmentDescriptionStencilLayout* CommandRecorder::CopyArray<VkAttachmentDescriptionStencilLayout>(
    const VkAttachmentDescriptionStencilLayout* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentDescriptionStencilLayout*>(
        m_allocator.Alloc(sizeof(VkAttachmentDescriptionStencilLayout) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stencilInitialLayout = src[start_index + i].stencilInitialLayout;
        ptr[i].stencilFinalLayout = src[start_index + i].stencilFinalLayout;
    }
    return ptr;
}

template <>
VkPhysicalDeviceHostQueryResetFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceHostQueryResetFeatures>(
    const VkPhysicalDeviceHostQueryResetFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceHostQueryResetFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hostQueryReset = src[start_index + i].hostQueryReset;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTimelineSemaphoreFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreFeatures>(
    const VkPhysicalDeviceTimelineSemaphoreFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].timelineSemaphore = src[start_index + i].timelineSemaphore;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTimelineSemaphoreProperties* CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreProperties>(
    const VkPhysicalDeviceTimelineSemaphoreProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTimelineSemaphoreProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxTimelineSemaphoreValueDifference = src[start_index + i].maxTimelineSemaphoreValueDifference;
    }
    return ptr;
}

template <>
VkSemaphoreTypeCreateInfo* CommandRecorder::CopyArray<VkSemaphoreTypeCreateInfo>(const VkSemaphoreTypeCreateInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSemaphoreTypeCreateInfo*>(m_allocator.Alloc(sizeof(VkSemaphoreTypeCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphoreType = src[start_index + i].semaphoreType;
        ptr[i].initialValue = src[start_index + i].initialValue;
    }
    return ptr;
}

template <>
VkTimelineSemaphoreSubmitInfo* CommandRecorder::CopyArray<VkTimelineSemaphoreSubmitInfo>(
    const VkTimelineSemaphoreSubmitInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTimelineSemaphoreSubmitInfo*>(
        m_allocator.Alloc(sizeof(VkTimelineSemaphoreSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreValueCount = src[start_index + i].waitSemaphoreValueCount;
        ptr[i].pWaitSemaphoreValues = nullptr;
        if (src[start_index + i].pWaitSemaphoreValues) {
            ptr[i].pWaitSemaphoreValues = CopyArray<>(src[start_index + i].pWaitSemaphoreValues, 0, 1);
        }
        ptr[i].signalSemaphoreValueCount = src[start_index + i].signalSemaphoreValueCount;
        ptr[i].pSignalSemaphoreValues = nullptr;
        if (src[start_index + i].pSignalSemaphoreValues) {
            ptr[i].pSignalSemaphoreValues = CopyArray<>(src[start_index + i].pSignalSemaphoreValues, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSemaphoreWaitInfo* CommandRecorder::CopyArray<VkSemaphoreWaitInfo>(const VkSemaphoreWaitInfo* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreWaitInfo*>(m_allocator.Alloc(sizeof(VkSemaphoreWaitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].semaphoreCount = src[start_index + i].semaphoreCount;
        ptr[i].pSemaphores = nullptr;
        if (src[start_index + i].pSemaphores) {
            ptr[i].pSemaphores = CopyArray<>(src[start_index + i].pSemaphores, 0, 1);
        }
        ptr[i].pValues = nullptr;
        if (src[start_index + i].pValues) {
            ptr[i].pValues = CopyArray<>(src[start_index + i].pValues, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSemaphoreSignalInfo* CommandRecorder::CopyArray<VkSemaphoreSignalInfo>(const VkSemaphoreSignalInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreSignalInfo*>(m_allocator.Alloc(sizeof(VkSemaphoreSignalInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].value = src[start_index + i].value;
    }
    return ptr;
}

template <>
VkPhysicalDeviceBufferDeviceAddressFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeatures>(
    const VkPhysicalDeviceBufferDeviceAddressFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].bufferDeviceAddress = src[start_index + i].bufferDeviceAddress;
        ptr[i].bufferDeviceAddressCaptureReplay = src[start_index + i].bufferDeviceAddressCaptureReplay;
        ptr[i].bufferDeviceAddressMultiDevice = src[start_index + i].bufferDeviceAddressMultiDevice;
    }
    return ptr;
}

template <>
VkBufferDeviceAddressInfo* CommandRecorder::CopyArray<VkBufferDeviceAddressInfo>(const VkBufferDeviceAddressInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkBufferDeviceAddressInfo*>(m_allocator.Alloc(sizeof(VkBufferDeviceAddressInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkBufferOpaqueCaptureAddressCreateInfo* CommandRecorder::CopyArray<VkBufferOpaqueCaptureAddressCreateInfo>(
    const VkBufferOpaqueCaptureAddressCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo*>(
        m_allocator.Alloc(sizeof(VkBufferOpaqueCaptureAddressCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].opaqueCaptureAddress = src[start_index + i].opaqueCaptureAddress;
    }
    return ptr;
}

template <>
VkMemoryOpaqueCaptureAddressAllocateInfo* CommandRecorder::CopyArray<VkMemoryOpaqueCaptureAddressAllocateInfo>(
    const VkMemoryOpaqueCaptureAddressAllocateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo*>(
        m_allocator.Alloc(sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].opaqueCaptureAddress = src[start_index + i].opaqueCaptureAddress;
    }
    return ptr;
}

template <>
VkDeviceMemoryOpaqueCaptureAddressInfo* CommandRecorder::CopyArray<VkDeviceMemoryOpaqueCaptureAddressInfo>(
    const VkDeviceMemoryOpaqueCaptureAddressInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceMemoryOpaqueCaptureAddressInfo*>(
        m_allocator.Alloc(sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan13Features* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan13Features>(
    const VkPhysicalDeviceVulkan13Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan13Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan13Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].robustImageAccess = src[start_index + i].robustImageAccess;
        ptr[i].inlineUniformBlock = src[start_index + i].inlineUniformBlock;
        ptr[i].descriptorBindingInlineUniformBlockUpdateAfterBind =
            src[start_index + i].descriptorBindingInlineUniformBlockUpdateAfterBind;
        ptr[i].pipelineCreationCacheControl = src[start_index + i].pipelineCreationCacheControl;
        ptr[i].privateData = src[start_index + i].privateData;
        ptr[i].shaderDemoteToHelperInvocation = src[start_index + i].shaderDemoteToHelperInvocation;
        ptr[i].shaderTerminateInvocation = src[start_index + i].shaderTerminateInvocation;
        ptr[i].subgroupSizeControl = src[start_index + i].subgroupSizeControl;
        ptr[i].computeFullSubgroups = src[start_index + i].computeFullSubgroups;
        ptr[i].synchronization2 = src[start_index + i].synchronization2;
        ptr[i].textureCompressionASTC_HDR = src[start_index + i].textureCompressionASTC_HDR;
        ptr[i].shaderZeroInitializeWorkgroupMemory = src[start_index + i].shaderZeroInitializeWorkgroupMemory;
        ptr[i].dynamicRendering = src[start_index + i].dynamicRendering;
        ptr[i].shaderIntegerDotProduct = src[start_index + i].shaderIntegerDotProduct;
        ptr[i].maintenance4 = src[start_index + i].maintenance4;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVulkan13Properties* CommandRecorder::CopyArray<VkPhysicalDeviceVulkan13Properties>(
    const VkPhysicalDeviceVulkan13Properties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan13Properties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan13Properties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minSubgroupSize = src[start_index + i].minSubgroupSize;
        ptr[i].maxSubgroupSize = src[start_index + i].maxSubgroupSize;
        ptr[i].maxComputeWorkgroupSubgroups = src[start_index + i].maxComputeWorkgroupSubgroups;
        ptr[i].requiredSubgroupSizeStages = src[start_index + i].requiredSubgroupSizeStages;
        ptr[i].maxInlineUniformBlockSize = src[start_index + i].maxInlineUniformBlockSize;
        ptr[i].maxPerStageDescriptorInlineUniformBlocks = src[start_index + i].maxPerStageDescriptorInlineUniformBlocks;
        ptr[i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
        ptr[i].maxDescriptorSetInlineUniformBlocks = src[start_index + i].maxDescriptorSetInlineUniformBlocks;
        ptr[i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks =
            src[start_index + i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
        ptr[i].maxInlineUniformTotalSize = src[start_index + i].maxInlineUniformTotalSize;
        ptr[i].integerDotProduct8BitUnsignedAccelerated = src[start_index + i].integerDotProduct8BitUnsignedAccelerated;
        ptr[i].integerDotProduct8BitSignedAccelerated = src[start_index + i].integerDotProduct8BitSignedAccelerated;
        ptr[i].integerDotProduct8BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct8BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct4x8BitPackedUnsignedAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedUnsignedAccelerated;
        ptr[i].integerDotProduct4x8BitPackedSignedAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedSignedAccelerated;
        ptr[i].integerDotProduct4x8BitPackedMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedMixedSignednessAccelerated;
        ptr[i].integerDotProduct16BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct16BitUnsignedAccelerated;
        ptr[i].integerDotProduct16BitSignedAccelerated = src[start_index + i].integerDotProduct16BitSignedAccelerated;
        ptr[i].integerDotProduct16BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct16BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct32BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct32BitUnsignedAccelerated;
        ptr[i].integerDotProduct32BitSignedAccelerated = src[start_index + i].integerDotProduct32BitSignedAccelerated;
        ptr[i].integerDotProduct32BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct32BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct64BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct64BitUnsignedAccelerated;
        ptr[i].integerDotProduct64BitSignedAccelerated = src[start_index + i].integerDotProduct64BitSignedAccelerated;
        ptr[i].integerDotProduct64BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct64BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
        ptr[i].storageTexelBufferOffsetAlignmentBytes = src[start_index + i].storageTexelBufferOffsetAlignmentBytes;
        ptr[i].storageTexelBufferOffsetSingleTexelAlignment =
            src[start_index + i].storageTexelBufferOffsetSingleTexelAlignment;
        ptr[i].uniformTexelBufferOffsetAlignmentBytes = src[start_index + i].uniformTexelBufferOffsetAlignmentBytes;
        ptr[i].uniformTexelBufferOffsetSingleTexelAlignment =
            src[start_index + i].uniformTexelBufferOffsetSingleTexelAlignment;
        ptr[i].maxBufferSize = src[start_index + i].maxBufferSize;
    }
    return ptr;
}

template <>
VkPipelineCreationFeedback* CommandRecorder::CopyArray<VkPipelineCreationFeedback>(
    const VkPipelineCreationFeedback* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPipelineCreationFeedback*>(m_allocator.Alloc(sizeof(VkPipelineCreationFeedback) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].duration = src[start_index + i].duration;
    }
    return ptr;
}

template <>
VkPipelineCreationFeedbackCreateInfo* CommandRecorder::CopyArray<VkPipelineCreationFeedbackCreateInfo>(
    const VkPipelineCreationFeedbackCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCreationFeedbackCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineCreationFeedbackCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pPipelineCreationFeedback = src[start_index + i].pPipelineCreationFeedback;
        ptr[i].pipelineStageCreationFeedbackCount = src[start_index + i].pipelineStageCreationFeedbackCount;
        ptr[i].pPipelineStageCreationFeedbacks = nullptr;
        if (src[start_index + i].pPipelineStageCreationFeedbacks) {
            ptr[i].pPipelineStageCreationFeedbacks =
                CopyArray<>(src[start_index + i].pPipelineStageCreationFeedbacks, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderTerminateInvocationFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderTerminateInvocationFeatures>(
    const VkPhysicalDeviceShaderTerminateInvocationFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderTerminateInvocation = src[start_index + i].shaderTerminateInvocation;
    }
    return ptr;
}

template <>
VkPhysicalDeviceToolProperties* CommandRecorder::CopyArray<VkPhysicalDeviceToolProperties>(
    const VkPhysicalDeviceToolProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceToolProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceToolProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
        std::memcpy(ptr[i].version, src[start_index + i].version, sizeof(src[start_index + i].version));
        ptr[i].purposes = src[start_index + i].purposes;
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        std::memcpy(ptr[i].layer, src[start_index + i].layer, sizeof(src[start_index + i].layer));
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>(
    const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderDemoteToHelperInvocation = src[start_index + i].shaderDemoteToHelperInvocation;
    }
    return ptr;
}

template <>
VkPhysicalDevicePrivateDataFeatures* CommandRecorder::CopyArray<VkPhysicalDevicePrivateDataFeatures>(
    const VkPhysicalDevicePrivateDataFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePrivateDataFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePrivateDataFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].privateData = src[start_index + i].privateData;
    }
    return ptr;
}

template <>
VkDevicePrivateDataCreateInfo* CommandRecorder::CopyArray<VkDevicePrivateDataCreateInfo>(
    const VkDevicePrivateDataCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDevicePrivateDataCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDevicePrivateDataCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].privateDataSlotRequestCount = src[start_index + i].privateDataSlotRequestCount;
    }
    return ptr;
}

template <>
VkPrivateDataSlotCreateInfo* CommandRecorder::CopyArray<VkPrivateDataSlotCreateInfo>(
    const VkPrivateDataSlotCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPrivateDataSlotCreateInfo*>(m_allocator.Alloc(sizeof(VkPrivateDataSlotCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineCreationCacheControlFeatures*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineCreationCacheControlFeatures>(
    const VkPhysicalDevicePipelineCreationCacheControlFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineCreationCacheControl = src[start_index + i].pipelineCreationCacheControl;
    }
    return ptr;
}

template <>
VkMemoryBarrier2* CommandRecorder::CopyArray<VkMemoryBarrier2>(const VkMemoryBarrier2* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryBarrier2*>(m_allocator.Alloc(sizeof(VkMemoryBarrier2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
    }
    return ptr;
}

template <>
VkBufferMemoryBarrier2* CommandRecorder::CopyArray<VkBufferMemoryBarrier2>(const VkBufferMemoryBarrier2* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferMemoryBarrier2*>(m_allocator.Alloc(sizeof(VkBufferMemoryBarrier2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkImageMemoryBarrier2* CommandRecorder::CopyArray<VkImageMemoryBarrier2>(const VkImageMemoryBarrier2* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageMemoryBarrier2*>(m_allocator.Alloc(sizeof(VkImageMemoryBarrier2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcStageMask = src[start_index + i].srcStageMask;
        ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
        ptr[i].dstStageMask = src[start_index + i].dstStageMask;
        ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
        ptr[i].oldLayout = src[start_index + i].oldLayout;
        ptr[i].newLayout = src[start_index + i].newLayout;
        ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
        ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
        ptr[i].image = src[start_index + i].image;
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;
    }
    return ptr;
}

template <>
VkDependencyInfo* CommandRecorder::CopyArray<VkDependencyInfo>(const VkDependencyInfo* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkDependencyInfo*>(m_allocator.Alloc(sizeof(VkDependencyInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
        ptr[i].memoryBarrierCount = src[start_index + i].memoryBarrierCount;
        ptr[i].pMemoryBarriers = nullptr;
        if (src[start_index + i].pMemoryBarriers) {
            ptr[i].pMemoryBarriers = CopyArray<>(src[start_index + i].pMemoryBarriers, 0, 1);
        }
        ptr[i].bufferMemoryBarrierCount = src[start_index + i].bufferMemoryBarrierCount;
        ptr[i].pBufferMemoryBarriers = nullptr;
        if (src[start_index + i].pBufferMemoryBarriers) {
            ptr[i].pBufferMemoryBarriers = CopyArray<>(src[start_index + i].pBufferMemoryBarriers, 0, 1);
        }
        ptr[i].imageMemoryBarrierCount = src[start_index + i].imageMemoryBarrierCount;
        ptr[i].pImageMemoryBarriers = nullptr;
        if (src[start_index + i].pImageMemoryBarriers) {
            ptr[i].pImageMemoryBarriers = CopyArray<>(src[start_index + i].pImageMemoryBarriers, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSemaphoreSubmitInfo* CommandRecorder::CopyArray<VkSemaphoreSubmitInfo>(const VkSemaphoreSubmitInfo* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreSubmitInfo*>(m_allocator.Alloc(sizeof(VkSemaphoreSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].value = src[start_index + i].value;
        ptr[i].stageMask = src[start_index + i].stageMask;
        ptr[i].deviceIndex = src[start_index + i].deviceIndex;
    }
    return ptr;
}

template <>
VkCommandBufferSubmitInfo* CommandRecorder::CopyArray<VkCommandBufferSubmitInfo>(const VkCommandBufferSubmitInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCommandBufferSubmitInfo*>(m_allocator.Alloc(sizeof(VkCommandBufferSubmitInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].commandBuffer = src[start_index + i].commandBuffer;
        ptr[i].deviceMask = src[start_index + i].deviceMask;
    }
    return ptr;
}

template <>
VkSubmitInfo2* CommandRecorder::CopyArray<VkSubmitInfo2>(const VkSubmitInfo2* src, uint64_t start_index,
                                                         uint64_t count) {
    auto ptr = reinterpret_cast<VkSubmitInfo2*>(m_allocator.Alloc(sizeof(VkSubmitInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].waitSemaphoreInfoCount = src[start_index + i].waitSemaphoreInfoCount;
        ptr[i].pWaitSemaphoreInfos = nullptr;
        if (src[start_index + i].pWaitSemaphoreInfos) {
            ptr[i].pWaitSemaphoreInfos = CopyArray<>(src[start_index + i].pWaitSemaphoreInfos, 0, 1);
        }
        ptr[i].commandBufferInfoCount = src[start_index + i].commandBufferInfoCount;
        ptr[i].pCommandBufferInfos = nullptr;
        if (src[start_index + i].pCommandBufferInfos) {
            ptr[i].pCommandBufferInfos = CopyArray<>(src[start_index + i].pCommandBufferInfos, 0, 1);
        }
        ptr[i].signalSemaphoreInfoCount = src[start_index + i].signalSemaphoreInfoCount;
        ptr[i].pSignalSemaphoreInfos = nullptr;
        if (src[start_index + i].pSignalSemaphoreInfos) {
            ptr[i].pSignalSemaphoreInfos = CopyArray<>(src[start_index + i].pSignalSemaphoreInfos, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceSynchronization2Features* CommandRecorder::CopyArray<VkPhysicalDeviceSynchronization2Features>(
    const VkPhysicalDeviceSynchronization2Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSynchronization2Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSynchronization2Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].synchronization2 = src[start_index + i].synchronization2;
    }
    return ptr;
}

template <>
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>(
    const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderZeroInitializeWorkgroupMemory = src[start_index + i].shaderZeroInitializeWorkgroupMemory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageRobustnessFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceImageRobustnessFeatures>(
    const VkPhysicalDeviceImageRobustnessFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageRobustnessFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageRobustnessFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].robustImageAccess = src[start_index + i].robustImageAccess;
    }
    return ptr;
}

template <>
VkBufferCopy2* CommandRecorder::CopyArray<VkBufferCopy2>(const VkBufferCopy2* src, uint64_t start_index,
                                                         uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCopy2*>(m_allocator.Alloc(sizeof(VkBufferCopy2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkCopyBufferInfo2* CommandRecorder::CopyArray<VkCopyBufferInfo2>(const VkCopyBufferInfo2* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyBufferInfo2*>(m_allocator.Alloc(sizeof(VkCopyBufferInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcBuffer = src[start_index + i].srcBuffer;
        ptr[i].dstBuffer = src[start_index + i].dstBuffer;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageCopy2* CommandRecorder::CopyArray<VkImageCopy2>(const VkImageCopy2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCopy2*>(m_allocator.Alloc(sizeof(VkImageCopy2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].extent = src[start_index + i].extent;
    }
    return ptr;
}

template <>
VkCopyImageInfo2* CommandRecorder::CopyArray<VkCopyImageInfo2>(const VkCopyImageInfo2* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyImageInfo2*>(m_allocator.Alloc(sizeof(VkCopyImageInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBufferImageCopy2* CommandRecorder::CopyArray<VkBufferImageCopy2>(const VkBufferImageCopy2* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferImageCopy2*>(m_allocator.Alloc(sizeof(VkBufferImageCopy2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].bufferOffset = src[start_index + i].bufferOffset;
        ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;
        ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
        ptr[i].imageOffset = src[start_index + i].imageOffset;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkCopyBufferToImageInfo2* CommandRecorder::CopyArray<VkCopyBufferToImageInfo2>(const VkCopyBufferToImageInfo2* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyBufferToImageInfo2*>(m_allocator.Alloc(sizeof(VkCopyBufferToImageInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcBuffer = src[start_index + i].srcBuffer;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyImageToBufferInfo2* CommandRecorder::CopyArray<VkCopyImageToBufferInfo2>(const VkCopyImageToBufferInfo2* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyImageToBufferInfo2*>(m_allocator.Alloc(sizeof(VkCopyImageToBufferInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].dstBuffer = src[start_index + i].dstBuffer;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageBlit2* CommandRecorder::CopyArray<VkImageBlit2>(const VkImageBlit2* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageBlit2*>(m_allocator.Alloc(sizeof(VkImageBlit2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        std::memcpy(ptr[i].srcOffsets, src[start_index + i].srcOffsets, sizeof(src[start_index + i].srcOffsets));
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        std::memcpy(ptr[i].dstOffsets, src[start_index + i].dstOffsets, sizeof(src[start_index + i].dstOffsets));
    }
    return ptr;
}

template <>
VkBlitImageInfo2* CommandRecorder::CopyArray<VkBlitImageInfo2>(const VkBlitImageInfo2* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkBlitImageInfo2*>(m_allocator.Alloc(sizeof(VkBlitImageInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
        ptr[i].filter = src[start_index + i].filter;
    }
    return ptr;
}

template <>
VkImageResolve2* CommandRecorder::CopyArray<VkImageResolve2>(const VkImageResolve2* src, uint64_t start_index,
                                                             uint64_t count) {
    auto ptr = reinterpret_cast<VkImageResolve2*>(m_allocator.Alloc(sizeof(VkImageResolve2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcSubresource = src[start_index + i].srcSubresource;
        ptr[i].srcOffset = src[start_index + i].srcOffset;
        ptr[i].dstSubresource = src[start_index + i].dstSubresource;
        ptr[i].dstOffset = src[start_index + i].dstOffset;
        ptr[i].extent = src[start_index + i].extent;
    }
    return ptr;
}

template <>
VkResolveImageInfo2* CommandRecorder::CopyArray<VkResolveImageInfo2>(const VkResolveImageInfo2* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkResolveImageInfo2*>(m_allocator.Alloc(sizeof(VkResolveImageInfo2) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubgroupSizeControlFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlFeatures>(
    const VkPhysicalDeviceSubgroupSizeControlFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subgroupSizeControl = src[start_index + i].subgroupSizeControl;
        ptr[i].computeFullSubgroups = src[start_index + i].computeFullSubgroups;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubgroupSizeControlProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlProperties>(
    const VkPhysicalDeviceSubgroupSizeControlProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupSizeControlProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minSubgroupSize = src[start_index + i].minSubgroupSize;
        ptr[i].maxSubgroupSize = src[start_index + i].maxSubgroupSize;
        ptr[i].maxComputeWorkgroupSubgroups = src[start_index + i].maxComputeWorkgroupSubgroups;
        ptr[i].requiredSubgroupSizeStages = src[start_index + i].requiredSubgroupSizeStages;
    }
    return ptr;
}

template <>
VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*
CommandRecorder::CopyArray<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>(
    const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].requiredSubgroupSize = src[start_index + i].requiredSubgroupSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceInlineUniformBlockFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockFeatures>(
    const VkPhysicalDeviceInlineUniformBlockFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceInlineUniformBlockFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].inlineUniformBlock = src[start_index + i].inlineUniformBlock;
        ptr[i].descriptorBindingInlineUniformBlockUpdateAfterBind =
            src[start_index + i].descriptorBindingInlineUniformBlockUpdateAfterBind;
    }
    return ptr;
}

template <>
VkPhysicalDeviceInlineUniformBlockProperties* CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockProperties>(
    const VkPhysicalDeviceInlineUniformBlockProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceInlineUniformBlockProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceInlineUniformBlockProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxInlineUniformBlockSize = src[start_index + i].maxInlineUniformBlockSize;
        ptr[i].maxPerStageDescriptorInlineUniformBlocks = src[start_index + i].maxPerStageDescriptorInlineUniformBlocks;
        ptr[i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
        ptr[i].maxDescriptorSetInlineUniformBlocks = src[start_index + i].maxDescriptorSetInlineUniformBlocks;
        ptr[i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks =
            src[start_index + i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
    }
    return ptr;
}

template <>
VkWriteDescriptorSetInlineUniformBlock* CommandRecorder::CopyArray<VkWriteDescriptorSetInlineUniformBlock>(
    const VkWriteDescriptorSetInlineUniformBlock* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWriteDescriptorSetInlineUniformBlock*>(
        m_allocator.Alloc(sizeof(VkWriteDescriptorSetInlineUniformBlock) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dataSize = src[start_index + i].dataSize;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkDescriptorPoolInlineUniformBlockCreateInfo* CommandRecorder::CopyArray<VkDescriptorPoolInlineUniformBlockCreateInfo>(
    const VkDescriptorPoolInlineUniformBlockCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfo*>(
        m_allocator.Alloc(sizeof(VkDescriptorPoolInlineUniformBlockCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxInlineUniformBlockBindings = src[start_index + i].maxInlineUniformBlockBindings;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTextureCompressionASTCHDRFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>(
    const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].textureCompressionASTC_HDR = src[start_index + i].textureCompressionASTC_HDR;
    }
    return ptr;
}

template <>
VkRenderingAttachmentInfo* CommandRecorder::CopyArray<VkRenderingAttachmentInfo>(const VkRenderingAttachmentInfo* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkRenderingAttachmentInfo*>(m_allocator.Alloc(sizeof(VkRenderingAttachmentInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].imageLayout = src[start_index + i].imageLayout;
        ptr[i].resolveMode = src[start_index + i].resolveMode;
        ptr[i].resolveImageView = src[start_index + i].resolveImageView;
        ptr[i].resolveImageLayout = src[start_index + i].resolveImageLayout;
        ptr[i].loadOp = src[start_index + i].loadOp;
        ptr[i].storeOp = src[start_index + i].storeOp;
        ptr[i].clearValue = src[start_index + i].clearValue;
    }
    return ptr;
}

template <>
VkRenderingInfo* CommandRecorder::CopyArray<VkRenderingInfo>(const VkRenderingInfo* src, uint64_t start_index,
                                                             uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingInfo*>(m_allocator.Alloc(sizeof(VkRenderingInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].renderArea = src[start_index + i].renderArea;
        ptr[i].layerCount = src[start_index + i].layerCount;
        ptr[i].viewMask = src[start_index + i].viewMask;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachments = nullptr;
        if (src[start_index + i].pColorAttachments) {
            ptr[i].pColorAttachments = CopyArray<>(src[start_index + i].pColorAttachments, 0, 1);
        }
        ptr[i].pDepthAttachment = src[start_index + i].pDepthAttachment;
        ptr[i].pStencilAttachment = src[start_index + i].pStencilAttachment;
    }
    return ptr;
}

template <>
VkPipelineRenderingCreateInfo* CommandRecorder::CopyArray<VkPipelineRenderingCreateInfo>(
    const VkPipelineRenderingCreateInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRenderingCreateInfo*>(
        m_allocator.Alloc(sizeof(VkPipelineRenderingCreateInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].viewMask = src[start_index + i].viewMask;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentFormats = nullptr;
        if (src[start_index + i].pColorAttachmentFormats) {
            ptr[i].pColorAttachmentFormats = CopyArray<>(src[start_index + i].pColorAttachmentFormats, 0, 1);
        }
        ptr[i].depthAttachmentFormat = src[start_index + i].depthAttachmentFormat;
        ptr[i].stencilAttachmentFormat = src[start_index + i].stencilAttachmentFormat;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDynamicRenderingFeatures* CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingFeatures>(
    const VkPhysicalDeviceDynamicRenderingFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDynamicRenderingFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDynamicRenderingFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dynamicRendering = src[start_index + i].dynamicRendering;
    }
    return ptr;
}

template <>
VkCommandBufferInheritanceRenderingInfo* CommandRecorder::CopyArray<VkCommandBufferInheritanceRenderingInfo>(
    const VkCommandBufferInheritanceRenderingInfo* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceRenderingInfo*>(
        m_allocator.Alloc(sizeof(VkCommandBufferInheritanceRenderingInfo) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].viewMask = src[start_index + i].viewMask;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentFormats = nullptr;
        if (src[start_index + i].pColorAttachmentFormats) {
            ptr[i].pColorAttachmentFormats = CopyArray<>(src[start_index + i].pColorAttachmentFormats, 0, 1);
        }
        ptr[i].depthAttachmentFormat = src[start_index + i].depthAttachmentFormat;
        ptr[i].stencilAttachmentFormat = src[start_index + i].stencilAttachmentFormat;
        ptr[i].rasterizationSamples = src[start_index + i].rasterizationSamples;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderIntegerDotProductFeatures*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerDotProductFeatures>(
    const VkPhysicalDeviceShaderIntegerDotProductFeatures* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductFeatures*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderIntegerDotProduct = src[start_index + i].shaderIntegerDotProduct;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderIntegerDotProductProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerDotProductProperties>(
    const VkPhysicalDeviceShaderIntegerDotProductProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderIntegerDotProductProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].integerDotProduct8BitUnsignedAccelerated = src[start_index + i].integerDotProduct8BitUnsignedAccelerated;
        ptr[i].integerDotProduct8BitSignedAccelerated = src[start_index + i].integerDotProduct8BitSignedAccelerated;
        ptr[i].integerDotProduct8BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct8BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct4x8BitPackedUnsignedAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedUnsignedAccelerated;
        ptr[i].integerDotProduct4x8BitPackedSignedAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedSignedAccelerated;
        ptr[i].integerDotProduct4x8BitPackedMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct4x8BitPackedMixedSignednessAccelerated;
        ptr[i].integerDotProduct16BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct16BitUnsignedAccelerated;
        ptr[i].integerDotProduct16BitSignedAccelerated = src[start_index + i].integerDotProduct16BitSignedAccelerated;
        ptr[i].integerDotProduct16BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct16BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct32BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct32BitUnsignedAccelerated;
        ptr[i].integerDotProduct32BitSignedAccelerated = src[start_index + i].integerDotProduct32BitSignedAccelerated;
        ptr[i].integerDotProduct32BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct32BitMixedSignednessAccelerated;
        ptr[i].integerDotProduct64BitUnsignedAccelerated =
            src[start_index + i].integerDotProduct64BitUnsignedAccelerated;
        ptr[i].integerDotProduct64BitSignedAccelerated = src[start_index + i].integerDotProduct64BitSignedAccelerated;
        ptr[i].integerDotProduct64BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProduct64BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitUnsignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitUnsignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitSignedAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitSignedAccelerated;
        ptr[i].integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated =
            src[start_index + i].integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTexelBufferAlignmentProperties*
CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentProperties>(
    const VkPhysicalDeviceTexelBufferAlignmentProperties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentProperties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].storageTexelBufferOffsetAlignmentBytes = src[start_index + i].storageTexelBufferOffsetAlignmentBytes;
        ptr[i].storageTexelBufferOffsetSingleTexelAlignment =
            src[start_index + i].storageTexelBufferOffsetSingleTexelAlignment;
        ptr[i].uniformTexelBufferOffsetAlignmentBytes = src[start_index + i].uniformTexelBufferOffsetAlignmentBytes;
        ptr[i].uniformTexelBufferOffsetSingleTexelAlignment =
            src[start_index + i].uniformTexelBufferOffsetSingleTexelAlignment;
    }
    return ptr;
}

template <>
VkFormatProperties3* CommandRecorder::CopyArray<VkFormatProperties3>(const VkFormatProperties3* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFormatProperties3*>(m_allocator.Alloc(sizeof(VkFormatProperties3) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].linearTilingFeatures = src[start_index + i].linearTilingFeatures;
        ptr[i].optimalTilingFeatures = src[start_index + i].optimalTilingFeatures;
        ptr[i].bufferFeatures = src[start_index + i].bufferFeatures;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance4Features* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance4Features>(
    const VkPhysicalDeviceMaintenance4Features* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance4Features*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance4Features) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maintenance4 = src[start_index + i].maintenance4;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance4Properties* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance4Properties>(
    const VkPhysicalDeviceMaintenance4Properties* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance4Properties*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance4Properties) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxBufferSize = src[start_index + i].maxBufferSize;
    }
    return ptr;
}

template <>
VkDeviceBufferMemoryRequirements* CommandRecorder::CopyArray<VkDeviceBufferMemoryRequirements>(
    const VkDeviceBufferMemoryRequirements* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceBufferMemoryRequirements*>(
        m_allocator.Alloc(sizeof(VkDeviceBufferMemoryRequirements) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pCreateInfo = src[start_index + i].pCreateInfo;
    }
    return ptr;
}

template <>
VkDeviceImageMemoryRequirements* CommandRecorder::CopyArray<VkDeviceImageMemoryRequirements>(
    const VkDeviceImageMemoryRequirements* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceImageMemoryRequirements*>(
        m_allocator.Alloc(sizeof(VkDeviceImageMemoryRequirements) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pCreateInfo = src[start_index + i].pCreateInfo;
        ptr[i].planeAspect = src[start_index + i].planeAspect;
    }
    return ptr;
}

template <>
VkSurfaceCapabilitiesKHR* CommandRecorder::CopyArray<VkSurfaceCapabilitiesKHR>(const VkSurfaceCapabilitiesKHR* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceCapabilitiesKHR*>(m_allocator.Alloc(sizeof(VkSurfaceCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].minImageCount = src[start_index + i].minImageCount;
        ptr[i].maxImageCount = src[start_index + i].maxImageCount;
        ptr[i].currentExtent = src[start_index + i].currentExtent;
        ptr[i].minImageExtent = src[start_index + i].minImageExtent;
        ptr[i].maxImageExtent = src[start_index + i].maxImageExtent;
        ptr[i].maxImageArrayLayers = src[start_index + i].maxImageArrayLayers;
        ptr[i].supportedTransforms = src[start_index + i].supportedTransforms;
        ptr[i].currentTransform = src[start_index + i].currentTransform;
        ptr[i].supportedCompositeAlpha = src[start_index + i].supportedCompositeAlpha;
        ptr[i].supportedUsageFlags = src[start_index + i].supportedUsageFlags;
    }
    return ptr;
}

template <>
VkSurfaceFormatKHR* CommandRecorder::CopyArray<VkSurfaceFormatKHR>(const VkSurfaceFormatKHR* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceFormatKHR*>(m_allocator.Alloc(sizeof(VkSurfaceFormatKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].format = src[start_index + i].format;
        ptr[i].colorSpace = src[start_index + i].colorSpace;
    }
    return ptr;
}

template <>
VkSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkSwapchainCreateInfoKHR>(const VkSwapchainCreateInfoKHR* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkSwapchainCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].surface = src[start_index + i].surface;
        ptr[i].minImageCount = src[start_index + i].minImageCount;
        ptr[i].imageFormat = src[start_index + i].imageFormat;
        ptr[i].imageColorSpace = src[start_index + i].imageColorSpace;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
        ptr[i].imageArrayLayers = src[start_index + i].imageArrayLayers;
        ptr[i].imageUsage = src[start_index + i].imageUsage;
        ptr[i].imageSharingMode = src[start_index + i].imageSharingMode;
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices) {
            ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
        }
        ptr[i].preTransform = src[start_index + i].preTransform;
        ptr[i].compositeAlpha = src[start_index + i].compositeAlpha;
        ptr[i].presentMode = src[start_index + i].presentMode;
        ptr[i].clipped = src[start_index + i].clipped;
        ptr[i].oldSwapchain = src[start_index + i].oldSwapchain;
    }
    return ptr;
}

template <>
VkPresentInfoKHR* CommandRecorder::CopyArray<VkPresentInfoKHR>(const VkPresentInfoKHR* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentInfoKHR*>(m_allocator.Alloc(sizeof(VkPresentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
        ptr[i].pWaitSemaphores = nullptr;
        if (src[start_index + i].pWaitSemaphores) {
            ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
        }
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pSwapchains = nullptr;
        if (src[start_index + i].pSwapchains) {
            ptr[i].pSwapchains = CopyArray<>(src[start_index + i].pSwapchains, 0, 1);
        }
        ptr[i].pImageIndices = nullptr;
        if (src[start_index + i].pImageIndices) {
            ptr[i].pImageIndices = CopyArray<>(src[start_index + i].pImageIndices, 0, 1);
        }
        ptr[i].pResults = nullptr;
        if (src[start_index + i].pResults) {
            ptr[i].pResults = CopyArray<>(src[start_index + i].pResults, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkImageSwapchainCreateInfoKHR>(
    const VkImageSwapchainCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSwapchainCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkImageSwapchainCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchain = src[start_index + i].swapchain;
    }
    return ptr;
}

template <>
VkBindImageMemorySwapchainInfoKHR* CommandRecorder::CopyArray<VkBindImageMemorySwapchainInfoKHR>(
    const VkBindImageMemorySwapchainInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindImageMemorySwapchainInfoKHR*>(
        m_allocator.Alloc(sizeof(VkBindImageMemorySwapchainInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchain = src[start_index + i].swapchain;
        ptr[i].imageIndex = src[start_index + i].imageIndex;
    }
    return ptr;
}

template <>
VkAcquireNextImageInfoKHR* CommandRecorder::CopyArray<VkAcquireNextImageInfoKHR>(const VkAcquireNextImageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkAcquireNextImageInfoKHR*>(m_allocator.Alloc(sizeof(VkAcquireNextImageInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchain = src[start_index + i].swapchain;
        ptr[i].timeout = src[start_index + i].timeout;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].fence = src[start_index + i].fence;
        ptr[i].deviceMask = src[start_index + i].deviceMask;
    }
    return ptr;
}

template <>
VkDeviceGroupPresentCapabilitiesKHR* CommandRecorder::CopyArray<VkDeviceGroupPresentCapabilitiesKHR>(
    const VkDeviceGroupPresentCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkDeviceGroupPresentCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].presentMask, src[start_index + i].presentMask, sizeof(src[start_index + i].presentMask));
        ptr[i].modes = src[start_index + i].modes;
    }
    return ptr;
}

template <>
VkDeviceGroupPresentInfoKHR* CommandRecorder::CopyArray<VkDeviceGroupPresentInfoKHR>(
    const VkDeviceGroupPresentInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDeviceGroupPresentInfoKHR*>(m_allocator.Alloc(sizeof(VkDeviceGroupPresentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pDeviceMasks = nullptr;
        if (src[start_index + i].pDeviceMasks) {
            ptr[i].pDeviceMasks = CopyArray<>(src[start_index + i].pDeviceMasks, 0, 1);
        }
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkDeviceGroupSwapchainCreateInfoKHR* CommandRecorder::CopyArray<VkDeviceGroupSwapchainCreateInfoKHR>(
    const VkDeviceGroupSwapchainCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkDeviceGroupSwapchainCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].modes = src[start_index + i].modes;
    }
    return ptr;
}

template <>
VkDisplayModeParametersKHR* CommandRecorder::CopyArray<VkDisplayModeParametersKHR>(
    const VkDisplayModeParametersKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDisplayModeParametersKHR*>(m_allocator.Alloc(sizeof(VkDisplayModeParametersKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].visibleRegion = src[start_index + i].visibleRegion;
        ptr[i].refreshRate = src[start_index + i].refreshRate;
    }
    return ptr;
}

template <>
VkDisplayModeCreateInfoKHR* CommandRecorder::CopyArray<VkDisplayModeCreateInfoKHR>(
    const VkDisplayModeCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDisplayModeCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkDisplayModeCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].parameters = src[start_index + i].parameters;
    }
    return ptr;
}

template <>
VkDisplayModePropertiesKHR* CommandRecorder::CopyArray<VkDisplayModePropertiesKHR>(
    const VkDisplayModePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDisplayModePropertiesKHR*>(m_allocator.Alloc(sizeof(VkDisplayModePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].displayMode = src[start_index + i].displayMode;
        ptr[i].parameters = src[start_index + i].parameters;
    }
    return ptr;
}

template <>
VkDisplayPlaneCapabilitiesKHR* CommandRecorder::CopyArray<VkDisplayPlaneCapabilitiesKHR>(
    const VkDisplayPlaneCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPlaneCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkDisplayPlaneCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].supportedAlpha = src[start_index + i].supportedAlpha;
        ptr[i].minSrcPosition = src[start_index + i].minSrcPosition;
        ptr[i].maxSrcPosition = src[start_index + i].maxSrcPosition;
        ptr[i].minSrcExtent = src[start_index + i].minSrcExtent;
        ptr[i].maxSrcExtent = src[start_index + i].maxSrcExtent;
        ptr[i].minDstPosition = src[start_index + i].minDstPosition;
        ptr[i].maxDstPosition = src[start_index + i].maxDstPosition;
        ptr[i].minDstExtent = src[start_index + i].minDstExtent;
        ptr[i].maxDstExtent = src[start_index + i].maxDstExtent;
    }
    return ptr;
}

template <>
VkDisplayPlanePropertiesKHR* CommandRecorder::CopyArray<VkDisplayPlanePropertiesKHR>(
    const VkDisplayPlanePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDisplayPlanePropertiesKHR*>(m_allocator.Alloc(sizeof(VkDisplayPlanePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].currentDisplay = src[start_index + i].currentDisplay;
        ptr[i].currentStackIndex = src[start_index + i].currentStackIndex;
    }
    return ptr;
}

template <>
VkDisplayPropertiesKHR* CommandRecorder::CopyArray<VkDisplayPropertiesKHR>(const VkDisplayPropertiesKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPropertiesKHR*>(m_allocator.Alloc(sizeof(VkDisplayPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].display = src[start_index + i].display;
        ptr[i].displayName = nullptr;
        if (src[start_index + i].displayName) {
            ptr[i].displayName =
                CopyArray<>(src[start_index + i].displayName, 0, strlen(src[start_index + i].displayName) + 1);
        }
        ptr[i].physicalDimensions = src[start_index + i].physicalDimensions;
        ptr[i].physicalResolution = src[start_index + i].physicalResolution;
        ptr[i].supportedTransforms = src[start_index + i].supportedTransforms;
        ptr[i].planeReorderPossible = src[start_index + i].planeReorderPossible;
        ptr[i].persistentContent = src[start_index + i].persistentContent;
    }
    return ptr;
}

template <>
VkDisplaySurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkDisplaySurfaceCreateInfoKHR>(
    const VkDisplaySurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplaySurfaceCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkDisplaySurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].displayMode = src[start_index + i].displayMode;
        ptr[i].planeIndex = src[start_index + i].planeIndex;
        ptr[i].planeStackIndex = src[start_index + i].planeStackIndex;
        ptr[i].transform = src[start_index + i].transform;
        ptr[i].globalAlpha = src[start_index + i].globalAlpha;
        ptr[i].alphaMode = src[start_index + i].alphaMode;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkDisplayPresentInfoKHR* CommandRecorder::CopyArray<VkDisplayPresentInfoKHR>(const VkDisplayPresentInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPresentInfoKHR*>(m_allocator.Alloc(sizeof(VkDisplayPresentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcRect = src[start_index + i].srcRect;
        ptr[i].dstRect = src[start_index + i].dstRect;
        ptr[i].persistent = src[start_index + i].persistent;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_XLIB_KHR
template <>
VkXlibSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkXlibSurfaceCreateInfoKHR>(
    const VkXlibSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkXlibSurfaceCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkXlibSurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].dpy = src[start_index + i].dpy;
        ptr[i].window = src[start_index + i].window;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_XLIB_KHR

#ifdef VK_USE_PLATFORM_XCB_KHR
template <>
VkXcbSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkXcbSurfaceCreateInfoKHR>(const VkXcbSurfaceCreateInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkXcbSurfaceCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkXcbSurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].connection = src[start_index + i].connection;
        ptr[i].window = src[start_index + i].window;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_XCB_KHR

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
template <>
VkWaylandSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkWaylandSurfaceCreateInfoKHR>(
    const VkWaylandSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWaylandSurfaceCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkWaylandSurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].display = src[start_index + i].display;
        ptr[i].surface = src[start_index + i].surface;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WAYLAND_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidSurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkAndroidSurfaceCreateInfoKHR>(
    const VkAndroidSurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidSurfaceCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAndroidSurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].window = src[start_index + i].window;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32SurfaceCreateInfoKHR* CommandRecorder::CopyArray<VkWin32SurfaceCreateInfoKHR>(
    const VkWin32SurfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkWin32SurfaceCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkWin32SurfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].hinstance = src[start_index + i].hinstance;
        ptr[i].hwnd = src[start_index + i].hwnd;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkQueueFamilyQueryResultStatusPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyQueryResultStatusPropertiesKHR>(
    const VkQueueFamilyQueryResultStatusPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyQueryResultStatusPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkQueueFamilyQueryResultStatusPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queryResultStatusSupport = src[start_index + i].queryResultStatusSupport;
    }
    return ptr;
}

template <>
VkQueueFamilyVideoPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyVideoPropertiesKHR>(
    const VkQueueFamilyVideoPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyVideoPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkQueueFamilyVideoPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoCodecOperations = src[start_index + i].videoCodecOperations;
    }
    return ptr;
}

template <>
VkVideoProfileInfoKHR* CommandRecorder::CopyArray<VkVideoProfileInfoKHR>(const VkVideoProfileInfoKHR* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoProfileInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoCodecOperation = src[start_index + i].videoCodecOperation;
        ptr[i].chromaSubsampling = src[start_index + i].chromaSubsampling;
        ptr[i].lumaBitDepth = src[start_index + i].lumaBitDepth;
        ptr[i].chromaBitDepth = src[start_index + i].chromaBitDepth;
    }
    return ptr;
}

template <>
VkVideoProfileListInfoKHR* CommandRecorder::CopyArray<VkVideoProfileListInfoKHR>(const VkVideoProfileListInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoProfileListInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoProfileListInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].profileCount = src[start_index + i].profileCount;
        ptr[i].pProfiles = nullptr;
        if (src[start_index + i].pProfiles) {
            ptr[i].pProfiles = CopyArray<>(src[start_index + i].pProfiles, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoCapabilitiesKHR>(const VkVideoCapabilitiesKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoCapabilitiesKHR*>(m_allocator.Alloc(sizeof(VkVideoCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].minBitstreamBufferOffsetAlignment = src[start_index + i].minBitstreamBufferOffsetAlignment;
        ptr[i].minBitstreamBufferSizeAlignment = src[start_index + i].minBitstreamBufferSizeAlignment;
        ptr[i].pictureAccessGranularity = src[start_index + i].pictureAccessGranularity;
        ptr[i].minCodedExtent = src[start_index + i].minCodedExtent;
        ptr[i].maxCodedExtent = src[start_index + i].maxCodedExtent;
        ptr[i].maxDpbSlots = src[start_index + i].maxDpbSlots;
        ptr[i].maxActiveReferencePictures = src[start_index + i].maxActiveReferencePictures;
        ptr[i].stdHeaderVersion = src[start_index + i].stdHeaderVersion;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVideoFormatInfoKHR* CommandRecorder::CopyArray<VkPhysicalDeviceVideoFormatInfoKHR>(
    const VkPhysicalDeviceVideoFormatInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVideoFormatInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVideoFormatInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageUsage = src[start_index + i].imageUsage;
    }
    return ptr;
}

template <>
VkVideoFormatPropertiesKHR* CommandRecorder::CopyArray<VkVideoFormatPropertiesKHR>(
    const VkVideoFormatPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoFormatPropertiesKHR*>(m_allocator.Alloc(sizeof(VkVideoFormatPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].componentMapping = src[start_index + i].componentMapping;
        ptr[i].imageCreateFlags = src[start_index + i].imageCreateFlags;
        ptr[i].imageType = src[start_index + i].imageType;
        ptr[i].imageTiling = src[start_index + i].imageTiling;
        ptr[i].imageUsageFlags = src[start_index + i].imageUsageFlags;
    }
    return ptr;
}

template <>
VkVideoPictureResourceInfoKHR* CommandRecorder::CopyArray<VkVideoPictureResourceInfoKHR>(
    const VkVideoPictureResourceInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoPictureResourceInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoPictureResourceInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].codedOffset = src[start_index + i].codedOffset;
        ptr[i].codedExtent = src[start_index + i].codedExtent;
        ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
        ptr[i].imageViewBinding = src[start_index + i].imageViewBinding;
    }
    return ptr;
}

template <>
VkVideoReferenceSlotInfoKHR* CommandRecorder::CopyArray<VkVideoReferenceSlotInfoKHR>(
    const VkVideoReferenceSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoReferenceSlotInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoReferenceSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].slotIndex = src[start_index + i].slotIndex;
        ptr[i].pPictureResource = src[start_index + i].pPictureResource;
    }
    return ptr;
}

template <>
VkVideoSessionMemoryRequirementsKHR* CommandRecorder::CopyArray<VkVideoSessionMemoryRequirementsKHR>(
    const VkVideoSessionMemoryRequirementsKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoSessionMemoryRequirementsKHR*>(
        m_allocator.Alloc(sizeof(VkVideoSessionMemoryRequirementsKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryBindIndex = src[start_index + i].memoryBindIndex;
        ptr[i].memoryRequirements = src[start_index + i].memoryRequirements;
    }
    return ptr;
}

template <>
VkBindVideoSessionMemoryInfoKHR* CommandRecorder::CopyArray<VkBindVideoSessionMemoryInfoKHR>(
    const VkBindVideoSessionMemoryInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindVideoSessionMemoryInfoKHR*>(
        m_allocator.Alloc(sizeof(VkBindVideoSessionMemoryInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryBindIndex = src[start_index + i].memoryBindIndex;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
        ptr[i].memorySize = src[start_index + i].memorySize;
    }
    return ptr;
}

template <>
VkVideoSessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionCreateInfoKHR>(
    const VkVideoSessionCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoSessionCreateInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoSessionCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pVideoProfile = src[start_index + i].pVideoProfile;
        ptr[i].pictureFormat = src[start_index + i].pictureFormat;
        ptr[i].maxCodedExtent = src[start_index + i].maxCodedExtent;
        ptr[i].referencePictureFormat = src[start_index + i].referencePictureFormat;
        ptr[i].maxDpbSlots = src[start_index + i].maxDpbSlots;
        ptr[i].maxActiveReferencePictures = src[start_index + i].maxActiveReferencePictures;
        ptr[i].pStdHeaderVersion = src[start_index + i].pStdHeaderVersion;
    }
    return ptr;
}

template <>
VkVideoSessionParametersCreateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionParametersCreateInfoKHR>(
    const VkVideoSessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoSessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoSessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].videoSessionParametersTemplate = src[start_index + i].videoSessionParametersTemplate;
        ptr[i].videoSession = src[start_index + i].videoSession;
    }
    return ptr;
}

template <>
VkVideoSessionParametersUpdateInfoKHR* CommandRecorder::CopyArray<VkVideoSessionParametersUpdateInfoKHR>(
    const VkVideoSessionParametersUpdateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoSessionParametersUpdateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoSessionParametersUpdateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].updateSequenceCount = src[start_index + i].updateSequenceCount;
    }
    return ptr;
}

template <>
VkVideoBeginCodingInfoKHR* CommandRecorder::CopyArray<VkVideoBeginCodingInfoKHR>(const VkVideoBeginCodingInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoBeginCodingInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoBeginCodingInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].videoSession = src[start_index + i].videoSession;
        ptr[i].videoSessionParameters = src[start_index + i].videoSessionParameters;
        ptr[i].referenceSlotCount = src[start_index + i].referenceSlotCount;
        ptr[i].pReferenceSlots = nullptr;
        if (src[start_index + i].pReferenceSlots) {
            ptr[i].pReferenceSlots = CopyArray<>(src[start_index + i].pReferenceSlots, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoEndCodingInfoKHR* CommandRecorder::CopyArray<VkVideoEndCodingInfoKHR>(const VkVideoEndCodingInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEndCodingInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoEndCodingInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkVideoCodingControlInfoKHR* CommandRecorder::CopyArray<VkVideoCodingControlInfoKHR>(
    const VkVideoCodingControlInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoCodingControlInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoCodingControlInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkVideoDecodeCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeCapabilitiesKHR>(
    const VkVideoDecodeCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkVideoDecodeUsageInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeUsageInfoKHR>(const VkVideoDecodeUsageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoDecodeUsageInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoDecodeUsageInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoUsageHints = src[start_index + i].videoUsageHints;
    }
    return ptr;
}

template <>
VkVideoDecodeInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeInfoKHR>(const VkVideoDecodeInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoDecodeInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].srcBuffer = src[start_index + i].srcBuffer;
        ptr[i].srcBufferOffset = src[start_index + i].srcBufferOffset;
        ptr[i].srcBufferRange = src[start_index + i].srcBufferRange;
        ptr[i].dstPictureResource = src[start_index + i].dstPictureResource;
        ptr[i].pSetupReferenceSlot = src[start_index + i].pSetupReferenceSlot;
        ptr[i].referenceSlotCount = src[start_index + i].referenceSlotCount;
        ptr[i].pReferenceSlots = nullptr;
        if (src[start_index + i].pReferenceSlots) {
            ptr[i].pReferenceSlots = CopyArray<>(src[start_index + i].pReferenceSlots, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoEncodeH264CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH264CapabilitiesKHR>(
    const VkVideoEncodeH264CapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264CapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264CapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
        ptr[i].maxSliceCount = src[start_index + i].maxSliceCount;
        ptr[i].maxPPictureL0ReferenceCount = src[start_index + i].maxPPictureL0ReferenceCount;
        ptr[i].maxBPictureL0ReferenceCount = src[start_index + i].maxBPictureL0ReferenceCount;
        ptr[i].maxL1ReferenceCount = src[start_index + i].maxL1ReferenceCount;
        ptr[i].maxTemporalLayerCount = src[start_index + i].maxTemporalLayerCount;
        ptr[i].expectDyadicTemporalLayerPattern = src[start_index + i].expectDyadicTemporalLayerPattern;
        ptr[i].minQp = src[start_index + i].minQp;
        ptr[i].maxQp = src[start_index + i].maxQp;
        ptr[i].prefersGopRemainingFrames = src[start_index + i].prefersGopRemainingFrames;
        ptr[i].requiresGopRemainingFrames = src[start_index + i].requiresGopRemainingFrames;
        ptr[i].stdSyntaxFlags = src[start_index + i].stdSyntaxFlags;
    }
    return ptr;
}

template <>
VkVideoEncodeH264QpKHR* CommandRecorder::CopyArray<VkVideoEncodeH264QpKHR>(const VkVideoEncodeH264QpKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264QpKHR*>(m_allocator.Alloc(sizeof(VkVideoEncodeH264QpKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].qpI = src[start_index + i].qpI;
        ptr[i].qpP = src[start_index + i].qpP;
        ptr[i].qpB = src[start_index + i].qpB;
    }
    return ptr;
}

template <>
VkVideoEncodeH264QualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH264QualityLevelPropertiesKHR>(
    const VkVideoEncodeH264QualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264QualityLevelPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264QualityLevelPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].preferredRateControlFlags = src[start_index + i].preferredRateControlFlags;
        ptr[i].preferredGopFrameCount = src[start_index + i].preferredGopFrameCount;
        ptr[i].preferredIdrPeriod = src[start_index + i].preferredIdrPeriod;
        ptr[i].preferredConsecutiveBFrameCount = src[start_index + i].preferredConsecutiveBFrameCount;
        ptr[i].preferredTemporalLayerCount = src[start_index + i].preferredTemporalLayerCount;
        ptr[i].preferredConstantQp = src[start_index + i].preferredConstantQp;
        ptr[i].preferredMaxL0ReferenceCount = src[start_index + i].preferredMaxL0ReferenceCount;
        ptr[i].preferredMaxL1ReferenceCount = src[start_index + i].preferredMaxL1ReferenceCount;
        ptr[i].preferredStdEntropyCodingModeFlag = src[start_index + i].preferredStdEntropyCodingModeFlag;
    }
    return ptr;
}

template <>
VkVideoEncodeH264SessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionCreateInfoKHR>(
    const VkVideoEncodeH264SessionCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264SessionCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264SessionCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useMaxLevelIdc = src[start_index + i].useMaxLevelIdc;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
    }
    return ptr;
}

template <>
VkVideoEncodeH264SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersAddInfoKHR>(
    const VkVideoEncodeH264SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264SessionParametersAddInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264SessionParametersAddInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdSPSCount = src[start_index + i].stdSPSCount;
        ptr[i].pStdSPSs = nullptr;
        if (src[start_index + i].pStdSPSs) {
            ptr[i].pStdSPSs = CopyArray<>(src[start_index + i].pStdSPSs, 0, 1);
        }
        ptr[i].stdPPSCount = src[start_index + i].stdPPSCount;
        ptr[i].pStdPPSs = nullptr;
        if (src[start_index + i].pStdPPSs) {
            ptr[i].pStdPPSs = CopyArray<>(src[start_index + i].pStdPPSs, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoEncodeH264SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersCreateInfoKHR>(
    const VkVideoEncodeH264SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264SessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264SessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxStdSPSCount = src[start_index + i].maxStdSPSCount;
        ptr[i].maxStdPPSCount = src[start_index + i].maxStdPPSCount;
        ptr[i].pParametersAddInfo = src[start_index + i].pParametersAddInfo;
    }
    return ptr;
}

template <>
VkVideoEncodeH264SessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersGetInfoKHR>(
    const VkVideoEncodeH264SessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264SessionParametersGetInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264SessionParametersGetInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].writeStdSPS = src[start_index + i].writeStdSPS;
        ptr[i].writeStdPPS = src[start_index + i].writeStdPPS;
        ptr[i].stdSPSId = src[start_index + i].stdSPSId;
        ptr[i].stdPPSId = src[start_index + i].stdPPSId;
    }
    return ptr;
}

template <>
VkVideoEncodeH264SessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH264SessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeH264SessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264SessionParametersFeedbackInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264SessionParametersFeedbackInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hasStdSPSOverrides = src[start_index + i].hasStdSPSOverrides;
        ptr[i].hasStdPPSOverrides = src[start_index + i].hasStdPPSOverrides;
    }
    return ptr;
}

template <>
VkVideoEncodeH264NaluSliceInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264NaluSliceInfoKHR>(
    const VkVideoEncodeH264NaluSliceInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264NaluSliceInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264NaluSliceInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].constantQp = src[start_index + i].constantQp;
        ptr[i].pStdSliceHeader = src[start_index + i].pStdSliceHeader;
    }
    return ptr;
}

template <>
VkVideoEncodeH264PictureInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264PictureInfoKHR>(
    const VkVideoEncodeH264PictureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264PictureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264PictureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].naluSliceEntryCount = src[start_index + i].naluSliceEntryCount;
        ptr[i].pNaluSliceEntries = nullptr;
        if (src[start_index + i].pNaluSliceEntries) {
            ptr[i].pNaluSliceEntries = CopyArray<>(src[start_index + i].pNaluSliceEntries, 0, 1);
        }
        ptr[i].pStdPictureInfo = src[start_index + i].pStdPictureInfo;
        ptr[i].generatePrefixNalu = src[start_index + i].generatePrefixNalu;
    }
    return ptr;
}

template <>
VkVideoEncodeH264DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264DpbSlotInfoKHR>(
    const VkVideoEncodeH264DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264DpbSlotInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264DpbSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdReferenceInfo = src[start_index + i].pStdReferenceInfo;
    }
    return ptr;
}

template <>
VkVideoEncodeH264ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264ProfileInfoKHR>(
    const VkVideoEncodeH264ProfileInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264ProfileInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264ProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdProfileIdc = src[start_index + i].stdProfileIdc;
    }
    return ptr;
}

template <>
VkVideoEncodeH264RateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264RateControlInfoKHR>(
    const VkVideoEncodeH264RateControlInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264RateControlInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264RateControlInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].gopFrameCount = src[start_index + i].gopFrameCount;
        ptr[i].idrPeriod = src[start_index + i].idrPeriod;
        ptr[i].consecutiveBFrameCount = src[start_index + i].consecutiveBFrameCount;
        ptr[i].temporalLayerCount = src[start_index + i].temporalLayerCount;
    }
    return ptr;
}

template <>
VkVideoEncodeH264FrameSizeKHR* CommandRecorder::CopyArray<VkVideoEncodeH264FrameSizeKHR>(
    const VkVideoEncodeH264FrameSizeKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264FrameSizeKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264FrameSizeKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].frameISize = src[start_index + i].frameISize;
        ptr[i].framePSize = src[start_index + i].framePSize;
        ptr[i].frameBSize = src[start_index + i].frameBSize;
    }
    return ptr;
}

template <>
VkVideoEncodeH264RateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264RateControlLayerInfoKHR>(
    const VkVideoEncodeH264RateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264RateControlLayerInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264RateControlLayerInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useMinQp = src[start_index + i].useMinQp;
        ptr[i].minQp = src[start_index + i].minQp;
        ptr[i].useMaxQp = src[start_index + i].useMaxQp;
        ptr[i].maxQp = src[start_index + i].maxQp;
        ptr[i].useMaxFrameSize = src[start_index + i].useMaxFrameSize;
        ptr[i].maxFrameSize = src[start_index + i].maxFrameSize;
    }
    return ptr;
}

template <>
VkVideoEncodeH264GopRemainingFrameInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH264GopRemainingFrameInfoKHR>(
    const VkVideoEncodeH264GopRemainingFrameInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH264GopRemainingFrameInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH264GopRemainingFrameInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useGopRemainingFrames = src[start_index + i].useGopRemainingFrames;
        ptr[i].gopRemainingI = src[start_index + i].gopRemainingI;
        ptr[i].gopRemainingP = src[start_index + i].gopRemainingP;
        ptr[i].gopRemainingB = src[start_index + i].gopRemainingB;
    }
    return ptr;
}

template <>
VkVideoEncodeH265CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH265CapabilitiesKHR>(
    const VkVideoEncodeH265CapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265CapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265CapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
        ptr[i].maxSliceSegmentCount = src[start_index + i].maxSliceSegmentCount;
        ptr[i].maxTiles = src[start_index + i].maxTiles;
        ptr[i].ctbSizes = src[start_index + i].ctbSizes;
        ptr[i].transformBlockSizes = src[start_index + i].transformBlockSizes;
        ptr[i].maxPPictureL0ReferenceCount = src[start_index + i].maxPPictureL0ReferenceCount;
        ptr[i].maxBPictureL0ReferenceCount = src[start_index + i].maxBPictureL0ReferenceCount;
        ptr[i].maxL1ReferenceCount = src[start_index + i].maxL1ReferenceCount;
        ptr[i].maxSubLayerCount = src[start_index + i].maxSubLayerCount;
        ptr[i].expectDyadicTemporalSubLayerPattern = src[start_index + i].expectDyadicTemporalSubLayerPattern;
        ptr[i].minQp = src[start_index + i].minQp;
        ptr[i].maxQp = src[start_index + i].maxQp;
        ptr[i].prefersGopRemainingFrames = src[start_index + i].prefersGopRemainingFrames;
        ptr[i].requiresGopRemainingFrames = src[start_index + i].requiresGopRemainingFrames;
        ptr[i].stdSyntaxFlags = src[start_index + i].stdSyntaxFlags;
    }
    return ptr;
}

template <>
VkVideoEncodeH265SessionCreateInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionCreateInfoKHR>(
    const VkVideoEncodeH265SessionCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265SessionCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265SessionCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useMaxLevelIdc = src[start_index + i].useMaxLevelIdc;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
    }
    return ptr;
}

template <>
VkVideoEncodeH265QpKHR* CommandRecorder::CopyArray<VkVideoEncodeH265QpKHR>(const VkVideoEncodeH265QpKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265QpKHR*>(m_allocator.Alloc(sizeof(VkVideoEncodeH265QpKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].qpI = src[start_index + i].qpI;
        ptr[i].qpP = src[start_index + i].qpP;
        ptr[i].qpB = src[start_index + i].qpB;
    }
    return ptr;
}

template <>
VkVideoEncodeH265QualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeH265QualityLevelPropertiesKHR>(
    const VkVideoEncodeH265QualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265QualityLevelPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265QualityLevelPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].preferredRateControlFlags = src[start_index + i].preferredRateControlFlags;
        ptr[i].preferredGopFrameCount = src[start_index + i].preferredGopFrameCount;
        ptr[i].preferredIdrPeriod = src[start_index + i].preferredIdrPeriod;
        ptr[i].preferredConsecutiveBFrameCount = src[start_index + i].preferredConsecutiveBFrameCount;
        ptr[i].preferredSubLayerCount = src[start_index + i].preferredSubLayerCount;
        ptr[i].preferredConstantQp = src[start_index + i].preferredConstantQp;
        ptr[i].preferredMaxL0ReferenceCount = src[start_index + i].preferredMaxL0ReferenceCount;
        ptr[i].preferredMaxL1ReferenceCount = src[start_index + i].preferredMaxL1ReferenceCount;
    }
    return ptr;
}

template <>
VkVideoEncodeH265SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersAddInfoKHR>(
    const VkVideoEncodeH265SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265SessionParametersAddInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265SessionParametersAddInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdVPSCount = src[start_index + i].stdVPSCount;
        ptr[i].pStdVPSs = nullptr;
        if (src[start_index + i].pStdVPSs) {
            ptr[i].pStdVPSs = CopyArray<>(src[start_index + i].pStdVPSs, 0, 1);
        }
        ptr[i].stdSPSCount = src[start_index + i].stdSPSCount;
        ptr[i].pStdSPSs = nullptr;
        if (src[start_index + i].pStdSPSs) {
            ptr[i].pStdSPSs = CopyArray<>(src[start_index + i].pStdSPSs, 0, 1);
        }
        ptr[i].stdPPSCount = src[start_index + i].stdPPSCount;
        ptr[i].pStdPPSs = nullptr;
        if (src[start_index + i].pStdPPSs) {
            ptr[i].pStdPPSs = CopyArray<>(src[start_index + i].pStdPPSs, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoEncodeH265SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersCreateInfoKHR>(
    const VkVideoEncodeH265SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265SessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265SessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxStdVPSCount = src[start_index + i].maxStdVPSCount;
        ptr[i].maxStdSPSCount = src[start_index + i].maxStdSPSCount;
        ptr[i].maxStdPPSCount = src[start_index + i].maxStdPPSCount;
        ptr[i].pParametersAddInfo = src[start_index + i].pParametersAddInfo;
    }
    return ptr;
}

template <>
VkVideoEncodeH265SessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersGetInfoKHR>(
    const VkVideoEncodeH265SessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265SessionParametersGetInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265SessionParametersGetInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].writeStdVPS = src[start_index + i].writeStdVPS;
        ptr[i].writeStdSPS = src[start_index + i].writeStdSPS;
        ptr[i].writeStdPPS = src[start_index + i].writeStdPPS;
        ptr[i].stdVPSId = src[start_index + i].stdVPSId;
        ptr[i].stdSPSId = src[start_index + i].stdSPSId;
        ptr[i].stdPPSId = src[start_index + i].stdPPSId;
    }
    return ptr;
}

template <>
VkVideoEncodeH265SessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeH265SessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeH265SessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265SessionParametersFeedbackInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265SessionParametersFeedbackInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hasStdVPSOverrides = src[start_index + i].hasStdVPSOverrides;
        ptr[i].hasStdSPSOverrides = src[start_index + i].hasStdSPSOverrides;
        ptr[i].hasStdPPSOverrides = src[start_index + i].hasStdPPSOverrides;
    }
    return ptr;
}

template <>
VkVideoEncodeH265NaluSliceSegmentInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265NaluSliceSegmentInfoKHR>(
    const VkVideoEncodeH265NaluSliceSegmentInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265NaluSliceSegmentInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265NaluSliceSegmentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].constantQp = src[start_index + i].constantQp;
        ptr[i].pStdSliceSegmentHeader = src[start_index + i].pStdSliceSegmentHeader;
    }
    return ptr;
}

template <>
VkVideoEncodeH265PictureInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265PictureInfoKHR>(
    const VkVideoEncodeH265PictureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265PictureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265PictureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].naluSliceSegmentEntryCount = src[start_index + i].naluSliceSegmentEntryCount;
        ptr[i].pNaluSliceSegmentEntries = nullptr;
        if (src[start_index + i].pNaluSliceSegmentEntries) {
            ptr[i].pNaluSliceSegmentEntries = CopyArray<>(src[start_index + i].pNaluSliceSegmentEntries, 0, 1);
        }
        ptr[i].pStdPictureInfo = src[start_index + i].pStdPictureInfo;
    }
    return ptr;
}

template <>
VkVideoEncodeH265DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265DpbSlotInfoKHR>(
    const VkVideoEncodeH265DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265DpbSlotInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265DpbSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdReferenceInfo = src[start_index + i].pStdReferenceInfo;
    }
    return ptr;
}

template <>
VkVideoEncodeH265ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265ProfileInfoKHR>(
    const VkVideoEncodeH265ProfileInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265ProfileInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265ProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdProfileIdc = src[start_index + i].stdProfileIdc;
    }
    return ptr;
}

template <>
VkVideoEncodeH265RateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265RateControlInfoKHR>(
    const VkVideoEncodeH265RateControlInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265RateControlInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265RateControlInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].gopFrameCount = src[start_index + i].gopFrameCount;
        ptr[i].idrPeriod = src[start_index + i].idrPeriod;
        ptr[i].consecutiveBFrameCount = src[start_index + i].consecutiveBFrameCount;
        ptr[i].subLayerCount = src[start_index + i].subLayerCount;
    }
    return ptr;
}

template <>
VkVideoEncodeH265FrameSizeKHR* CommandRecorder::CopyArray<VkVideoEncodeH265FrameSizeKHR>(
    const VkVideoEncodeH265FrameSizeKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265FrameSizeKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265FrameSizeKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].frameISize = src[start_index + i].frameISize;
        ptr[i].framePSize = src[start_index + i].framePSize;
        ptr[i].frameBSize = src[start_index + i].frameBSize;
    }
    return ptr;
}

template <>
VkVideoEncodeH265RateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265RateControlLayerInfoKHR>(
    const VkVideoEncodeH265RateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265RateControlLayerInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265RateControlLayerInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useMinQp = src[start_index + i].useMinQp;
        ptr[i].minQp = src[start_index + i].minQp;
        ptr[i].useMaxQp = src[start_index + i].useMaxQp;
        ptr[i].maxQp = src[start_index + i].maxQp;
        ptr[i].useMaxFrameSize = src[start_index + i].useMaxFrameSize;
        ptr[i].maxFrameSize = src[start_index + i].maxFrameSize;
    }
    return ptr;
}

template <>
VkVideoEncodeH265GopRemainingFrameInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeH265GopRemainingFrameInfoKHR>(
    const VkVideoEncodeH265GopRemainingFrameInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeH265GopRemainingFrameInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeH265GopRemainingFrameInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].useGopRemainingFrames = src[start_index + i].useGopRemainingFrames;
        ptr[i].gopRemainingI = src[start_index + i].gopRemainingI;
        ptr[i].gopRemainingP = src[start_index + i].gopRemainingP;
        ptr[i].gopRemainingB = src[start_index + i].gopRemainingB;
    }
    return ptr;
}

template <>
VkVideoDecodeH264ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264ProfileInfoKHR>(
    const VkVideoDecodeH264ProfileInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264ProfileInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264ProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdProfileIdc = src[start_index + i].stdProfileIdc;
        ptr[i].pictureLayout = src[start_index + i].pictureLayout;
    }
    return ptr;
}

template <>
VkVideoDecodeH264CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeH264CapabilitiesKHR>(
    const VkVideoDecodeH264CapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264CapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264CapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
        ptr[i].fieldOffsetGranularity = src[start_index + i].fieldOffsetGranularity;
    }
    return ptr;
}

template <>
VkVideoDecodeH264SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264SessionParametersAddInfoKHR>(
    const VkVideoDecodeH264SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264SessionParametersAddInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264SessionParametersAddInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdSPSCount = src[start_index + i].stdSPSCount;
        ptr[i].pStdSPSs = nullptr;
        if (src[start_index + i].pStdSPSs) {
            ptr[i].pStdSPSs = CopyArray<>(src[start_index + i].pStdSPSs, 0, 1);
        }
        ptr[i].stdPPSCount = src[start_index + i].stdPPSCount;
        ptr[i].pStdPPSs = nullptr;
        if (src[start_index + i].pStdPPSs) {
            ptr[i].pStdPPSs = CopyArray<>(src[start_index + i].pStdPPSs, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoDecodeH264SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeH264SessionParametersCreateInfoKHR>(
    const VkVideoDecodeH264SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264SessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264SessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxStdSPSCount = src[start_index + i].maxStdSPSCount;
        ptr[i].maxStdPPSCount = src[start_index + i].maxStdPPSCount;
        ptr[i].pParametersAddInfo = src[start_index + i].pParametersAddInfo;
    }
    return ptr;
}

template <>
VkVideoDecodeH264PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264PictureInfoKHR>(
    const VkVideoDecodeH264PictureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264PictureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264PictureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdPictureInfo = src[start_index + i].pStdPictureInfo;
        ptr[i].sliceCount = src[start_index + i].sliceCount;
        ptr[i].pSliceOffsets = nullptr;
        if (src[start_index + i].pSliceOffsets) {
            ptr[i].pSliceOffsets = CopyArray<>(src[start_index + i].pSliceOffsets, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoDecodeH264DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH264DpbSlotInfoKHR>(
    const VkVideoDecodeH264DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH264DpbSlotInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH264DpbSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdReferenceInfo = src[start_index + i].pStdReferenceInfo;
    }
    return ptr;
}

template <>
VkRenderingFragmentShadingRateAttachmentInfoKHR*
CommandRecorder::CopyArray<VkRenderingFragmentShadingRateAttachmentInfoKHR>(
    const VkRenderingFragmentShadingRateAttachmentInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingFragmentShadingRateAttachmentInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRenderingFragmentShadingRateAttachmentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].imageLayout = src[start_index + i].imageLayout;
        ptr[i].shadingRateAttachmentTexelSize = src[start_index + i].shadingRateAttachmentTexelSize;
    }
    return ptr;
}

template <>
VkRenderingFragmentDensityMapAttachmentInfoEXT*
CommandRecorder::CopyArray<VkRenderingFragmentDensityMapAttachmentInfoEXT>(
    const VkRenderingFragmentDensityMapAttachmentInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingFragmentDensityMapAttachmentInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderingFragmentDensityMapAttachmentInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].imageLayout = src[start_index + i].imageLayout;
    }
    return ptr;
}

template <>
VkAttachmentSampleCountInfoAMD* CommandRecorder::CopyArray<VkAttachmentSampleCountInfoAMD>(
    const VkAttachmentSampleCountInfoAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentSampleCountInfoAMD*>(
        m_allocator.Alloc(sizeof(VkAttachmentSampleCountInfoAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentSamples = nullptr;
        if (src[start_index + i].pColorAttachmentSamples) {
            ptr[i].pColorAttachmentSamples = CopyArray<>(src[start_index + i].pColorAttachmentSamples, 0, 1);
        }
        ptr[i].depthStencilAttachmentSamples = src[start_index + i].depthStencilAttachmentSamples;
    }
    return ptr;
}

template <>
VkMultiviewPerViewAttributesInfoNVX* CommandRecorder::CopyArray<VkMultiviewPerViewAttributesInfoNVX>(
    const VkMultiviewPerViewAttributesInfoNVX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMultiviewPerViewAttributesInfoNVX*>(
        m_allocator.Alloc(sizeof(VkMultiviewPerViewAttributesInfoNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].perViewAttributes = src[start_index + i].perViewAttributes;
        ptr[i].perViewAttributesPositionXOnly = src[start_index + i].perViewAttributesPositionXOnly;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportMemoryWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportMemoryWin32HandleInfoKHR>(
    const VkImportMemoryWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkImportMemoryWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].handle = src[start_index + i].handle;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportMemoryWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportMemoryWin32HandleInfoKHR>(
    const VkExportMemoryWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMemoryWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkExportMemoryWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pAttributes = src[start_index + i].pAttributes;
        ptr[i].dwAccess = src[start_index + i].dwAccess;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkMemoryWin32HandlePropertiesKHR* CommandRecorder::CopyArray<VkMemoryWin32HandlePropertiesKHR>(
    const VkMemoryWin32HandlePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryWin32HandlePropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkMemoryWin32HandlePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkMemoryGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkMemoryGetWin32HandleInfoKHR>(
    const VkMemoryGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryGetWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkMemoryGetWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkImportMemoryFdInfoKHR* CommandRecorder::CopyArray<VkImportMemoryFdInfoKHR>(const VkImportMemoryFdInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryFdInfoKHR*>(m_allocator.Alloc(sizeof(VkImportMemoryFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].fd = src[start_index + i].fd;
    }
    return ptr;
}

template <>
VkMemoryFdPropertiesKHR* CommandRecorder::CopyArray<VkMemoryFdPropertiesKHR>(const VkMemoryFdPropertiesKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryFdPropertiesKHR*>(m_allocator.Alloc(sizeof(VkMemoryFdPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}

template <>
VkMemoryGetFdInfoKHR* CommandRecorder::CopyArray<VkMemoryGetFdInfoKHR>(const VkMemoryGetFdInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryGetFdInfoKHR*>(m_allocator.Alloc(sizeof(VkMemoryGetFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32KeyedMutexAcquireReleaseInfoKHR* CommandRecorder::CopyArray<VkWin32KeyedMutexAcquireReleaseInfoKHR>(
    const VkWin32KeyedMutexAcquireReleaseInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>(
        m_allocator.Alloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].acquireCount = src[start_index + i].acquireCount;
        ptr[i].pAcquireSyncs = nullptr;
        if (src[start_index + i].pAcquireSyncs) {
            ptr[i].pAcquireSyncs = CopyArray<>(src[start_index + i].pAcquireSyncs, 0, 1);
        }
        ptr[i].pAcquireKeys = nullptr;
        if (src[start_index + i].pAcquireKeys) {
            ptr[i].pAcquireKeys = CopyArray<>(src[start_index + i].pAcquireKeys, 0, 1);
        }
        ptr[i].pAcquireTimeouts = nullptr;
        if (src[start_index + i].pAcquireTimeouts) {
            ptr[i].pAcquireTimeouts = CopyArray<>(src[start_index + i].pAcquireTimeouts, 0, 1);
        }
        ptr[i].releaseCount = src[start_index + i].releaseCount;
        ptr[i].pReleaseSyncs = nullptr;
        if (src[start_index + i].pReleaseSyncs) {
            ptr[i].pReleaseSyncs = CopyArray<>(src[start_index + i].pReleaseSyncs, 0, 1);
        }
        ptr[i].pReleaseKeys = nullptr;
        if (src[start_index + i].pReleaseKeys) {
            ptr[i].pReleaseKeys = CopyArray<>(src[start_index + i].pReleaseKeys, 0, 1);
        }
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportSemaphoreWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportSemaphoreWin32HandleInfoKHR>(
    const VkImportSemaphoreWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportSemaphoreWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkImportSemaphoreWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].handle = src[start_index + i].handle;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportSemaphoreWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportSemaphoreWin32HandleInfoKHR>(
    const VkExportSemaphoreWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportSemaphoreWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkExportSemaphoreWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pAttributes = src[start_index + i].pAttributes;
        ptr[i].dwAccess = src[start_index + i].dwAccess;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkD3D12FenceSubmitInfoKHR* CommandRecorder::CopyArray<VkD3D12FenceSubmitInfoKHR>(const VkD3D12FenceSubmitInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkD3D12FenceSubmitInfoKHR*>(m_allocator.Alloc(sizeof(VkD3D12FenceSubmitInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].waitSemaphoreValuesCount = src[start_index + i].waitSemaphoreValuesCount;
        ptr[i].pWaitSemaphoreValues = nullptr;
        if (src[start_index + i].pWaitSemaphoreValues) {
            ptr[i].pWaitSemaphoreValues = CopyArray<>(src[start_index + i].pWaitSemaphoreValues, 0, 1);
        }
        ptr[i].signalSemaphoreValuesCount = src[start_index + i].signalSemaphoreValuesCount;
        ptr[i].pSignalSemaphoreValues = nullptr;
        if (src[start_index + i].pSignalSemaphoreValues) {
            ptr[i].pSignalSemaphoreValues = CopyArray<>(src[start_index + i].pSignalSemaphoreValues, 0, 1);
        }
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSemaphoreGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkSemaphoreGetWin32HandleInfoKHR>(
    const VkSemaphoreGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreGetWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkSemaphoreGetWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkImportSemaphoreFdInfoKHR* CommandRecorder::CopyArray<VkImportSemaphoreFdInfoKHR>(
    const VkImportSemaphoreFdInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImportSemaphoreFdInfoKHR*>(m_allocator.Alloc(sizeof(VkImportSemaphoreFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].fd = src[start_index + i].fd;
    }
    return ptr;
}

template <>
VkSemaphoreGetFdInfoKHR* CommandRecorder::CopyArray<VkSemaphoreGetFdInfoKHR>(const VkSemaphoreGetFdInfoKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreGetFdInfoKHR*>(m_allocator.Alloc(sizeof(VkSemaphoreGetFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkPhysicalDevicePushDescriptorPropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePushDescriptorPropertiesKHR>(
    const VkPhysicalDevicePushDescriptorPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxPushDescriptors = src[start_index + i].maxPushDescriptors;
    }
    return ptr;
}

template <>
VkRectLayerKHR* CommandRecorder::CopyArray<VkRectLayerKHR>(const VkRectLayerKHR* src, uint64_t start_index,
                                                           uint64_t count) {
    auto ptr = reinterpret_cast<VkRectLayerKHR*>(m_allocator.Alloc(sizeof(VkRectLayerKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].extent = src[start_index + i].extent;
        ptr[i].layer = src[start_index + i].layer;
    }
    return ptr;
}

template <>
VkPresentRegionKHR* CommandRecorder::CopyArray<VkPresentRegionKHR>(const VkPresentRegionKHR* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentRegionKHR*>(m_allocator.Alloc(sizeof(VkPresentRegionKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].rectangleCount = src[start_index + i].rectangleCount;
        ptr[i].pRectangles = nullptr;
        if (src[start_index + i].pRectangles) {
            ptr[i].pRectangles = CopyArray<>(src[start_index + i].pRectangles, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPresentRegionsKHR* CommandRecorder::CopyArray<VkPresentRegionsKHR>(const VkPresentRegionsKHR* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentRegionsKHR*>(m_allocator.Alloc(sizeof(VkPresentRegionsKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSharedPresentSurfaceCapabilitiesKHR* CommandRecorder::CopyArray<VkSharedPresentSurfaceCapabilitiesKHR>(
    const VkSharedPresentSurfaceCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkSharedPresentSurfaceCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sharedPresentSupportedUsageFlags = src[start_index + i].sharedPresentSupportedUsageFlags;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportFenceWin32HandleInfoKHR* CommandRecorder::CopyArray<VkImportFenceWin32HandleInfoKHR>(
    const VkImportFenceWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportFenceWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkImportFenceWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fence = src[start_index + i].fence;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].handle = src[start_index + i].handle;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportFenceWin32HandleInfoKHR* CommandRecorder::CopyArray<VkExportFenceWin32HandleInfoKHR>(
    const VkExportFenceWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportFenceWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkExportFenceWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pAttributes = src[start_index + i].pAttributes;
        ptr[i].dwAccess = src[start_index + i].dwAccess;
        ptr[i].name = src[start_index + i].name;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkFenceGetWin32HandleInfoKHR* CommandRecorder::CopyArray<VkFenceGetWin32HandleInfoKHR>(
    const VkFenceGetWin32HandleInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFenceGetWin32HandleInfoKHR*>(
        m_allocator.Alloc(sizeof(VkFenceGetWin32HandleInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fence = src[start_index + i].fence;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkImportFenceFdInfoKHR* CommandRecorder::CopyArray<VkImportFenceFdInfoKHR>(const VkImportFenceFdInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportFenceFdInfoKHR*>(m_allocator.Alloc(sizeof(VkImportFenceFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fence = src[start_index + i].fence;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].fd = src[start_index + i].fd;
    }
    return ptr;
}

template <>
VkFenceGetFdInfoKHR* CommandRecorder::CopyArray<VkFenceGetFdInfoKHR>(const VkFenceGetFdInfoKHR* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFenceGetFdInfoKHR*>(m_allocator.Alloc(sizeof(VkFenceGetFdInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fence = src[start_index + i].fence;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkPhysicalDevicePerformanceQueryFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryFeaturesKHR>(
    const VkPhysicalDevicePerformanceQueryFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].performanceCounterQueryPools = src[start_index + i].performanceCounterQueryPools;
        ptr[i].performanceCounterMultipleQueryPools = src[start_index + i].performanceCounterMultipleQueryPools;
    }
    return ptr;
}

template <>
VkPhysicalDevicePerformanceQueryPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryPropertiesKHR>(
    const VkPhysicalDevicePerformanceQueryPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].allowCommandBufferQueryCopies = src[start_index + i].allowCommandBufferQueryCopies;
    }
    return ptr;
}

template <>
VkPerformanceCounterKHR* CommandRecorder::CopyArray<VkPerformanceCounterKHR>(const VkPerformanceCounterKHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceCounterKHR*>(m_allocator.Alloc(sizeof(VkPerformanceCounterKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].unit = src[start_index + i].unit;
        ptr[i].scope = src[start_index + i].scope;
        ptr[i].storage = src[start_index + i].storage;
        std::memcpy(ptr[i].uuid, src[start_index + i].uuid, sizeof(src[start_index + i].uuid));
    }
    return ptr;
}

template <>
VkPerformanceCounterDescriptionKHR* CommandRecorder::CopyArray<VkPerformanceCounterDescriptionKHR>(
    const VkPerformanceCounterDescriptionKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceCounterDescriptionKHR*>(
        m_allocator.Alloc(sizeof(VkPerformanceCounterDescriptionKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
        std::memcpy(ptr[i].category, src[start_index + i].category, sizeof(src[start_index + i].category));
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
    }
    return ptr;
}

template <>
VkQueryPoolPerformanceCreateInfoKHR* CommandRecorder::CopyArray<VkQueryPoolPerformanceCreateInfoKHR>(
    const VkQueryPoolPerformanceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkQueryPoolPerformanceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
        ptr[i].counterIndexCount = src[start_index + i].counterIndexCount;
        ptr[i].pCounterIndices = nullptr;
        if (src[start_index + i].pCounterIndices) {
            ptr[i].pCounterIndices = CopyArray<>(src[start_index + i].pCounterIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPerformanceCounterResultKHR* CommandRecorder::CopyArray<VkPerformanceCounterResultKHR>(
    const VkPerformanceCounterResultKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceCounterResultKHR*>(
        m_allocator.Alloc(sizeof(VkPerformanceCounterResultKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].int32 = src[start_index + i].int32;
        ptr[i].int64 = src[start_index + i].int64;
        ptr[i].uint32 = src[start_index + i].uint32;
        ptr[i].uint64 = src[start_index + i].uint64;
        ptr[i].float32 = src[start_index + i].float32;
        ptr[i].float64 = src[start_index + i].float64;
    }
    return ptr;
}

template <>
VkAcquireProfilingLockInfoKHR* CommandRecorder::CopyArray<VkAcquireProfilingLockInfoKHR>(
    const VkAcquireProfilingLockInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAcquireProfilingLockInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAcquireProfilingLockInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].timeout = src[start_index + i].timeout;
    }
    return ptr;
}

template <>
VkPerformanceQuerySubmitInfoKHR* CommandRecorder::CopyArray<VkPerformanceQuerySubmitInfoKHR>(
    const VkPerformanceQuerySubmitInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceQuerySubmitInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPerformanceQuerySubmitInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].counterPassIndex = src[start_index + i].counterPassIndex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSurfaceInfo2KHR* CommandRecorder::CopyArray<VkPhysicalDeviceSurfaceInfo2KHR>(
    const VkPhysicalDeviceSurfaceInfo2KHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSurfaceInfo2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].surface = src[start_index + i].surface;
    }
    return ptr;
}

template <>
VkSurfaceCapabilities2KHR* CommandRecorder::CopyArray<VkSurfaceCapabilities2KHR>(const VkSurfaceCapabilities2KHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSurfaceCapabilities2KHR*>(m_allocator.Alloc(sizeof(VkSurfaceCapabilities2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].surfaceCapabilities = src[start_index + i].surfaceCapabilities;
    }
    return ptr;
}

template <>
VkSurfaceFormat2KHR* CommandRecorder::CopyArray<VkSurfaceFormat2KHR>(const VkSurfaceFormat2KHR* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceFormat2KHR*>(m_allocator.Alloc(sizeof(VkSurfaceFormat2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].surfaceFormat = src[start_index + i].surfaceFormat;
    }
    return ptr;
}

template <>
VkDisplayProperties2KHR* CommandRecorder::CopyArray<VkDisplayProperties2KHR>(const VkDisplayProperties2KHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayProperties2KHR*>(m_allocator.Alloc(sizeof(VkDisplayProperties2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displayProperties = src[start_index + i].displayProperties;
    }
    return ptr;
}

template <>
VkDisplayPlaneProperties2KHR* CommandRecorder::CopyArray<VkDisplayPlaneProperties2KHR>(
    const VkDisplayPlaneProperties2KHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPlaneProperties2KHR*>(
        m_allocator.Alloc(sizeof(VkDisplayPlaneProperties2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displayPlaneProperties = src[start_index + i].displayPlaneProperties;
    }
    return ptr;
}

template <>
VkDisplayModeProperties2KHR* CommandRecorder::CopyArray<VkDisplayModeProperties2KHR>(
    const VkDisplayModeProperties2KHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDisplayModeProperties2KHR*>(m_allocator.Alloc(sizeof(VkDisplayModeProperties2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displayModeProperties = src[start_index + i].displayModeProperties;
    }
    return ptr;
}

template <>
VkDisplayPlaneInfo2KHR* CommandRecorder::CopyArray<VkDisplayPlaneInfo2KHR>(const VkDisplayPlaneInfo2KHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPlaneInfo2KHR*>(m_allocator.Alloc(sizeof(VkDisplayPlaneInfo2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mode = src[start_index + i].mode;
        ptr[i].planeIndex = src[start_index + i].planeIndex;
    }
    return ptr;
}

template <>
VkDisplayPlaneCapabilities2KHR* CommandRecorder::CopyArray<VkDisplayPlaneCapabilities2KHR>(
    const VkDisplayPlaneCapabilities2KHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPlaneCapabilities2KHR*>(
        m_allocator.Alloc(sizeof(VkDisplayPlaneCapabilities2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].capabilities = src[start_index + i].capabilities;
    }
    return ptr;
}

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDevicePortabilitySubsetFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePortabilitySubsetFeaturesKHR>(
    const VkPhysicalDevicePortabilitySubsetFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePortabilitySubsetFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].constantAlphaColorBlendFactors = src[start_index + i].constantAlphaColorBlendFactors;
        ptr[i].events = src[start_index + i].events;
        ptr[i].imageViewFormatReinterpretation = src[start_index + i].imageViewFormatReinterpretation;
        ptr[i].imageViewFormatSwizzle = src[start_index + i].imageViewFormatSwizzle;
        ptr[i].imageView2DOn3DImage = src[start_index + i].imageView2DOn3DImage;
        ptr[i].multisampleArrayImage = src[start_index + i].multisampleArrayImage;
        ptr[i].mutableComparisonSamplers = src[start_index + i].mutableComparisonSamplers;
        ptr[i].pointPolygons = src[start_index + i].pointPolygons;
        ptr[i].samplerMipLodBias = src[start_index + i].samplerMipLodBias;
        ptr[i].separateStencilMaskRef = src[start_index + i].separateStencilMaskRef;
        ptr[i].shaderSampleRateInterpolationFunctions = src[start_index + i].shaderSampleRateInterpolationFunctions;
        ptr[i].tessellationIsolines = src[start_index + i].tessellationIsolines;
        ptr[i].tessellationPointMode = src[start_index + i].tessellationPointMode;
        ptr[i].triangleFans = src[start_index + i].triangleFans;
        ptr[i].vertexAttributeAccessBeyondStride = src[start_index + i].vertexAttributeAccessBeyondStride;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDevicePortabilitySubsetPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePortabilitySubsetPropertiesKHR>(
    const VkPhysicalDevicePortabilitySubsetPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePortabilitySubsetPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePortabilitySubsetPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minVertexInputBindingStrideAlignment = src[start_index + i].minVertexInputBindingStrideAlignment;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

template <>
VkPhysicalDeviceShaderClockFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceShaderClockFeaturesKHR>(
    const VkPhysicalDeviceShaderClockFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderClockFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSubgroupClock = src[start_index + i].shaderSubgroupClock;
        ptr[i].shaderDeviceClock = src[start_index + i].shaderDeviceClock;
    }
    return ptr;
}

template <>
VkVideoDecodeH265ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265ProfileInfoKHR>(
    const VkVideoDecodeH265ProfileInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265ProfileInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265ProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdProfileIdc = src[start_index + i].stdProfileIdc;
    }
    return ptr;
}

template <>
VkVideoDecodeH265CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeH265CapabilitiesKHR>(
    const VkVideoDecodeH265CapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265CapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265CapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxLevelIdc = src[start_index + i].maxLevelIdc;
    }
    return ptr;
}

template <>
VkVideoDecodeH265SessionParametersAddInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265SessionParametersAddInfoKHR>(
    const VkVideoDecodeH265SessionParametersAddInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265SessionParametersAddInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265SessionParametersAddInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdVPSCount = src[start_index + i].stdVPSCount;
        ptr[i].pStdVPSs = nullptr;
        if (src[start_index + i].pStdVPSs) {
            ptr[i].pStdVPSs = CopyArray<>(src[start_index + i].pStdVPSs, 0, 1);
        }
        ptr[i].stdSPSCount = src[start_index + i].stdSPSCount;
        ptr[i].pStdSPSs = nullptr;
        if (src[start_index + i].pStdSPSs) {
            ptr[i].pStdSPSs = CopyArray<>(src[start_index + i].pStdSPSs, 0, 1);
        }
        ptr[i].stdPPSCount = src[start_index + i].stdPPSCount;
        ptr[i].pStdPPSs = nullptr;
        if (src[start_index + i].pStdPPSs) {
            ptr[i].pStdPPSs = CopyArray<>(src[start_index + i].pStdPPSs, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoDecodeH265SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeH265SessionParametersCreateInfoKHR>(
    const VkVideoDecodeH265SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265SessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265SessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxStdVPSCount = src[start_index + i].maxStdVPSCount;
        ptr[i].maxStdSPSCount = src[start_index + i].maxStdSPSCount;
        ptr[i].maxStdPPSCount = src[start_index + i].maxStdPPSCount;
        ptr[i].pParametersAddInfo = src[start_index + i].pParametersAddInfo;
    }
    return ptr;
}

template <>
VkVideoDecodeH265PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265PictureInfoKHR>(
    const VkVideoDecodeH265PictureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265PictureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265PictureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdPictureInfo = src[start_index + i].pStdPictureInfo;
        ptr[i].sliceSegmentCount = src[start_index + i].sliceSegmentCount;
        ptr[i].pSliceSegmentOffsets = nullptr;
        if (src[start_index + i].pSliceSegmentOffsets) {
            ptr[i].pSliceSegmentOffsets = CopyArray<>(src[start_index + i].pSliceSegmentOffsets, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoDecodeH265DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeH265DpbSlotInfoKHR>(
    const VkVideoDecodeH265DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeH265DpbSlotInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeH265DpbSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdReferenceInfo = src[start_index + i].pStdReferenceInfo;
    }
    return ptr;
}

template <>
VkDeviceQueueGlobalPriorityCreateInfoKHR* CommandRecorder::CopyArray<VkDeviceQueueGlobalPriorityCreateInfoKHR>(
    const VkDeviceQueueGlobalPriorityCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkDeviceQueueGlobalPriorityCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].globalPriority = src[start_index + i].globalPriority;
    }
    return ptr;
}

template <>
VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>(
    const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].globalPriorityQuery = src[start_index + i].globalPriorityQuery;
    }
    return ptr;
}

template <>
VkQueueFamilyGlobalPriorityPropertiesKHR* CommandRecorder::CopyArray<VkQueueFamilyGlobalPriorityPropertiesKHR>(
    const VkQueueFamilyGlobalPriorityPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkQueueFamilyGlobalPriorityPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].priorityCount = src[start_index + i].priorityCount;
        std::memcpy(ptr[i].priorities, src[start_index + i].priorities, sizeof(src[start_index + i].priorities));
    }
    return ptr;
}

template <>
VkFragmentShadingRateAttachmentInfoKHR* CommandRecorder::CopyArray<VkFragmentShadingRateAttachmentInfoKHR>(
    const VkFragmentShadingRateAttachmentInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR*>(
        m_allocator.Alloc(sizeof(VkFragmentShadingRateAttachmentInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pFragmentShadingRateAttachment = src[start_index + i].pFragmentShadingRateAttachment;
        ptr[i].shadingRateAttachmentTexelSize = src[start_index + i].shadingRateAttachmentTexelSize;
    }
    return ptr;
}

template <>
VkPipelineFragmentShadingRateStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineFragmentShadingRateStateCreateInfoKHR>(
    const VkPipelineFragmentShadingRateStateCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentSize = src[start_index + i].fragmentSize;
        std::memcpy(ptr[i].combinerOps, src[start_index + i].combinerOps, sizeof(src[start_index + i].combinerOps));
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShadingRateFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(
    const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineFragmentShadingRate = src[start_index + i].pipelineFragmentShadingRate;
        ptr[i].primitiveFragmentShadingRate = src[start_index + i].primitiveFragmentShadingRate;
        ptr[i].attachmentFragmentShadingRate = src[start_index + i].attachmentFragmentShadingRate;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShadingRatePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(
    const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minFragmentShadingRateAttachmentTexelSize =
            src[start_index + i].minFragmentShadingRateAttachmentTexelSize;
        ptr[i].maxFragmentShadingRateAttachmentTexelSize =
            src[start_index + i].maxFragmentShadingRateAttachmentTexelSize;
        ptr[i].maxFragmentShadingRateAttachmentTexelSizeAspectRatio =
            src[start_index + i].maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
        ptr[i].primitiveFragmentShadingRateWithMultipleViewports =
            src[start_index + i].primitiveFragmentShadingRateWithMultipleViewports;
        ptr[i].layeredShadingRateAttachments = src[start_index + i].layeredShadingRateAttachments;
        ptr[i].fragmentShadingRateNonTrivialCombinerOps = src[start_index + i].fragmentShadingRateNonTrivialCombinerOps;
        ptr[i].maxFragmentSize = src[start_index + i].maxFragmentSize;
        ptr[i].maxFragmentSizeAspectRatio = src[start_index + i].maxFragmentSizeAspectRatio;
        ptr[i].maxFragmentShadingRateCoverageSamples = src[start_index + i].maxFragmentShadingRateCoverageSamples;
        ptr[i].maxFragmentShadingRateRasterizationSamples =
            src[start_index + i].maxFragmentShadingRateRasterizationSamples;
        ptr[i].fragmentShadingRateWithShaderDepthStencilWrites =
            src[start_index + i].fragmentShadingRateWithShaderDepthStencilWrites;
        ptr[i].fragmentShadingRateWithSampleMask = src[start_index + i].fragmentShadingRateWithSampleMask;
        ptr[i].fragmentShadingRateWithShaderSampleMask = src[start_index + i].fragmentShadingRateWithShaderSampleMask;
        ptr[i].fragmentShadingRateWithConservativeRasterization =
            src[start_index + i].fragmentShadingRateWithConservativeRasterization;
        ptr[i].fragmentShadingRateWithFragmentShaderInterlock =
            src[start_index + i].fragmentShadingRateWithFragmentShaderInterlock;
        ptr[i].fragmentShadingRateWithCustomSampleLocations =
            src[start_index + i].fragmentShadingRateWithCustomSampleLocations;
        ptr[i].fragmentShadingRateStrictMultiplyCombiner =
            src[start_index + i].fragmentShadingRateStrictMultiplyCombiner;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShadingRateKHR* CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateKHR>(
    const VkPhysicalDeviceFragmentShadingRateKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampleCounts = src[start_index + i].sampleCounts;
        ptr[i].fragmentSize = src[start_index + i].fragmentSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR>(
    const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dynamicRenderingLocalRead = src[start_index + i].dynamicRenderingLocalRead;
    }
    return ptr;
}

template <>
VkRenderingAttachmentLocationInfoKHR* CommandRecorder::CopyArray<VkRenderingAttachmentLocationInfoKHR>(
    const VkRenderingAttachmentLocationInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingAttachmentLocationInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRenderingAttachmentLocationInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentLocations = nullptr;
        if (src[start_index + i].pColorAttachmentLocations) {
            ptr[i].pColorAttachmentLocations = CopyArray<>(src[start_index + i].pColorAttachmentLocations, 0, 1);
        }
    }
    return ptr;
}

template <>
VkRenderingInputAttachmentIndexInfoKHR* CommandRecorder::CopyArray<VkRenderingInputAttachmentIndexInfoKHR>(
    const VkRenderingInputAttachmentIndexInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingInputAttachmentIndexInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRenderingInputAttachmentIndexInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentInputIndices = nullptr;
        if (src[start_index + i].pColorAttachmentInputIndices) {
            ptr[i].pColorAttachmentInputIndices = CopyArray<>(src[start_index + i].pColorAttachmentInputIndices, 0, 1);
        }
        ptr[i].pDepthInputAttachmentIndex = src[start_index + i].pDepthInputAttachmentIndex;
        ptr[i].pStencilInputAttachmentIndex = src[start_index + i].pStencilInputAttachmentIndex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderQuadControlFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceShaderQuadControlFeaturesKHR>(
    const VkPhysicalDeviceShaderQuadControlFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderQuadControlFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderQuadControlFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderQuadControl = src[start_index + i].shaderQuadControl;
    }
    return ptr;
}

template <>
VkSurfaceProtectedCapabilitiesKHR* CommandRecorder::CopyArray<VkSurfaceProtectedCapabilitiesKHR>(
    const VkSurfaceProtectedCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkSurfaceProtectedCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportsProtected = src[start_index + i].supportsProtected;
    }
    return ptr;
}

template <>
VkPhysicalDevicePresentWaitFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePresentWaitFeaturesKHR>(
    const VkPhysicalDevicePresentWaitFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePresentWaitFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePresentWaitFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentWait = src[start_index + i].presentWait;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(
    const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineExecutableInfo = src[start_index + i].pipelineExecutableInfo;
    }
    return ptr;
}

template <>
VkPipelineInfoKHR* CommandRecorder::CopyArray<VkPipelineInfoKHR>(const VkPipelineInfoKHR* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineInfoKHR*>(m_allocator.Alloc(sizeof(VkPipelineInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipeline = src[start_index + i].pipeline;
    }
    return ptr;
}

template <>
VkPipelineExecutablePropertiesKHR* CommandRecorder::CopyArray<VkPipelineExecutablePropertiesKHR>(
    const VkPipelineExecutablePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineExecutablePropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineExecutablePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stages = src[start_index + i].stages;
        std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].subgroupSize = src[start_index + i].subgroupSize;
    }
    return ptr;
}

template <>
VkPipelineExecutableInfoKHR* CommandRecorder::CopyArray<VkPipelineExecutableInfoKHR>(
    const VkPipelineExecutableInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPipelineExecutableInfoKHR*>(m_allocator.Alloc(sizeof(VkPipelineExecutableInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipeline = src[start_index + i].pipeline;
        ptr[i].executableIndex = src[start_index + i].executableIndex;
    }
    return ptr;
}

template <>
VkPipelineExecutableStatisticValueKHR* CommandRecorder::CopyArray<VkPipelineExecutableStatisticValueKHR>(
    const VkPipelineExecutableStatisticValueKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineExecutableStatisticValueKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineExecutableStatisticValueKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].b32 = src[start_index + i].b32;
        ptr[i].i64 = src[start_index + i].i64;
        ptr[i].u64 = src[start_index + i].u64;
        ptr[i].f64 = src[start_index + i].f64;
    }
    return ptr;
}

template <>
VkPipelineExecutableStatisticKHR* CommandRecorder::CopyArray<VkPipelineExecutableStatisticKHR>(
    const VkPipelineExecutableStatisticKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineExecutableStatisticKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineExecutableStatisticKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].format = src[start_index + i].format;
        ptr[i].value = src[start_index + i].value;
    }
    return ptr;
}

template <>
VkPipelineExecutableInternalRepresentationKHR*
CommandRecorder::CopyArray<VkPipelineExecutableInternalRepresentationKHR>(
    const VkPipelineExecutableInternalRepresentationKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineExecutableInternalRepresentationKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineExecutableInternalRepresentationKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].isText = src[start_index + i].isText;
        ptr[i].dataSize = src[start_index + i].dataSize;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkMemoryMapInfoKHR* CommandRecorder::CopyArray<VkMemoryMapInfoKHR>(const VkMemoryMapInfoKHR* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryMapInfoKHR*>(m_allocator.Alloc(sizeof(VkMemoryMapInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkMemoryUnmapInfoKHR* CommandRecorder::CopyArray<VkMemoryUnmapInfoKHR>(const VkMemoryUnmapInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryUnmapInfoKHR*>(m_allocator.Alloc(sizeof(VkMemoryUnmapInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].memory = src[start_index + i].memory;
    }
    return ptr;
}

template <>
VkPipelineLibraryCreateInfoKHR* CommandRecorder::CopyArray<VkPipelineLibraryCreateInfoKHR>(
    const VkPipelineLibraryCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineLibraryCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineLibraryCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].libraryCount = src[start_index + i].libraryCount;
        ptr[i].pLibraries = nullptr;
        if (src[start_index + i].pLibraries) {
            ptr[i].pLibraries = CopyArray<>(src[start_index + i].pLibraries, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPresentIdKHR* CommandRecorder::CopyArray<VkPresentIdKHR>(const VkPresentIdKHR* src, uint64_t start_index,
                                                           uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentIdKHR*>(m_allocator.Alloc(sizeof(VkPresentIdKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pPresentIds = nullptr;
        if (src[start_index + i].pPresentIds) {
            ptr[i].pPresentIds = CopyArray<>(src[start_index + i].pPresentIds, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDevicePresentIdFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDevicePresentIdFeaturesKHR>(
    const VkPhysicalDevicePresentIdFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePresentIdFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePresentIdFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentId = src[start_index + i].presentId;
    }
    return ptr;
}

template <>
VkVideoEncodeInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeInfoKHR>(const VkVideoEncodeInfoKHR* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoEncodeInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].dstBuffer = src[start_index + i].dstBuffer;
        ptr[i].dstBufferOffset = src[start_index + i].dstBufferOffset;
        ptr[i].dstBufferRange = src[start_index + i].dstBufferRange;
        ptr[i].srcPictureResource = src[start_index + i].srcPictureResource;
        ptr[i].pSetupReferenceSlot = src[start_index + i].pSetupReferenceSlot;
        ptr[i].referenceSlotCount = src[start_index + i].referenceSlotCount;
        ptr[i].pReferenceSlots = nullptr;
        if (src[start_index + i].pReferenceSlots) {
            ptr[i].pReferenceSlots = CopyArray<>(src[start_index + i].pReferenceSlots, 0, 1);
        }
        ptr[i].precedingExternallyEncodedBytes = src[start_index + i].precedingExternallyEncodedBytes;
    }
    return ptr;
}

template <>
VkVideoEncodeCapabilitiesKHR* CommandRecorder::CopyArray<VkVideoEncodeCapabilitiesKHR>(
    const VkVideoEncodeCapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeCapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeCapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].rateControlModes = src[start_index + i].rateControlModes;
        ptr[i].maxRateControlLayers = src[start_index + i].maxRateControlLayers;
        ptr[i].maxBitrate = src[start_index + i].maxBitrate;
        ptr[i].maxQualityLevels = src[start_index + i].maxQualityLevels;
        ptr[i].encodeInputPictureGranularity = src[start_index + i].encodeInputPictureGranularity;
        ptr[i].supportedEncodeFeedbackFlags = src[start_index + i].supportedEncodeFeedbackFlags;
    }
    return ptr;
}

template <>
VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* CommandRecorder::CopyArray<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>(
    const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkQueryPoolVideoEncodeFeedbackCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].encodeFeedbackFlags = src[start_index + i].encodeFeedbackFlags;
    }
    return ptr;
}

template <>
VkVideoEncodeUsageInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeUsageInfoKHR>(const VkVideoEncodeUsageInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoEncodeUsageInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoEncodeUsageInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoUsageHints = src[start_index + i].videoUsageHints;
        ptr[i].videoContentHints = src[start_index + i].videoContentHints;
        ptr[i].tuningMode = src[start_index + i].tuningMode;
    }
    return ptr;
}

template <>
VkVideoEncodeRateControlLayerInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeRateControlLayerInfoKHR>(
    const VkVideoEncodeRateControlLayerInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeRateControlLayerInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeRateControlLayerInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].averageBitrate = src[start_index + i].averageBitrate;
        ptr[i].maxBitrate = src[start_index + i].maxBitrate;
        ptr[i].frameRateNumerator = src[start_index + i].frameRateNumerator;
        ptr[i].frameRateDenominator = src[start_index + i].frameRateDenominator;
    }
    return ptr;
}

template <>
VkVideoEncodeRateControlInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeRateControlInfoKHR>(
    const VkVideoEncodeRateControlInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeRateControlInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeRateControlInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].rateControlMode = src[start_index + i].rateControlMode;
        ptr[i].layerCount = src[start_index + i].layerCount;
        ptr[i].pLayers = nullptr;
        if (src[start_index + i].pLayers) {
            ptr[i].pLayers = CopyArray<>(src[start_index + i].pLayers, 0, 1);
        }
        ptr[i].virtualBufferSizeInMs = src[start_index + i].virtualBufferSizeInMs;
        ptr[i].initialVirtualBufferSizeInMs = src[start_index + i].initialVirtualBufferSizeInMs;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>(
    const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pVideoProfile = src[start_index + i].pVideoProfile;
        ptr[i].qualityLevel = src[start_index + i].qualityLevel;
    }
    return ptr;
}

template <>
VkVideoEncodeQualityLevelPropertiesKHR* CommandRecorder::CopyArray<VkVideoEncodeQualityLevelPropertiesKHR>(
    const VkVideoEncodeQualityLevelPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeQualityLevelPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeQualityLevelPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].preferredRateControlMode = src[start_index + i].preferredRateControlMode;
        ptr[i].preferredRateControlLayerCount = src[start_index + i].preferredRateControlLayerCount;
    }
    return ptr;
}

template <>
VkVideoEncodeQualityLevelInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeQualityLevelInfoKHR>(
    const VkVideoEncodeQualityLevelInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeQualityLevelInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeQualityLevelInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].qualityLevel = src[start_index + i].qualityLevel;
    }
    return ptr;
}

template <>
VkVideoEncodeSessionParametersGetInfoKHR* CommandRecorder::CopyArray<VkVideoEncodeSessionParametersGetInfoKHR>(
    const VkVideoEncodeSessionParametersGetInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeSessionParametersGetInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeSessionParametersGetInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoSessionParameters = src[start_index + i].videoSessionParameters;
    }
    return ptr;
}

template <>
VkVideoEncodeSessionParametersFeedbackInfoKHR*
CommandRecorder::CopyArray<VkVideoEncodeSessionParametersFeedbackInfoKHR>(
    const VkVideoEncodeSessionParametersFeedbackInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoEncodeSessionParametersFeedbackInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoEncodeSessionParametersFeedbackInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hasOverrides = src[start_index + i].hasOverrides;
    }
    return ptr;
}

template <>
VkQueueFamilyCheckpointProperties2NV* CommandRecorder::CopyArray<VkQueueFamilyCheckpointProperties2NV>(
    const VkQueueFamilyCheckpointProperties2NV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyCheckpointProperties2NV*>(
        m_allocator.Alloc(sizeof(VkQueueFamilyCheckpointProperties2NV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].checkpointExecutionStageMask = src[start_index + i].checkpointExecutionStageMask;
    }
    return ptr;
}

template <>
VkCheckpointData2NV* CommandRecorder::CopyArray<VkCheckpointData2NV>(const VkCheckpointData2NV* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCheckpointData2NV*>(m_allocator.Alloc(sizeof(VkCheckpointData2NV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stage = src[start_index + i].stage;
        ptr[i].pCheckpointMarker = src[start_index + i].pCheckpointMarker;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>(
    const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentShaderBarycentric = src[start_index + i].fragmentShaderBarycentric;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>(
    const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].triStripVertexOrderIndependentOfProvokingVertex =
            src[start_index + i].triStripVertexOrderIndependentOfProvokingVertex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(
    const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSubgroupUniformControlFlow = src[start_index + i].shaderSubgroupUniformControlFlow;
    }
    return ptr;
}

template <>
VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(
    const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].workgroupMemoryExplicitLayout = src[start_index + i].workgroupMemoryExplicitLayout;
        ptr[i].workgroupMemoryExplicitLayoutScalarBlockLayout =
            src[start_index + i].workgroupMemoryExplicitLayoutScalarBlockLayout;
        ptr[i].workgroupMemoryExplicitLayout8BitAccess = src[start_index + i].workgroupMemoryExplicitLayout8BitAccess;
        ptr[i].workgroupMemoryExplicitLayout16BitAccess = src[start_index + i].workgroupMemoryExplicitLayout16BitAccess;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>(
    const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingMaintenance1 = src[start_index + i].rayTracingMaintenance1;
        ptr[i].rayTracingPipelineTraceRaysIndirect2 = src[start_index + i].rayTracingPipelineTraceRaysIndirect2;
    }
    return ptr;
}

template <>
VkTraceRaysIndirectCommand2KHR* CommandRecorder::CopyArray<VkTraceRaysIndirectCommand2KHR>(
    const VkTraceRaysIndirectCommand2KHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTraceRaysIndirectCommand2KHR*>(
        m_allocator.Alloc(sizeof(VkTraceRaysIndirectCommand2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].raygenShaderRecordAddress = src[start_index + i].raygenShaderRecordAddress;
        ptr[i].raygenShaderRecordSize = src[start_index + i].raygenShaderRecordSize;
        ptr[i].missShaderBindingTableAddress = src[start_index + i].missShaderBindingTableAddress;
        ptr[i].missShaderBindingTableSize = src[start_index + i].missShaderBindingTableSize;
        ptr[i].missShaderBindingTableStride = src[start_index + i].missShaderBindingTableStride;
        ptr[i].hitShaderBindingTableAddress = src[start_index + i].hitShaderBindingTableAddress;
        ptr[i].hitShaderBindingTableSize = src[start_index + i].hitShaderBindingTableSize;
        ptr[i].hitShaderBindingTableStride = src[start_index + i].hitShaderBindingTableStride;
        ptr[i].callableShaderBindingTableAddress = src[start_index + i].callableShaderBindingTableAddress;
        ptr[i].callableShaderBindingTableSize = src[start_index + i].callableShaderBindingTableSize;
        ptr[i].callableShaderBindingTableStride = src[start_index + i].callableShaderBindingTableStride;
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].depth = src[start_index + i].depth;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR>(
    const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSubgroupRotate = src[start_index + i].shaderSubgroupRotate;
        ptr[i].shaderSubgroupRotateClustered = src[start_index + i].shaderSubgroupRotateClustered;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>(
    const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderMaximalReconvergence = src[start_index + i].shaderMaximalReconvergence;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance5FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance5FeaturesKHR>(
    const VkPhysicalDeviceMaintenance5FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance5FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance5FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maintenance5 = src[start_index + i].maintenance5;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance5PropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance5PropertiesKHR>(
    const VkPhysicalDeviceMaintenance5PropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance5PropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance5PropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].earlyFragmentMultisampleCoverageAfterSampleCounting =
            src[start_index + i].earlyFragmentMultisampleCoverageAfterSampleCounting;
        ptr[i].earlyFragmentSampleMaskTestBeforeSampleCounting =
            src[start_index + i].earlyFragmentSampleMaskTestBeforeSampleCounting;
        ptr[i].depthStencilSwizzleOneSupport = src[start_index + i].depthStencilSwizzleOneSupport;
        ptr[i].polygonModePointSize = src[start_index + i].polygonModePointSize;
        ptr[i].nonStrictSinglePixelWideLinesUseParallelogram =
            src[start_index + i].nonStrictSinglePixelWideLinesUseParallelogram;
        ptr[i].nonStrictWideLinesUseParallelogram = src[start_index + i].nonStrictWideLinesUseParallelogram;
    }
    return ptr;
}

template <>
VkRenderingAreaInfoKHR* CommandRecorder::CopyArray<VkRenderingAreaInfoKHR>(const VkRenderingAreaInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderingAreaInfoKHR*>(m_allocator.Alloc(sizeof(VkRenderingAreaInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].viewMask = src[start_index + i].viewMask;
        ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
        ptr[i].pColorAttachmentFormats = nullptr;
        if (src[start_index + i].pColorAttachmentFormats) {
            ptr[i].pColorAttachmentFormats = CopyArray<>(src[start_index + i].pColorAttachmentFormats, 0, 1);
        }
        ptr[i].depthAttachmentFormat = src[start_index + i].depthAttachmentFormat;
        ptr[i].stencilAttachmentFormat = src[start_index + i].stencilAttachmentFormat;
    }
    return ptr;
}

template <>
VkImageSubresource2KHR* CommandRecorder::CopyArray<VkImageSubresource2KHR>(const VkImageSubresource2KHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageSubresource2KHR*>(m_allocator.Alloc(sizeof(VkImageSubresource2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
    }
    return ptr;
}

template <>
VkDeviceImageSubresourceInfoKHR* CommandRecorder::CopyArray<VkDeviceImageSubresourceInfoKHR>(
    const VkDeviceImageSubresourceInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceImageSubresourceInfoKHR*>(
        m_allocator.Alloc(sizeof(VkDeviceImageSubresourceInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pCreateInfo = src[start_index + i].pCreateInfo;
        ptr[i].pSubresource = src[start_index + i].pSubresource;
    }
    return ptr;
}

template <>
VkSubresourceLayout2KHR* CommandRecorder::CopyArray<VkSubresourceLayout2KHR>(const VkSubresourceLayout2KHR* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubresourceLayout2KHR*>(m_allocator.Alloc(sizeof(VkSubresourceLayout2KHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subresourceLayout = src[start_index + i].subresourceLayout;
    }
    return ptr;
}

template <>
VkPipelineCreateFlags2CreateInfoKHR* CommandRecorder::CopyArray<VkPipelineCreateFlags2CreateInfoKHR>(
    const VkPipelineCreateFlags2CreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCreateFlags2CreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineCreateFlags2CreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkBufferUsageFlags2CreateInfoKHR* CommandRecorder::CopyArray<VkBufferUsageFlags2CreateInfoKHR>(
    const VkBufferUsageFlags2CreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferUsageFlags2CreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkBufferUsageFlags2CreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].usage = src[start_index + i].usage;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>(
    const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingPositionFetch = src[start_index + i].rayTracingPositionFetch;
    }
    return ptr;
}

template <>
VkCooperativeMatrixPropertiesKHR* CommandRecorder::CopyArray<VkCooperativeMatrixPropertiesKHR>(
    const VkCooperativeMatrixPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCooperativeMatrixPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkCooperativeMatrixPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].MSize = src[start_index + i].MSize;
        ptr[i].NSize = src[start_index + i].NSize;
        ptr[i].KSize = src[start_index + i].KSize;
        ptr[i].AType = src[start_index + i].AType;
        ptr[i].BType = src[start_index + i].BType;
        ptr[i].CType = src[start_index + i].CType;
        ptr[i].ResultType = src[start_index + i].ResultType;
        ptr[i].saturatingAccumulation = src[start_index + i].saturatingAccumulation;
        ptr[i].scope = src[start_index + i].scope;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCooperativeMatrixFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>(
    const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cooperativeMatrix = src[start_index + i].cooperativeMatrix;
        ptr[i].cooperativeMatrixRobustBufferAccess = src[start_index + i].cooperativeMatrixRobustBufferAccess;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCooperativeMatrixPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixPropertiesKHR>(
    const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cooperativeMatrixSupportedStages = src[start_index + i].cooperativeMatrixSupportedStages;
    }
    return ptr;
}

template <>
VkVideoDecodeAV1ProfileInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1ProfileInfoKHR>(
    const VkVideoDecodeAV1ProfileInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeAV1ProfileInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeAV1ProfileInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stdProfile = src[start_index + i].stdProfile;
        ptr[i].filmGrainSupport = src[start_index + i].filmGrainSupport;
    }
    return ptr;
}

template <>
VkVideoDecodeAV1CapabilitiesKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1CapabilitiesKHR>(
    const VkVideoDecodeAV1CapabilitiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeAV1CapabilitiesKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeAV1CapabilitiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxLevel = src[start_index + i].maxLevel;
    }
    return ptr;
}

template <>
VkVideoDecodeAV1SessionParametersCreateInfoKHR*
CommandRecorder::CopyArray<VkVideoDecodeAV1SessionParametersCreateInfoKHR>(
    const VkVideoDecodeAV1SessionParametersCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeAV1SessionParametersCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeAV1SessionParametersCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdSequenceHeader = src[start_index + i].pStdSequenceHeader;
    }
    return ptr;
}

template <>
VkVideoDecodeAV1PictureInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1PictureInfoKHR>(
    const VkVideoDecodeAV1PictureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeAV1PictureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeAV1PictureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdPictureInfo = src[start_index + i].pStdPictureInfo;
        std::memcpy(ptr[i].referenceNameSlotIndices, src[start_index + i].referenceNameSlotIndices,
                    sizeof(src[start_index + i].referenceNameSlotIndices));
        ptr[i].frameHeaderOffset = src[start_index + i].frameHeaderOffset;
        ptr[i].tileCount = src[start_index + i].tileCount;
        ptr[i].pTileOffsets = nullptr;
        if (src[start_index + i].pTileOffsets) {
            ptr[i].pTileOffsets = CopyArray<>(src[start_index + i].pTileOffsets, 0, 1);
        }
        ptr[i].pTileSizes = nullptr;
        if (src[start_index + i].pTileSizes) {
            ptr[i].pTileSizes = CopyArray<>(src[start_index + i].pTileSizes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkVideoDecodeAV1DpbSlotInfoKHR* CommandRecorder::CopyArray<VkVideoDecodeAV1DpbSlotInfoKHR>(
    const VkVideoDecodeAV1DpbSlotInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVideoDecodeAV1DpbSlotInfoKHR*>(
        m_allocator.Alloc(sizeof(VkVideoDecodeAV1DpbSlotInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pStdReferenceInfo = src[start_index + i].pStdReferenceInfo;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVideoMaintenance1FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>(
    const VkPhysicalDeviceVideoMaintenance1FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVideoMaintenance1FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVideoMaintenance1FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].videoMaintenance1 = src[start_index + i].videoMaintenance1;
    }
    return ptr;
}

template <>
VkVideoInlineQueryInfoKHR* CommandRecorder::CopyArray<VkVideoInlineQueryInfoKHR>(const VkVideoInlineQueryInfoKHR* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkVideoInlineQueryInfoKHR*>(m_allocator.Alloc(sizeof(VkVideoInlineQueryInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queryPool = src[start_index + i].queryPool;
        ptr[i].firstQuery = src[start_index + i].firstQuery;
        ptr[i].queryCount = src[start_index + i].queryCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR>(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxVertexAttribDivisor = src[start_index + i].maxVertexAttribDivisor;
        ptr[i].supportsNonZeroFirstInstance = src[start_index + i].supportsNonZeroFirstInstance;
    }
    return ptr;
}

template <>
VkVertexInputBindingDivisorDescriptionKHR* CommandRecorder::CopyArray<VkVertexInputBindingDivisorDescriptionKHR>(
    const VkVertexInputBindingDivisorDescriptionKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVertexInputBindingDivisorDescriptionKHR*>(
        m_allocator.Alloc(sizeof(VkVertexInputBindingDivisorDescriptionKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].divisor = src[start_index + i].divisor;
    }
    return ptr;
}

template <>
VkPipelineVertexInputDivisorStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineVertexInputDivisorStateCreateInfoKHR>(
    const VkPipelineVertexInputDivisorStateCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineVertexInputDivisorStateCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineVertexInputDivisorStateCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexBindingDivisorCount = src[start_index + i].vertexBindingDivisorCount;
        ptr[i].pVertexBindingDivisors = nullptr;
        if (src[start_index + i].pVertexBindingDivisors) {
            ptr[i].pVertexBindingDivisors = CopyArray<>(src[start_index + i].pVertexBindingDivisors, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR>(
    const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexAttributeInstanceRateDivisor = src[start_index + i].vertexAttributeInstanceRateDivisor;
        ptr[i].vertexAttributeInstanceRateZeroDivisor = src[start_index + i].vertexAttributeInstanceRateZeroDivisor;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderFloatControls2FeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloatControls2FeaturesKHR>(
    const VkPhysicalDeviceShaderFloatControls2FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderFloatControls2FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderFloatControls2FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderFloatControls2 = src[start_index + i].shaderFloatControls2;
    }
    return ptr;
}

template <>
VkPhysicalDeviceIndexTypeUint8FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceIndexTypeUint8FeaturesKHR>(
    const VkPhysicalDeviceIndexTypeUint8FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].indexTypeUint8 = src[start_index + i].indexTypeUint8;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLineRasterizationFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationFeaturesKHR>(
    const VkPhysicalDeviceLineRasterizationFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLineRasterizationFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rectangularLines = src[start_index + i].rectangularLines;
        ptr[i].bresenhamLines = src[start_index + i].bresenhamLines;
        ptr[i].smoothLines = src[start_index + i].smoothLines;
        ptr[i].stippledRectangularLines = src[start_index + i].stippledRectangularLines;
        ptr[i].stippledBresenhamLines = src[start_index + i].stippledBresenhamLines;
        ptr[i].stippledSmoothLines = src[start_index + i].stippledSmoothLines;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLineRasterizationPropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationPropertiesKHR>(
    const VkPhysicalDeviceLineRasterizationPropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLineRasterizationPropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].lineSubPixelPrecisionBits = src[start_index + i].lineSubPixelPrecisionBits;
    }
    return ptr;
}

template <>
VkPipelineRasterizationLineStateCreateInfoKHR*
CommandRecorder::CopyArray<VkPipelineRasterizationLineStateCreateInfoKHR>(
    const VkPipelineRasterizationLineStateCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationLineStateCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].lineRasterizationMode = src[start_index + i].lineRasterizationMode;
        ptr[i].stippledLineEnable = src[start_index + i].stippledLineEnable;
        ptr[i].lineStippleFactor = src[start_index + i].lineStippleFactor;
        ptr[i].lineStipplePattern = src[start_index + i].lineStipplePattern;
    }
    return ptr;
}

template <>
VkCalibratedTimestampInfoKHR* CommandRecorder::CopyArray<VkCalibratedTimestampInfoKHR>(
    const VkCalibratedTimestampInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCalibratedTimestampInfoKHR*>(
        m_allocator.Alloc(sizeof(VkCalibratedTimestampInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].timeDomain = src[start_index + i].timeDomain;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderExpectAssumeFeaturesKHR>(
    const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderExpectAssumeFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderExpectAssume = src[start_index + i].shaderExpectAssume;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance6FeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance6FeaturesKHR>(
    const VkPhysicalDeviceMaintenance6FeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance6FeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance6FeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maintenance6 = src[start_index + i].maintenance6;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMaintenance6PropertiesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance6PropertiesKHR>(
    const VkPhysicalDeviceMaintenance6PropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance6PropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance6PropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].blockTexelViewCompatibleMultipleLayers = src[start_index + i].blockTexelViewCompatibleMultipleLayers;
        ptr[i].maxCombinedImageSamplerDescriptorCount = src[start_index + i].maxCombinedImageSamplerDescriptorCount;
        ptr[i].fragmentShadingRateClampCombinerInputs = src[start_index + i].fragmentShadingRateClampCombinerInputs;
    }
    return ptr;
}

template <>
VkBindMemoryStatusKHR* CommandRecorder::CopyArray<VkBindMemoryStatusKHR>(const VkBindMemoryStatusKHR* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindMemoryStatusKHR*>(m_allocator.Alloc(sizeof(VkBindMemoryStatusKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pResult = src[start_index + i].pResult;
    }
    return ptr;
}

template <>
VkBindDescriptorSetsInfoKHR* CommandRecorder::CopyArray<VkBindDescriptorSetsInfoKHR>(
    const VkBindDescriptorSetsInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkBindDescriptorSetsInfoKHR*>(m_allocator.Alloc(sizeof(VkBindDescriptorSetsInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].firstSet = src[start_index + i].firstSet;
        ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;
        ptr[i].pDescriptorSets = nullptr;
        if (src[start_index + i].pDescriptorSets) {
            ptr[i].pDescriptorSets = CopyArray<>(src[start_index + i].pDescriptorSets, 0, 1);
        }
        ptr[i].dynamicOffsetCount = src[start_index + i].dynamicOffsetCount;
        ptr[i].pDynamicOffsets = nullptr;
        if (src[start_index + i].pDynamicOffsets) {
            ptr[i].pDynamicOffsets = CopyArray<>(src[start_index + i].pDynamicOffsets, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPushConstantsInfoKHR* CommandRecorder::CopyArray<VkPushConstantsInfoKHR>(const VkPushConstantsInfoKHR* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPushConstantsInfoKHR*>(m_allocator.Alloc(sizeof(VkPushConstantsInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
        ptr[i].pValues = src[start_index + i].pValues;
    }
    return ptr;
}

template <>
VkPushDescriptorSetInfoKHR* CommandRecorder::CopyArray<VkPushDescriptorSetInfoKHR>(
    const VkPushDescriptorSetInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPushDescriptorSetInfoKHR*>(m_allocator.Alloc(sizeof(VkPushDescriptorSetInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].set = src[start_index + i].set;
        ptr[i].descriptorWriteCount = src[start_index + i].descriptorWriteCount;
        ptr[i].pDescriptorWrites = nullptr;
        if (src[start_index + i].pDescriptorWrites) {
            ptr[i].pDescriptorWrites = CopyArray<>(src[start_index + i].pDescriptorWrites, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPushDescriptorSetWithTemplateInfoKHR* CommandRecorder::CopyArray<VkPushDescriptorSetWithTemplateInfoKHR>(
    const VkPushDescriptorSetWithTemplateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPushDescriptorSetWithTemplateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkPushDescriptorSetWithTemplateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorUpdateTemplate = src[start_index + i].descriptorUpdateTemplate;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].set = src[start_index + i].set;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkSetDescriptorBufferOffsetsInfoEXT* CommandRecorder::CopyArray<VkSetDescriptorBufferOffsetsInfoEXT>(
    const VkSetDescriptorBufferOffsetsInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSetDescriptorBufferOffsetsInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSetDescriptorBufferOffsetsInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].firstSet = src[start_index + i].firstSet;
        ptr[i].setCount = src[start_index + i].setCount;
        ptr[i].pBufferIndices = nullptr;
        if (src[start_index + i].pBufferIndices) {
            ptr[i].pBufferIndices = CopyArray<>(src[start_index + i].pBufferIndices, 0, 1);
        }
        ptr[i].pOffsets = nullptr;
        if (src[start_index + i].pOffsets) {
            ptr[i].pOffsets = CopyArray<>(src[start_index + i].pOffsets, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBindDescriptorBufferEmbeddedSamplersInfoEXT*
CommandRecorder::CopyArray<VkBindDescriptorBufferEmbeddedSamplersInfoEXT>(
    const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindDescriptorBufferEmbeddedSamplersInfoEXT*>(
        m_allocator.Alloc(sizeof(VkBindDescriptorBufferEmbeddedSamplersInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stageFlags = src[start_index + i].stageFlags;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].set = src[start_index + i].set;
    }
    return ptr;
}

template <>
VkDebugReportCallbackCreateInfoEXT* CommandRecorder::CopyArray<VkDebugReportCallbackCreateInfoEXT>(
    const VkDebugReportCallbackCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugReportCallbackCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pfnCallback = src[start_index + i].pfnCallback;
        ptr[i].pUserData = src[start_index + i].pUserData;
    }
    return ptr;
}

template <>
VkPipelineRasterizationStateRasterizationOrderAMD*
CommandRecorder::CopyArray<VkPipelineRasterizationStateRasterizationOrderAMD>(
    const VkPipelineRasterizationStateRasterizationOrderAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rasterizationOrder = src[start_index + i].rasterizationOrder;
    }
    return ptr;
}

template <>
VkDebugMarkerObjectNameInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerObjectNameInfoEXT>(
    const VkDebugMarkerObjectNameInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugMarkerObjectNameInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugMarkerObjectNameInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].objectType = src[start_index + i].objectType;
        ptr[i].object = src[start_index + i].object;
        ptr[i].pObjectName = nullptr;
        if (src[start_index + i].pObjectName) {
            ptr[i].pObjectName =
                CopyArray<>(src[start_index + i].pObjectName, 0, strlen(src[start_index + i].pObjectName) + 1);
        }
    }
    return ptr;
}

template <>
VkDebugMarkerObjectTagInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerObjectTagInfoEXT>(
    const VkDebugMarkerObjectTagInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugMarkerObjectTagInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugMarkerObjectTagInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].objectType = src[start_index + i].objectType;
        ptr[i].object = src[start_index + i].object;
        ptr[i].tagName = src[start_index + i].tagName;
        ptr[i].tagSize = src[start_index + i].tagSize;
        ptr[i].pTag = src[start_index + i].pTag;
    }
    return ptr;
}

template <>
VkDebugMarkerMarkerInfoEXT* CommandRecorder::CopyArray<VkDebugMarkerMarkerInfoEXT>(
    const VkDebugMarkerMarkerInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDebugMarkerMarkerInfoEXT*>(m_allocator.Alloc(sizeof(VkDebugMarkerMarkerInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pMarkerName = nullptr;
        if (src[start_index + i].pMarkerName) {
            ptr[i].pMarkerName =
                CopyArray<>(src[start_index + i].pMarkerName, 0, strlen(src[start_index + i].pMarkerName) + 1);
        }
        std::memcpy(ptr[i].color, src[start_index + i].color, sizeof(src[start_index + i].color));
    }
    return ptr;
}

template <>
VkDedicatedAllocationImageCreateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationImageCreateInfoNV>(
    const VkDedicatedAllocationImageCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDedicatedAllocationImageCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkDedicatedAllocationImageCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dedicatedAllocation = src[start_index + i].dedicatedAllocation;
    }
    return ptr;
}

template <>
VkDedicatedAllocationBufferCreateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationBufferCreateInfoNV>(
    const VkDedicatedAllocationBufferCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDedicatedAllocationBufferCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkDedicatedAllocationBufferCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dedicatedAllocation = src[start_index + i].dedicatedAllocation;
    }
    return ptr;
}

template <>
VkDedicatedAllocationMemoryAllocateInfoNV* CommandRecorder::CopyArray<VkDedicatedAllocationMemoryAllocateInfoNV>(
    const VkDedicatedAllocationMemoryAllocateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDedicatedAllocationMemoryAllocateInfoNV*>(
        m_allocator.Alloc(sizeof(VkDedicatedAllocationMemoryAllocateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTransformFeedbackFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(
    const VkPhysicalDeviceTransformFeedbackFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].transformFeedback = src[start_index + i].transformFeedback;
        ptr[i].geometryStreams = src[start_index + i].geometryStreams;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTransformFeedbackPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(
    const VkPhysicalDeviceTransformFeedbackPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxTransformFeedbackStreams = src[start_index + i].maxTransformFeedbackStreams;
        ptr[i].maxTransformFeedbackBuffers = src[start_index + i].maxTransformFeedbackBuffers;
        ptr[i].maxTransformFeedbackBufferSize = src[start_index + i].maxTransformFeedbackBufferSize;
        ptr[i].maxTransformFeedbackStreamDataSize = src[start_index + i].maxTransformFeedbackStreamDataSize;
        ptr[i].maxTransformFeedbackBufferDataSize = src[start_index + i].maxTransformFeedbackBufferDataSize;
        ptr[i].maxTransformFeedbackBufferDataStride = src[start_index + i].maxTransformFeedbackBufferDataStride;
        ptr[i].transformFeedbackQueries = src[start_index + i].transformFeedbackQueries;
        ptr[i].transformFeedbackStreamsLinesTriangles = src[start_index + i].transformFeedbackStreamsLinesTriangles;
        ptr[i].transformFeedbackRasterizationStreamSelect =
            src[start_index + i].transformFeedbackRasterizationStreamSelect;
        ptr[i].transformFeedbackDraw = src[start_index + i].transformFeedbackDraw;
    }
    return ptr;
}

template <>
VkPipelineRasterizationStateStreamCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationStateStreamCreateInfoEXT>(
    const VkPipelineRasterizationStateStreamCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationStateStreamCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationStateStreamCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].rasterizationStream = src[start_index + i].rasterizationStream;
    }
    return ptr;
}

template <>
VkCuModuleCreateInfoNVX* CommandRecorder::CopyArray<VkCuModuleCreateInfoNVX>(const VkCuModuleCreateInfoNVX* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCuModuleCreateInfoNVX*>(m_allocator.Alloc(sizeof(VkCuModuleCreateInfoNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dataSize = src[start_index + i].dataSize;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkCuFunctionCreateInfoNVX* CommandRecorder::CopyArray<VkCuFunctionCreateInfoNVX>(const VkCuFunctionCreateInfoNVX* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCuFunctionCreateInfoNVX*>(m_allocator.Alloc(sizeof(VkCuFunctionCreateInfoNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].module = src[start_index + i].module;
        ptr[i].pName = nullptr;
        if (src[start_index + i].pName) {
            ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName) + 1);
        }
    }
    return ptr;
}

template <>
VkCuLaunchInfoNVX* CommandRecorder::CopyArray<VkCuLaunchInfoNVX>(const VkCuLaunchInfoNVX* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkCuLaunchInfoNVX*>(m_allocator.Alloc(sizeof(VkCuLaunchInfoNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].function = src[start_index + i].function;
        ptr[i].gridDimX = src[start_index + i].gridDimX;
        ptr[i].gridDimY = src[start_index + i].gridDimY;
        ptr[i].gridDimZ = src[start_index + i].gridDimZ;
        ptr[i].blockDimX = src[start_index + i].blockDimX;
        ptr[i].blockDimY = src[start_index + i].blockDimY;
        ptr[i].blockDimZ = src[start_index + i].blockDimZ;
        ptr[i].sharedMemBytes = src[start_index + i].sharedMemBytes;
        ptr[i].paramCount = src[start_index + i].paramCount;
        ptr[i].pParams = src[start_index + i].pParams;
        ptr[i].extraCount = src[start_index + i].extraCount;
        ptr[i].pExtras = src[start_index + i].pExtras;
    }
    return ptr;
}

template <>
VkImageViewHandleInfoNVX* CommandRecorder::CopyArray<VkImageViewHandleInfoNVX>(const VkImageViewHandleInfoNVX* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewHandleInfoNVX*>(m_allocator.Alloc(sizeof(VkImageViewHandleInfoNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].descriptorType = src[start_index + i].descriptorType;
        ptr[i].sampler = src[start_index + i].sampler;
    }
    return ptr;
}

template <>
VkImageViewAddressPropertiesNVX* CommandRecorder::CopyArray<VkImageViewAddressPropertiesNVX>(
    const VkImageViewAddressPropertiesNVX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewAddressPropertiesNVX*>(
        m_allocator.Alloc(sizeof(VkImageViewAddressPropertiesNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkTextureLODGatherFormatPropertiesAMD* CommandRecorder::CopyArray<VkTextureLODGatherFormatPropertiesAMD>(
    const VkTextureLODGatherFormatPropertiesAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD*>(
        m_allocator.Alloc(sizeof(VkTextureLODGatherFormatPropertiesAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportsTextureGatherLODBiasAMD = src[start_index + i].supportsTextureGatherLODBiasAMD;
    }
    return ptr;
}

template <>
VkShaderResourceUsageAMD* CommandRecorder::CopyArray<VkShaderResourceUsageAMD>(const VkShaderResourceUsageAMD* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkShaderResourceUsageAMD*>(m_allocator.Alloc(sizeof(VkShaderResourceUsageAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].numUsedVgprs = src[start_index + i].numUsedVgprs;
        ptr[i].numUsedSgprs = src[start_index + i].numUsedSgprs;
        ptr[i].ldsSizePerLocalWorkGroup = src[start_index + i].ldsSizePerLocalWorkGroup;
        ptr[i].ldsUsageSizeInBytes = src[start_index + i].ldsUsageSizeInBytes;
        ptr[i].scratchMemUsageInBytes = src[start_index + i].scratchMemUsageInBytes;
    }
    return ptr;
}

template <>
VkShaderStatisticsInfoAMD* CommandRecorder::CopyArray<VkShaderStatisticsInfoAMD>(const VkShaderStatisticsInfoAMD* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkShaderStatisticsInfoAMD*>(m_allocator.Alloc(sizeof(VkShaderStatisticsInfoAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].shaderStageMask = src[start_index + i].shaderStageMask;
        ptr[i].resourceUsage = src[start_index + i].resourceUsage;
        ptr[i].numPhysicalVgprs = src[start_index + i].numPhysicalVgprs;
        ptr[i].numPhysicalSgprs = src[start_index + i].numPhysicalSgprs;
        ptr[i].numAvailableVgprs = src[start_index + i].numAvailableVgprs;
        ptr[i].numAvailableSgprs = src[start_index + i].numAvailableSgprs;
        std::memcpy(ptr[i].computeWorkGroupSize, src[start_index + i].computeWorkGroupSize,
                    sizeof(src[start_index + i].computeWorkGroupSize));
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_GGP
template <>
VkStreamDescriptorSurfaceCreateInfoGGP* CommandRecorder::CopyArray<VkStreamDescriptorSurfaceCreateInfoGGP>(
    const VkStreamDescriptorSurfaceCreateInfoGGP* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkStreamDescriptorSurfaceCreateInfoGGP*>(
        m_allocator.Alloc(sizeof(VkStreamDescriptorSurfaceCreateInfoGGP) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].streamDescriptor = src[start_index + i].streamDescriptor;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_GGP

template <>
VkPhysicalDeviceCornerSampledImageFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCornerSampledImageFeaturesNV>(
    const VkPhysicalDeviceCornerSampledImageFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCornerSampledImageFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cornerSampledImage = src[start_index + i].cornerSampledImage;
    }
    return ptr;
}

template <>
VkExternalImageFormatPropertiesNV* CommandRecorder::CopyArray<VkExternalImageFormatPropertiesNV>(
    const VkExternalImageFormatPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalImageFormatPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkExternalImageFormatPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].imageFormatProperties = src[start_index + i].imageFormatProperties;
        ptr[i].externalMemoryFeatures = src[start_index + i].externalMemoryFeatures;
        ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
        ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
    }
    return ptr;
}

template <>
VkExternalMemoryImageCreateInfoNV* CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfoNV>(
    const VkExternalMemoryImageCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalMemoryImageCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkExternalMemoryImageCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

template <>
VkExportMemoryAllocateInfoNV* CommandRecorder::CopyArray<VkExportMemoryAllocateInfoNV>(
    const VkExportMemoryAllocateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMemoryAllocateInfoNV*>(
        m_allocator.Alloc(sizeof(VkExportMemoryAllocateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleTypes = src[start_index + i].handleTypes;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkImportMemoryWin32HandleInfoNV* CommandRecorder::CopyArray<VkImportMemoryWin32HandleInfoNV>(
    const VkImportMemoryWin32HandleInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryWin32HandleInfoNV*>(
        m_allocator.Alloc(sizeof(VkImportMemoryWin32HandleInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].handle = src[start_index + i].handle;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkExportMemoryWin32HandleInfoNV* CommandRecorder::CopyArray<VkExportMemoryWin32HandleInfoNV>(
    const VkExportMemoryWin32HandleInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMemoryWin32HandleInfoNV*>(
        m_allocator.Alloc(sizeof(VkExportMemoryWin32HandleInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pAttributes = src[start_index + i].pAttributes;
        ptr[i].dwAccess = src[start_index + i].dwAccess;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkWin32KeyedMutexAcquireReleaseInfoNV* CommandRecorder::CopyArray<VkWin32KeyedMutexAcquireReleaseInfoNV>(
    const VkWin32KeyedMutexAcquireReleaseInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWin32KeyedMutexAcquireReleaseInfoNV*>(
        m_allocator.Alloc(sizeof(VkWin32KeyedMutexAcquireReleaseInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].acquireCount = src[start_index + i].acquireCount;
        ptr[i].pAcquireSyncs = nullptr;
        if (src[start_index + i].pAcquireSyncs) {
            ptr[i].pAcquireSyncs = CopyArray<>(src[start_index + i].pAcquireSyncs, 0, 1);
        }
        ptr[i].pAcquireKeys = nullptr;
        if (src[start_index + i].pAcquireKeys) {
            ptr[i].pAcquireKeys = CopyArray<>(src[start_index + i].pAcquireKeys, 0, 1);
        }
        ptr[i].pAcquireTimeoutMilliseconds = nullptr;
        if (src[start_index + i].pAcquireTimeoutMilliseconds) {
            ptr[i].pAcquireTimeoutMilliseconds = CopyArray<>(src[start_index + i].pAcquireTimeoutMilliseconds, 0, 1);
        }
        ptr[i].releaseCount = src[start_index + i].releaseCount;
        ptr[i].pReleaseSyncs = nullptr;
        if (src[start_index + i].pReleaseSyncs) {
            ptr[i].pReleaseSyncs = CopyArray<>(src[start_index + i].pReleaseSyncs, 0, 1);
        }
        ptr[i].pReleaseKeys = nullptr;
        if (src[start_index + i].pReleaseKeys) {
            ptr[i].pReleaseKeys = CopyArray<>(src[start_index + i].pReleaseKeys, 0, 1);
        }
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkValidationFlagsEXT* CommandRecorder::CopyArray<VkValidationFlagsEXT>(const VkValidationFlagsEXT* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkValidationFlagsEXT*>(m_allocator.Alloc(sizeof(VkValidationFlagsEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].disabledValidationCheckCount = src[start_index + i].disabledValidationCheckCount;
        ptr[i].pDisabledValidationChecks = nullptr;
        if (src[start_index + i].pDisabledValidationChecks) {
            ptr[i].pDisabledValidationChecks = CopyArray<>(src[start_index + i].pDisabledValidationChecks, 0, 1);
        }
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_VI_NN
template <>
VkViSurfaceCreateInfoNN* CommandRecorder::CopyArray<VkViSurfaceCreateInfoNN>(const VkViSurfaceCreateInfoNN* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkViSurfaceCreateInfoNN*>(m_allocator.Alloc(sizeof(VkViSurfaceCreateInfoNN) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].window = src[start_index + i].window;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_VI_NN

template <>
VkImageViewASTCDecodeModeEXT* CommandRecorder::CopyArray<VkImageViewASTCDecodeModeEXT>(
    const VkImageViewASTCDecodeModeEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewASTCDecodeModeEXT*>(
        m_allocator.Alloc(sizeof(VkImageViewASTCDecodeModeEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].decodeMode = src[start_index + i].decodeMode;
    }
    return ptr;
}

template <>
VkPhysicalDeviceASTCDecodeFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceASTCDecodeFeaturesEXT>(
    const VkPhysicalDeviceASTCDecodeFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceASTCDecodeFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].decodeModeSharedExponent = src[start_index + i].decodeModeSharedExponent;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineRobustnessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineRobustnessFeaturesEXT>(
    const VkPhysicalDevicePipelineRobustnessFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineRobustnessFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineRobustness = src[start_index + i].pipelineRobustness;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineRobustnessPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineRobustnessPropertiesEXT>(
    const VkPhysicalDevicePipelineRobustnessPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineRobustnessPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].defaultRobustnessStorageBuffers = src[start_index + i].defaultRobustnessStorageBuffers;
        ptr[i].defaultRobustnessUniformBuffers = src[start_index + i].defaultRobustnessUniformBuffers;
        ptr[i].defaultRobustnessVertexInputs = src[start_index + i].defaultRobustnessVertexInputs;
        ptr[i].defaultRobustnessImages = src[start_index + i].defaultRobustnessImages;
    }
    return ptr;
}

template <>
VkPipelineRobustnessCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineRobustnessCreateInfoEXT>(
    const VkPipelineRobustnessCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRobustnessCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineRobustnessCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].storageBuffers = src[start_index + i].storageBuffers;
        ptr[i].uniformBuffers = src[start_index + i].uniformBuffers;
        ptr[i].vertexInputs = src[start_index + i].vertexInputs;
        ptr[i].images = src[start_index + i].images;
    }
    return ptr;
}

template <>
VkConditionalRenderingBeginInfoEXT* CommandRecorder::CopyArray<VkConditionalRenderingBeginInfoEXT>(
    const VkConditionalRenderingBeginInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkConditionalRenderingBeginInfoEXT*>(
        m_allocator.Alloc(sizeof(VkConditionalRenderingBeginInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceConditionalRenderingFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(
    const VkPhysicalDeviceConditionalRenderingFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].conditionalRendering = src[start_index + i].conditionalRendering;
        ptr[i].inheritedConditionalRendering = src[start_index + i].inheritedConditionalRendering;
    }
    return ptr;
}

template <>
VkCommandBufferInheritanceConditionalRenderingInfoEXT*
CommandRecorder::CopyArray<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(
    const VkCommandBufferInheritanceConditionalRenderingInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(
        m_allocator.Alloc(sizeof(VkCommandBufferInheritanceConditionalRenderingInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].conditionalRenderingEnable = src[start_index + i].conditionalRenderingEnable;
    }
    return ptr;
}

template <>
VkViewportWScalingNV* CommandRecorder::CopyArray<VkViewportWScalingNV>(const VkViewportWScalingNV* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkViewportWScalingNV*>(m_allocator.Alloc(sizeof(VkViewportWScalingNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].xcoeff = src[start_index + i].xcoeff;
        ptr[i].ycoeff = src[start_index + i].ycoeff;
    }
    return ptr;
}

template <>
VkPipelineViewportWScalingStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineViewportWScalingStateCreateInfoNV>(
    const VkPipelineViewportWScalingStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportWScalingStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportWScalingStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].viewportWScalingEnable = src[start_index + i].viewportWScalingEnable;
        ptr[i].viewportCount = src[start_index + i].viewportCount;
        ptr[i].pViewportWScalings = nullptr;
        if (src[start_index + i].pViewportWScalings) {
            ptr[i].pViewportWScalings = CopyArray<>(src[start_index + i].pViewportWScalings, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSurfaceCapabilities2EXT* CommandRecorder::CopyArray<VkSurfaceCapabilities2EXT>(const VkSurfaceCapabilities2EXT* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSurfaceCapabilities2EXT*>(m_allocator.Alloc(sizeof(VkSurfaceCapabilities2EXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minImageCount = src[start_index + i].minImageCount;
        ptr[i].maxImageCount = src[start_index + i].maxImageCount;
        ptr[i].currentExtent = src[start_index + i].currentExtent;
        ptr[i].minImageExtent = src[start_index + i].minImageExtent;
        ptr[i].maxImageExtent = src[start_index + i].maxImageExtent;
        ptr[i].maxImageArrayLayers = src[start_index + i].maxImageArrayLayers;
        ptr[i].supportedTransforms = src[start_index + i].supportedTransforms;
        ptr[i].currentTransform = src[start_index + i].currentTransform;
        ptr[i].supportedCompositeAlpha = src[start_index + i].supportedCompositeAlpha;
        ptr[i].supportedUsageFlags = src[start_index + i].supportedUsageFlags;
        ptr[i].supportedSurfaceCounters = src[start_index + i].supportedSurfaceCounters;
    }
    return ptr;
}

template <>
VkDisplayPowerInfoEXT* CommandRecorder::CopyArray<VkDisplayPowerInfoEXT>(const VkDisplayPowerInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayPowerInfoEXT*>(m_allocator.Alloc(sizeof(VkDisplayPowerInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].powerState = src[start_index + i].powerState;
    }
    return ptr;
}

template <>
VkDeviceEventInfoEXT* CommandRecorder::CopyArray<VkDeviceEventInfoEXT>(const VkDeviceEventInfoEXT* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceEventInfoEXT*>(m_allocator.Alloc(sizeof(VkDeviceEventInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceEvent = src[start_index + i].deviceEvent;
    }
    return ptr;
}

template <>
VkDisplayEventInfoEXT* CommandRecorder::CopyArray<VkDisplayEventInfoEXT>(const VkDisplayEventInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayEventInfoEXT*>(m_allocator.Alloc(sizeof(VkDisplayEventInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displayEvent = src[start_index + i].displayEvent;
    }
    return ptr;
}

template <>
VkSwapchainCounterCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainCounterCreateInfoEXT>(
    const VkSwapchainCounterCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainCounterCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSwapchainCounterCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].surfaceCounters = src[start_index + i].surfaceCounters;
    }
    return ptr;
}

template <>
VkRefreshCycleDurationGOOGLE* CommandRecorder::CopyArray<VkRefreshCycleDurationGOOGLE>(
    const VkRefreshCycleDurationGOOGLE* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRefreshCycleDurationGOOGLE*>(
        m_allocator.Alloc(sizeof(VkRefreshCycleDurationGOOGLE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].refreshDuration = src[start_index + i].refreshDuration;
    }
    return ptr;
}

template <>
VkPastPresentationTimingGOOGLE* CommandRecorder::CopyArray<VkPastPresentationTimingGOOGLE>(
    const VkPastPresentationTimingGOOGLE* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPastPresentationTimingGOOGLE*>(
        m_allocator.Alloc(sizeof(VkPastPresentationTimingGOOGLE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].presentID = src[start_index + i].presentID;
        ptr[i].desiredPresentTime = src[start_index + i].desiredPresentTime;
        ptr[i].actualPresentTime = src[start_index + i].actualPresentTime;
        ptr[i].earliestPresentTime = src[start_index + i].earliestPresentTime;
        ptr[i].presentMargin = src[start_index + i].presentMargin;
    }
    return ptr;
}

template <>
VkPresentTimeGOOGLE* CommandRecorder::CopyArray<VkPresentTimeGOOGLE>(const VkPresentTimeGOOGLE* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentTimeGOOGLE*>(m_allocator.Alloc(sizeof(VkPresentTimeGOOGLE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].presentID = src[start_index + i].presentID;
        ptr[i].desiredPresentTime = src[start_index + i].desiredPresentTime;
    }
    return ptr;
}

template <>
VkPresentTimesInfoGOOGLE* CommandRecorder::CopyArray<VkPresentTimesInfoGOOGLE>(const VkPresentTimesInfoGOOGLE* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentTimesInfoGOOGLE*>(m_allocator.Alloc(sizeof(VkPresentTimesInfoGOOGLE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pTimes = nullptr;
        if (src[start_index + i].pTimes) {
            ptr[i].pTimes = CopyArray<>(src[start_index + i].pTimes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(
    const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].perViewPositionAllComponents = src[start_index + i].perViewPositionAllComponents;
    }
    return ptr;
}

template <>
VkViewportSwizzleNV* CommandRecorder::CopyArray<VkViewportSwizzleNV>(const VkViewportSwizzleNV* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkViewportSwizzleNV*>(m_allocator.Alloc(sizeof(VkViewportSwizzleNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
        ptr[i].z = src[start_index + i].z;
        ptr[i].w = src[start_index + i].w;
    }
    return ptr;
}

template <>
VkPipelineViewportSwizzleStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineViewportSwizzleStateCreateInfoNV>(
    const VkPipelineViewportSwizzleStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportSwizzleStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportSwizzleStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].viewportCount = src[start_index + i].viewportCount;
        ptr[i].pViewportSwizzles = nullptr;
        if (src[start_index + i].pViewportSwizzles) {
            ptr[i].pViewportSwizzles = CopyArray<>(src[start_index + i].pViewportSwizzles, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceDiscardRectanglePropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(
    const VkPhysicalDeviceDiscardRectanglePropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxDiscardRectangles = src[start_index + i].maxDiscardRectangles;
    }
    return ptr;
}

template <>
VkPipelineDiscardRectangleStateCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineDiscardRectangleStateCreateInfoEXT>(
    const VkPipelineDiscardRectangleStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineDiscardRectangleStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineDiscardRectangleStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].discardRectangleMode = src[start_index + i].discardRectangleMode;
        ptr[i].discardRectangleCount = src[start_index + i].discardRectangleCount;
        ptr[i].pDiscardRectangles = nullptr;
        if (src[start_index + i].pDiscardRectangles) {
            ptr[i].pDiscardRectangles = CopyArray<>(src[start_index + i].pDiscardRectangles, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceConservativeRasterizationPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(
    const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].primitiveOverestimationSize = src[start_index + i].primitiveOverestimationSize;
        ptr[i].maxExtraPrimitiveOverestimationSize = src[start_index + i].maxExtraPrimitiveOverestimationSize;
        ptr[i].extraPrimitiveOverestimationSizeGranularity =
            src[start_index + i].extraPrimitiveOverestimationSizeGranularity;
        ptr[i].primitiveUnderestimation = src[start_index + i].primitiveUnderestimation;
        ptr[i].conservativePointAndLineRasterization = src[start_index + i].conservativePointAndLineRasterization;
        ptr[i].degenerateTrianglesRasterized = src[start_index + i].degenerateTrianglesRasterized;
        ptr[i].degenerateLinesRasterized = src[start_index + i].degenerateLinesRasterized;
        ptr[i].fullyCoveredFragmentShaderInputVariable = src[start_index + i].fullyCoveredFragmentShaderInputVariable;
        ptr[i].conservativeRasterizationPostDepthCoverage =
            src[start_index + i].conservativeRasterizationPostDepthCoverage;
    }
    return ptr;
}

template <>
VkPipelineRasterizationConservativeStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationConservativeStateCreateInfoEXT>(
    const VkPipelineRasterizationConservativeStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationConservativeStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationConservativeStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].conservativeRasterizationMode = src[start_index + i].conservativeRasterizationMode;
        ptr[i].extraPrimitiveOverestimationSize = src[start_index + i].extraPrimitiveOverestimationSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDepthClipEnableFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(
    const VkPhysicalDeviceDepthClipEnableFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthClipEnable = src[start_index + i].depthClipEnable;
    }
    return ptr;
}

template <>
VkPipelineRasterizationDepthClipStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(
    const VkPipelineRasterizationDepthClipStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].depthClipEnable = src[start_index + i].depthClipEnable;
    }
    return ptr;
}

template <>
VkXYColorEXT* CommandRecorder::CopyArray<VkXYColorEXT>(const VkXYColorEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkXYColorEXT*>(m_allocator.Alloc(sizeof(VkXYColorEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
    }
    return ptr;
}

template <>
VkHdrMetadataEXT* CommandRecorder::CopyArray<VkHdrMetadataEXT>(const VkHdrMetadataEXT* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkHdrMetadataEXT*>(m_allocator.Alloc(sizeof(VkHdrMetadataEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displayPrimaryRed = src[start_index + i].displayPrimaryRed;
        ptr[i].displayPrimaryGreen = src[start_index + i].displayPrimaryGreen;
        ptr[i].displayPrimaryBlue = src[start_index + i].displayPrimaryBlue;
        ptr[i].whitePoint = src[start_index + i].whitePoint;
        ptr[i].maxLuminance = src[start_index + i].maxLuminance;
        ptr[i].minLuminance = src[start_index + i].minLuminance;
        ptr[i].maxContentLightLevel = src[start_index + i].maxContentLightLevel;
        ptr[i].maxFrameAverageLightLevel = src[start_index + i].maxFrameAverageLightLevel;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*
CommandRecorder::CopyArray<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>(
    const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].relaxedLineRasterization = src[start_index + i].relaxedLineRasterization;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_IOS_MVK
template <>
VkIOSSurfaceCreateInfoMVK* CommandRecorder::CopyArray<VkIOSSurfaceCreateInfoMVK>(const VkIOSSurfaceCreateInfoMVK* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkIOSSurfaceCreateInfoMVK*>(m_allocator.Alloc(sizeof(VkIOSSurfaceCreateInfoMVK) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pView = src[start_index + i].pView;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_IOS_MVK

#ifdef VK_USE_PLATFORM_MACOS_MVK
template <>
VkMacOSSurfaceCreateInfoMVK* CommandRecorder::CopyArray<VkMacOSSurfaceCreateInfoMVK>(
    const VkMacOSSurfaceCreateInfoMVK* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMacOSSurfaceCreateInfoMVK*>(m_allocator.Alloc(sizeof(VkMacOSSurfaceCreateInfoMVK) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pView = src[start_index + i].pView;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_MACOS_MVK

template <>
VkDebugUtilsLabelEXT* CommandRecorder::CopyArray<VkDebugUtilsLabelEXT>(const VkDebugUtilsLabelEXT* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugUtilsLabelEXT*>(m_allocator.Alloc(sizeof(VkDebugUtilsLabelEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pLabelName = nullptr;
        if (src[start_index + i].pLabelName) {
            ptr[i].pLabelName =
                CopyArray<>(src[start_index + i].pLabelName, 0, strlen(src[start_index + i].pLabelName) + 1);
        }
        std::memcpy(ptr[i].color, src[start_index + i].color, sizeof(src[start_index + i].color));
    }
    return ptr;
}

template <>
VkDebugUtilsObjectNameInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsObjectNameInfoEXT>(
    const VkDebugUtilsObjectNameInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugUtilsObjectNameInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugUtilsObjectNameInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].objectType = src[start_index + i].objectType;
        ptr[i].objectHandle = src[start_index + i].objectHandle;
        ptr[i].pObjectName = nullptr;
        if (src[start_index + i].pObjectName) {
            ptr[i].pObjectName =
                CopyArray<>(src[start_index + i].pObjectName, 0, strlen(src[start_index + i].pObjectName) + 1);
        }
    }
    return ptr;
}

template <>
VkDebugUtilsMessengerCallbackDataEXT* CommandRecorder::CopyArray<VkDebugUtilsMessengerCallbackDataEXT>(
    const VkDebugUtilsMessengerCallbackDataEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugUtilsMessengerCallbackDataEXT*>(
        m_allocator.Alloc(sizeof(VkDebugUtilsMessengerCallbackDataEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pMessageIdName = nullptr;
        if (src[start_index + i].pMessageIdName) {
            ptr[i].pMessageIdName =
                CopyArray<>(src[start_index + i].pMessageIdName, 0, strlen(src[start_index + i].pMessageIdName) + 1);
        }
        ptr[i].messageIdNumber = src[start_index + i].messageIdNumber;
        ptr[i].pMessage = nullptr;
        if (src[start_index + i].pMessage) {
            ptr[i].pMessage = CopyArray<>(src[start_index + i].pMessage, 0, strlen(src[start_index + i].pMessage) + 1);
        }
        ptr[i].queueLabelCount = src[start_index + i].queueLabelCount;
        ptr[i].pQueueLabels = nullptr;
        if (src[start_index + i].pQueueLabels) {
            ptr[i].pQueueLabels = CopyArray<>(src[start_index + i].pQueueLabels, 0, 1);
        }
        ptr[i].cmdBufLabelCount = src[start_index + i].cmdBufLabelCount;
        ptr[i].pCmdBufLabels = nullptr;
        if (src[start_index + i].pCmdBufLabels) {
            ptr[i].pCmdBufLabels = CopyArray<>(src[start_index + i].pCmdBufLabels, 0, 1);
        }
        ptr[i].objectCount = src[start_index + i].objectCount;
        ptr[i].pObjects = nullptr;
        if (src[start_index + i].pObjects) {
            ptr[i].pObjects = CopyArray<>(src[start_index + i].pObjects, 0, 1);
        }
    }
    return ptr;
}

template <>
VkDebugUtilsMessengerCreateInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsMessengerCreateInfoEXT>(
    const VkDebugUtilsMessengerCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugUtilsMessengerCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].messageSeverity = src[start_index + i].messageSeverity;
        ptr[i].messageType = src[start_index + i].messageType;
        ptr[i].pfnUserCallback = src[start_index + i].pfnUserCallback;
        ptr[i].pUserData = src[start_index + i].pUserData;
    }
    return ptr;
}

template <>
VkDebugUtilsObjectTagInfoEXT* CommandRecorder::CopyArray<VkDebugUtilsObjectTagInfoEXT>(
    const VkDebugUtilsObjectTagInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDebugUtilsObjectTagInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDebugUtilsObjectTagInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].objectType = src[start_index + i].objectType;
        ptr[i].objectHandle = src[start_index + i].objectHandle;
        ptr[i].tagName = src[start_index + i].tagName;
        ptr[i].tagSize = src[start_index + i].tagSize;
        ptr[i].pTag = src[start_index + i].pTag;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferUsageANDROID* CommandRecorder::CopyArray<VkAndroidHardwareBufferUsageANDROID>(
    const VkAndroidHardwareBufferUsageANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidHardwareBufferUsageANDROID*>(
        m_allocator.Alloc(sizeof(VkAndroidHardwareBufferUsageANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].androidHardwareBufferUsage = src[start_index + i].androidHardwareBufferUsage;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferPropertiesANDROID* CommandRecorder::CopyArray<VkAndroidHardwareBufferPropertiesANDROID>(
    const VkAndroidHardwareBufferPropertiesANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidHardwareBufferPropertiesANDROID*>(
        m_allocator.Alloc(sizeof(VkAndroidHardwareBufferPropertiesANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].allocationSize = src[start_index + i].allocationSize;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatPropertiesANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatPropertiesANDROID>(
    const VkAndroidHardwareBufferFormatPropertiesANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidHardwareBufferFormatPropertiesANDROID*>(
        m_allocator.Alloc(sizeof(VkAndroidHardwareBufferFormatPropertiesANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].externalFormat = src[start_index + i].externalFormat;
        ptr[i].formatFeatures = src[start_index + i].formatFeatures;
        ptr[i].samplerYcbcrConversionComponents = src[start_index + i].samplerYcbcrConversionComponents;
        ptr[i].suggestedYcbcrModel = src[start_index + i].suggestedYcbcrModel;
        ptr[i].suggestedYcbcrRange = src[start_index + i].suggestedYcbcrRange;
        ptr[i].suggestedXChromaOffset = src[start_index + i].suggestedXChromaOffset;
        ptr[i].suggestedYChromaOffset = src[start_index + i].suggestedYChromaOffset;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkImportAndroidHardwareBufferInfoANDROID* CommandRecorder::CopyArray<VkImportAndroidHardwareBufferInfoANDROID>(
    const VkImportAndroidHardwareBufferInfoANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportAndroidHardwareBufferInfoANDROID*>(
        m_allocator.Alloc(sizeof(VkImportAndroidHardwareBufferInfoANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkMemoryGetAndroidHardwareBufferInfoANDROID* CommandRecorder::CopyArray<VkMemoryGetAndroidHardwareBufferInfoANDROID>(
    const VkMemoryGetAndroidHardwareBufferInfoANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryGetAndroidHardwareBufferInfoANDROID*>(
        m_allocator.Alloc(sizeof(VkMemoryGetAndroidHardwareBufferInfoANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkExternalFormatANDROID* CommandRecorder::CopyArray<VkExternalFormatANDROID>(const VkExternalFormatANDROID* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalFormatANDROID*>(m_allocator.Alloc(sizeof(VkExternalFormatANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalFormat = src[start_index + i].externalFormat;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatProperties2ANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatProperties2ANDROID>(
    const VkAndroidHardwareBufferFormatProperties2ANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidHardwareBufferFormatProperties2ANDROID*>(
        m_allocator.Alloc(sizeof(VkAndroidHardwareBufferFormatProperties2ANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].externalFormat = src[start_index + i].externalFormat;
        ptr[i].formatFeatures = src[start_index + i].formatFeatures;
        ptr[i].samplerYcbcrConversionComponents = src[start_index + i].samplerYcbcrConversionComponents;
        ptr[i].suggestedYcbcrModel = src[start_index + i].suggestedYcbcrModel;
        ptr[i].suggestedYcbcrRange = src[start_index + i].suggestedYcbcrRange;
        ptr[i].suggestedXChromaOffset = src[start_index + i].suggestedXChromaOffset;
        ptr[i].suggestedYChromaOffset = src[start_index + i].suggestedYChromaOffset;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceShaderEnqueueFeaturesAMDX* CommandRecorder::CopyArray<VkPhysicalDeviceShaderEnqueueFeaturesAMDX>(
    const VkPhysicalDeviceShaderEnqueueFeaturesAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderEnqueueFeaturesAMDX*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderEnqueueFeaturesAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderEnqueue = src[start_index + i].shaderEnqueue;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceShaderEnqueuePropertiesAMDX* CommandRecorder::CopyArray<VkPhysicalDeviceShaderEnqueuePropertiesAMDX>(
    const VkPhysicalDeviceShaderEnqueuePropertiesAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderEnqueuePropertiesAMDX*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderEnqueuePropertiesAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxExecutionGraphDepth = src[start_index + i].maxExecutionGraphDepth;
        ptr[i].maxExecutionGraphShaderOutputNodes = src[start_index + i].maxExecutionGraphShaderOutputNodes;
        ptr[i].maxExecutionGraphShaderPayloadSize = src[start_index + i].maxExecutionGraphShaderPayloadSize;
        ptr[i].maxExecutionGraphShaderPayloadCount = src[start_index + i].maxExecutionGraphShaderPayloadCount;
        ptr[i].executionGraphDispatchAddressAlignment = src[start_index + i].executionGraphDispatchAddressAlignment;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkExecutionGraphPipelineScratchSizeAMDX* CommandRecorder::CopyArray<VkExecutionGraphPipelineScratchSizeAMDX>(
    const VkExecutionGraphPipelineScratchSizeAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExecutionGraphPipelineScratchSizeAMDX*>(
        m_allocator.Alloc(sizeof(VkExecutionGraphPipelineScratchSizeAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkExecutionGraphPipelineCreateInfoAMDX* CommandRecorder::CopyArray<VkExecutionGraphPipelineCreateInfoAMDX>(
    const VkExecutionGraphPipelineCreateInfoAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExecutionGraphPipelineCreateInfoAMDX*>(
        m_allocator.Alloc(sizeof(VkExecutionGraphPipelineCreateInfoAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stageCount = src[start_index + i].stageCount;
        ptr[i].pStages = nullptr;
        if (src[start_index + i].pStages) {
            ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
        }
        ptr[i].pLibraryInfo = src[start_index + i].pLibraryInfo;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
        ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDeviceOrHostAddressConstAMDX* CommandRecorder::CopyArray<VkDeviceOrHostAddressConstAMDX>(
    const VkDeviceOrHostAddressConstAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceOrHostAddressConstAMDX*>(
        m_allocator.Alloc(sizeof(VkDeviceOrHostAddressConstAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].hostAddress = src[start_index + i].hostAddress;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDispatchGraphInfoAMDX* CommandRecorder::CopyArray<VkDispatchGraphInfoAMDX>(const VkDispatchGraphInfoAMDX* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDispatchGraphInfoAMDX*>(m_allocator.Alloc(sizeof(VkDispatchGraphInfoAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].nodeIndex = src[start_index + i].nodeIndex;
        ptr[i].payloadCount = src[start_index + i].payloadCount;
        ptr[i].payloads = src[start_index + i].payloads;
        ptr[i].payloadStride = src[start_index + i].payloadStride;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkDispatchGraphCountInfoAMDX* CommandRecorder::CopyArray<VkDispatchGraphCountInfoAMDX>(
    const VkDispatchGraphCountInfoAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDispatchGraphCountInfoAMDX*>(
        m_allocator.Alloc(sizeof(VkDispatchGraphCountInfoAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].count = src[start_index + i].count;
        ptr[i].infos = src[start_index + i].infos;
        ptr[i].stride = src[start_index + i].stride;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPipelineShaderStageNodeCreateInfoAMDX* CommandRecorder::CopyArray<VkPipelineShaderStageNodeCreateInfoAMDX>(
    const VkPipelineShaderStageNodeCreateInfoAMDX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineShaderStageNodeCreateInfoAMDX*>(
        m_allocator.Alloc(sizeof(VkPipelineShaderStageNodeCreateInfoAMDX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pName = nullptr;
        if (src[start_index + i].pName) {
            ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName) + 1);
        }
        ptr[i].index = src[start_index + i].index;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

template <>
VkSampleLocationEXT* CommandRecorder::CopyArray<VkSampleLocationEXT>(const VkSampleLocationEXT* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSampleLocationEXT*>(m_allocator.Alloc(sizeof(VkSampleLocationEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].x = src[start_index + i].x;
        ptr[i].y = src[start_index + i].y;
    }
    return ptr;
}

template <>
VkSampleLocationsInfoEXT* CommandRecorder::CopyArray<VkSampleLocationsInfoEXT>(const VkSampleLocationsInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSampleLocationsInfoEXT*>(m_allocator.Alloc(sizeof(VkSampleLocationsInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampleLocationsPerPixel = src[start_index + i].sampleLocationsPerPixel;
        ptr[i].sampleLocationGridSize = src[start_index + i].sampleLocationGridSize;
        ptr[i].sampleLocationsCount = src[start_index + i].sampleLocationsCount;
        ptr[i].pSampleLocations = nullptr;
        if (src[start_index + i].pSampleLocations) {
            ptr[i].pSampleLocations = CopyArray<>(src[start_index + i].pSampleLocations, 0, 1);
        }
    }
    return ptr;
}

template <>
VkAttachmentSampleLocationsEXT* CommandRecorder::CopyArray<VkAttachmentSampleLocationsEXT>(
    const VkAttachmentSampleLocationsEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAttachmentSampleLocationsEXT*>(
        m_allocator.Alloc(sizeof(VkAttachmentSampleLocationsEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].attachmentIndex = src[start_index + i].attachmentIndex;
        ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
    }
    return ptr;
}

template <>
VkSubpassSampleLocationsEXT* CommandRecorder::CopyArray<VkSubpassSampleLocationsEXT>(
    const VkSubpassSampleLocationsEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSubpassSampleLocationsEXT*>(m_allocator.Alloc(sizeof(VkSubpassSampleLocationsEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].subpassIndex = src[start_index + i].subpassIndex;
        ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
    }
    return ptr;
}

template <>
VkRenderPassSampleLocationsBeginInfoEXT* CommandRecorder::CopyArray<VkRenderPassSampleLocationsBeginInfoEXT>(
    const VkRenderPassSampleLocationsBeginInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassSampleLocationsBeginInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentInitialSampleLocationsCount = src[start_index + i].attachmentInitialSampleLocationsCount;
        ptr[i].pAttachmentInitialSampleLocations = nullptr;
        if (src[start_index + i].pAttachmentInitialSampleLocations) {
            ptr[i].pAttachmentInitialSampleLocations =
                CopyArray<>(src[start_index + i].pAttachmentInitialSampleLocations, 0, 1);
        }
        ptr[i].postSubpassSampleLocationsCount = src[start_index + i].postSubpassSampleLocationsCount;
        ptr[i].pPostSubpassSampleLocations = nullptr;
        if (src[start_index + i].pPostSubpassSampleLocations) {
            ptr[i].pPostSubpassSampleLocations = CopyArray<>(src[start_index + i].pPostSubpassSampleLocations, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineSampleLocationsStateCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineSampleLocationsStateCreateInfoEXT>(
    const VkPipelineSampleLocationsStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineSampleLocationsStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampleLocationsEnable = src[start_index + i].sampleLocationsEnable;
        ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSampleLocationsPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceSampleLocationsPropertiesEXT>(
    const VkPhysicalDeviceSampleLocationsPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampleLocationSampleCounts = src[start_index + i].sampleLocationSampleCounts;
        ptr[i].maxSampleLocationGridSize = src[start_index + i].maxSampleLocationGridSize;
        std::memcpy(ptr[i].sampleLocationCoordinateRange, src[start_index + i].sampleLocationCoordinateRange,
                    sizeof(src[start_index + i].sampleLocationCoordinateRange));
        ptr[i].sampleLocationSubPixelBits = src[start_index + i].sampleLocationSubPixelBits;
        ptr[i].variableSampleLocations = src[start_index + i].variableSampleLocations;
    }
    return ptr;
}

template <>
VkMultisamplePropertiesEXT* CommandRecorder::CopyArray<VkMultisamplePropertiesEXT>(
    const VkMultisamplePropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMultisamplePropertiesEXT*>(m_allocator.Alloc(sizeof(VkMultisamplePropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxSampleLocationGridSize = src[start_index + i].maxSampleLocationGridSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(
    const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].advancedBlendCoherentOperations = src[start_index + i].advancedBlendCoherentOperations;
    }
    return ptr;
}

template <>
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(
    const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].advancedBlendMaxColorAttachments = src[start_index + i].advancedBlendMaxColorAttachments;
        ptr[i].advancedBlendIndependentBlend = src[start_index + i].advancedBlendIndependentBlend;
        ptr[i].advancedBlendNonPremultipliedSrcColor = src[start_index + i].advancedBlendNonPremultipliedSrcColor;
        ptr[i].advancedBlendNonPremultipliedDstColor = src[start_index + i].advancedBlendNonPremultipliedDstColor;
        ptr[i].advancedBlendCorrelatedOverlap = src[start_index + i].advancedBlendCorrelatedOverlap;
        ptr[i].advancedBlendAllOperations = src[start_index + i].advancedBlendAllOperations;
    }
    return ptr;
}

template <>
VkPipelineColorBlendAdvancedStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(
    const VkPipelineColorBlendAdvancedStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineColorBlendAdvancedStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].srcPremultiplied = src[start_index + i].srcPremultiplied;
        ptr[i].dstPremultiplied = src[start_index + i].dstPremultiplied;
        ptr[i].blendOverlap = src[start_index + i].blendOverlap;
    }
    return ptr;
}

template <>
VkPipelineCoverageToColorStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineCoverageToColorStateCreateInfoNV>(
    const VkPipelineCoverageToColorStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCoverageToColorStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineCoverageToColorStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].coverageToColorEnable = src[start_index + i].coverageToColorEnable;
        ptr[i].coverageToColorLocation = src[start_index + i].coverageToColorLocation;
    }
    return ptr;
}

template <>
VkPipelineCoverageModulationStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineCoverageModulationStateCreateInfoNV>(
    const VkPipelineCoverageModulationStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCoverageModulationStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineCoverageModulationStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].coverageModulationMode = src[start_index + i].coverageModulationMode;
        ptr[i].coverageModulationTableEnable = src[start_index + i].coverageModulationTableEnable;
        ptr[i].coverageModulationTableCount = src[start_index + i].coverageModulationTableCount;
        ptr[i].pCoverageModulationTable = nullptr;
        if (src[start_index + i].pCoverageModulationTable) {
            ptr[i].pCoverageModulationTable = CopyArray<>(src[start_index + i].pCoverageModulationTable, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(
    const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSMCount = src[start_index + i].shaderSMCount;
        ptr[i].shaderWarpsPerSM = src[start_index + i].shaderWarpsPerSM;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(
    const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderSMBuiltins = src[start_index + i].shaderSMBuiltins;
    }
    return ptr;
}

template <>
VkDrmFormatModifierPropertiesEXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesEXT>(
    const VkDrmFormatModifierPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrmFormatModifierPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkDrmFormatModifierPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
        ptr[i].drmFormatModifierPlaneCount = src[start_index + i].drmFormatModifierPlaneCount;
        ptr[i].drmFormatModifierTilingFeatures = src[start_index + i].drmFormatModifierTilingFeatures;
    }
    return ptr;
}

template <>
VkDrmFormatModifierPropertiesListEXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesListEXT>(
    const VkDrmFormatModifierPropertiesListEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrmFormatModifierPropertiesListEXT*>(
        m_allocator.Alloc(sizeof(VkDrmFormatModifierPropertiesListEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifierCount = src[start_index + i].drmFormatModifierCount;
        ptr[i].pDrmFormatModifierProperties = nullptr;
        if (src[start_index + i].pDrmFormatModifierProperties) {
            ptr[i].pDrmFormatModifierProperties = CopyArray<>(src[start_index + i].pDrmFormatModifierProperties, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageDrmFormatModifierInfoEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(
    const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
        ptr[i].sharingMode = src[start_index + i].sharingMode;
        ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
        ptr[i].pQueueFamilyIndices = nullptr;
        if (src[start_index + i].pQueueFamilyIndices) {
            ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageDrmFormatModifierListCreateInfoEXT* CommandRecorder::CopyArray<VkImageDrmFormatModifierListCreateInfoEXT>(
    const VkImageDrmFormatModifierListCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageDrmFormatModifierListCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifierCount = src[start_index + i].drmFormatModifierCount;
        ptr[i].pDrmFormatModifiers = nullptr;
        if (src[start_index + i].pDrmFormatModifiers) {
            ptr[i].pDrmFormatModifiers = CopyArray<>(src[start_index + i].pDrmFormatModifiers, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageDrmFormatModifierExplicitCreateInfoEXT*
CommandRecorder::CopyArray<VkImageDrmFormatModifierExplicitCreateInfoEXT>(
    const VkImageDrmFormatModifierExplicitCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
        ptr[i].drmFormatModifierPlaneCount = src[start_index + i].drmFormatModifierPlaneCount;
        ptr[i].pPlaneLayouts = nullptr;
        if (src[start_index + i].pPlaneLayouts) {
            ptr[i].pPlaneLayouts = CopyArray<>(src[start_index + i].pPlaneLayouts, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageDrmFormatModifierPropertiesEXT* CommandRecorder::CopyArray<VkImageDrmFormatModifierPropertiesEXT>(
    const VkImageDrmFormatModifierPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageDrmFormatModifierPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkImageDrmFormatModifierPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
    }
    return ptr;
}

template <>
VkDrmFormatModifierProperties2EXT* CommandRecorder::CopyArray<VkDrmFormatModifierProperties2EXT>(
    const VkDrmFormatModifierProperties2EXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrmFormatModifierProperties2EXT*>(
        m_allocator.Alloc(sizeof(VkDrmFormatModifierProperties2EXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
        ptr[i].drmFormatModifierPlaneCount = src[start_index + i].drmFormatModifierPlaneCount;
        ptr[i].drmFormatModifierTilingFeatures = src[start_index + i].drmFormatModifierTilingFeatures;
    }
    return ptr;
}

template <>
VkDrmFormatModifierPropertiesList2EXT* CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesList2EXT>(
    const VkDrmFormatModifierPropertiesList2EXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrmFormatModifierPropertiesList2EXT*>(
        m_allocator.Alloc(sizeof(VkDrmFormatModifierPropertiesList2EXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].drmFormatModifierCount = src[start_index + i].drmFormatModifierCount;
        ptr[i].pDrmFormatModifierProperties = nullptr;
        if (src[start_index + i].pDrmFormatModifierProperties) {
            ptr[i].pDrmFormatModifierProperties = CopyArray<>(src[start_index + i].pDrmFormatModifierProperties, 0, 1);
        }
    }
    return ptr;
}

template <>
VkValidationCacheCreateInfoEXT* CommandRecorder::CopyArray<VkValidationCacheCreateInfoEXT>(
    const VkValidationCacheCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkValidationCacheCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkValidationCacheCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].initialDataSize = src[start_index + i].initialDataSize;
        ptr[i].pInitialData = src[start_index + i].pInitialData;
    }
    return ptr;
}

template <>
VkShaderModuleValidationCacheCreateInfoEXT* CommandRecorder::CopyArray<VkShaderModuleValidationCacheCreateInfoEXT>(
    const VkShaderModuleValidationCacheCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkShaderModuleValidationCacheCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkShaderModuleValidationCacheCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].validationCache = src[start_index + i].validationCache;
    }
    return ptr;
}

template <>
VkShadingRatePaletteNV* CommandRecorder::CopyArray<VkShadingRatePaletteNV>(const VkShadingRatePaletteNV* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkShadingRatePaletteNV*>(m_allocator.Alloc(sizeof(VkShadingRatePaletteNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].shadingRatePaletteEntryCount = src[start_index + i].shadingRatePaletteEntryCount;
        ptr[i].pShadingRatePaletteEntries = nullptr;
        if (src[start_index + i].pShadingRatePaletteEntries) {
            ptr[i].pShadingRatePaletteEntries = CopyArray<>(src[start_index + i].pShadingRatePaletteEntries, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineViewportShadingRateImageStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportShadingRateImageStateCreateInfoNV>(
    const VkPipelineViewportShadingRateImageStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportShadingRateImageStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shadingRateImageEnable = src[start_index + i].shadingRateImageEnable;
        ptr[i].viewportCount = src[start_index + i].viewportCount;
        ptr[i].pShadingRatePalettes = nullptr;
        if (src[start_index + i].pShadingRatePalettes) {
            ptr[i].pShadingRatePalettes = CopyArray<>(src[start_index + i].pShadingRatePalettes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceShadingRateImageFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShadingRateImageFeaturesNV>(
    const VkPhysicalDeviceShadingRateImageFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShadingRateImageFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shadingRateImage = src[start_index + i].shadingRateImage;
        ptr[i].shadingRateCoarseSampleOrder = src[start_index + i].shadingRateCoarseSampleOrder;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShadingRateImagePropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceShadingRateImagePropertiesNV>(
    const VkPhysicalDeviceShadingRateImagePropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShadingRateImagePropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shadingRateTexelSize = src[start_index + i].shadingRateTexelSize;
        ptr[i].shadingRatePaletteSize = src[start_index + i].shadingRatePaletteSize;
        ptr[i].shadingRateMaxCoarseSamples = src[start_index + i].shadingRateMaxCoarseSamples;
    }
    return ptr;
}

template <>
VkCoarseSampleLocationNV* CommandRecorder::CopyArray<VkCoarseSampleLocationNV>(const VkCoarseSampleLocationNV* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCoarseSampleLocationNV*>(m_allocator.Alloc(sizeof(VkCoarseSampleLocationNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].pixelX = src[start_index + i].pixelX;
        ptr[i].pixelY = src[start_index + i].pixelY;
        ptr[i].sample = src[start_index + i].sample;
    }
    return ptr;
}

template <>
VkCoarseSampleOrderCustomNV* CommandRecorder::CopyArray<VkCoarseSampleOrderCustomNV>(
    const VkCoarseSampleOrderCustomNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCoarseSampleOrderCustomNV*>(m_allocator.Alloc(sizeof(VkCoarseSampleOrderCustomNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].shadingRate = src[start_index + i].shadingRate;
        ptr[i].sampleCount = src[start_index + i].sampleCount;
        ptr[i].sampleLocationCount = src[start_index + i].sampleLocationCount;
        ptr[i].pSampleLocations = nullptr;
        if (src[start_index + i].pSampleLocations) {
            ptr[i].pSampleLocations = CopyArray<>(src[start_index + i].pSampleLocations, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(
    const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampleOrderType = src[start_index + i].sampleOrderType;
        ptr[i].customSampleOrderCount = src[start_index + i].customSampleOrderCount;
        ptr[i].pCustomSampleOrders = nullptr;
        if (src[start_index + i].pCustomSampleOrders) {
            ptr[i].pCustomSampleOrders = CopyArray<>(src[start_index + i].pCustomSampleOrders, 0, 1);
        }
    }
    return ptr;
}

template <>
VkRayTracingShaderGroupCreateInfoNV* CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoNV>(
    const VkRayTracingShaderGroupCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRayTracingShaderGroupCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkRayTracingShaderGroupCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].generalShader = src[start_index + i].generalShader;
        ptr[i].closestHitShader = src[start_index + i].closestHitShader;
        ptr[i].anyHitShader = src[start_index + i].anyHitShader;
        ptr[i].intersectionShader = src[start_index + i].intersectionShader;
    }
    return ptr;
}

template <>
VkRayTracingPipelineCreateInfoNV* CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoNV>(
    const VkRayTracingPipelineCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRayTracingPipelineCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkRayTracingPipelineCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stageCount = src[start_index + i].stageCount;
        ptr[i].pStages = nullptr;
        if (src[start_index + i].pStages) {
            ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
        }
        ptr[i].groupCount = src[start_index + i].groupCount;
        ptr[i].pGroups = nullptr;
        if (src[start_index + i].pGroups) {
            ptr[i].pGroups = CopyArray<>(src[start_index + i].pGroups, 0, 1);
        }
        ptr[i].maxRecursionDepth = src[start_index + i].maxRecursionDepth;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
        ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
    }
    return ptr;
}

template <>
VkGeometryTrianglesNV* CommandRecorder::CopyArray<VkGeometryTrianglesNV>(const VkGeometryTrianglesNV* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGeometryTrianglesNV*>(m_allocator.Alloc(sizeof(VkGeometryTrianglesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexData = src[start_index + i].vertexData;
        ptr[i].vertexOffset = src[start_index + i].vertexOffset;
        ptr[i].vertexCount = src[start_index + i].vertexCount;
        ptr[i].vertexStride = src[start_index + i].vertexStride;
        ptr[i].vertexFormat = src[start_index + i].vertexFormat;
        ptr[i].indexData = src[start_index + i].indexData;
        ptr[i].indexOffset = src[start_index + i].indexOffset;
        ptr[i].indexCount = src[start_index + i].indexCount;
        ptr[i].indexType = src[start_index + i].indexType;
        ptr[i].transformData = src[start_index + i].transformData;
        ptr[i].transformOffset = src[start_index + i].transformOffset;
    }
    return ptr;
}

template <>
VkGeometryAABBNV* CommandRecorder::CopyArray<VkGeometryAABBNV>(const VkGeometryAABBNV* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkGeometryAABBNV*>(m_allocator.Alloc(sizeof(VkGeometryAABBNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].aabbData = src[start_index + i].aabbData;
        ptr[i].numAABBs = src[start_index + i].numAABBs;
        ptr[i].stride = src[start_index + i].stride;
        ptr[i].offset = src[start_index + i].offset;
    }
    return ptr;
}

template <>
VkGeometryDataNV* CommandRecorder::CopyArray<VkGeometryDataNV>(const VkGeometryDataNV* src, uint64_t start_index,
                                                               uint64_t count) {
    auto ptr = reinterpret_cast<VkGeometryDataNV*>(m_allocator.Alloc(sizeof(VkGeometryDataNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].triangles = src[start_index + i].triangles;
        ptr[i].aabbs = src[start_index + i].aabbs;
    }
    return ptr;
}

template <>
VkGeometryNV* CommandRecorder::CopyArray<VkGeometryNV>(const VkGeometryNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGeometryNV*>(m_allocator.Alloc(sizeof(VkGeometryNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].geometryType = src[start_index + i].geometryType;
        ptr[i].geometry = src[start_index + i].geometry;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkAccelerationStructureInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureInfoNV>(
    const VkAccelerationStructureInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureInfoNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].instanceCount = src[start_index + i].instanceCount;
        ptr[i].geometryCount = src[start_index + i].geometryCount;
        ptr[i].pGeometries = nullptr;
        if (src[start_index + i].pGeometries) {
            ptr[i].pGeometries = CopyArray<>(src[start_index + i].pGeometries, 0, 1);
        }
    }
    return ptr;
}

template <>
VkAccelerationStructureCreateInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoNV>(
    const VkAccelerationStructureCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].compactedSize = src[start_index + i].compactedSize;
        ptr[i].info = src[start_index + i].info;
    }
    return ptr;
}

template <>
VkBindAccelerationStructureMemoryInfoNV* CommandRecorder::CopyArray<VkBindAccelerationStructureMemoryInfoNV>(
    const VkBindAccelerationStructureMemoryInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindAccelerationStructureMemoryInfoNV*>(
        m_allocator.Alloc(sizeof(VkBindAccelerationStructureMemoryInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].memoryOffset = src[start_index + i].memoryOffset;
        ptr[i].deviceIndexCount = src[start_index + i].deviceIndexCount;
        ptr[i].pDeviceIndices = nullptr;
        if (src[start_index + i].pDeviceIndices) {
            ptr[i].pDeviceIndices = CopyArray<>(src[start_index + i].pDeviceIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkWriteDescriptorSetAccelerationStructureNV* CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureNV>(
    const VkWriteDescriptorSetAccelerationStructureNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWriteDescriptorSetAccelerationStructureNV*>(
        m_allocator.Alloc(sizeof(VkWriteDescriptorSetAccelerationStructureNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructureCount = src[start_index + i].accelerationStructureCount;
        ptr[i].pAccelerationStructures = nullptr;
        if (src[start_index + i].pAccelerationStructures) {
            ptr[i].pAccelerationStructures = CopyArray<>(src[start_index + i].pAccelerationStructures, 0, 1);
        }
    }
    return ptr;
}

template <>
VkAccelerationStructureMemoryRequirementsInfoNV*
CommandRecorder::CopyArray<VkAccelerationStructureMemoryRequirementsInfoNV>(
    const VkAccelerationStructureMemoryRequirementsInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureMemoryRequirementsInfoNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureMemoryRequirementsInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPropertiesNV>(
    const VkPhysicalDeviceRayTracingPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderGroupHandleSize = src[start_index + i].shaderGroupHandleSize;
        ptr[i].maxRecursionDepth = src[start_index + i].maxRecursionDepth;
        ptr[i].maxShaderGroupStride = src[start_index + i].maxShaderGroupStride;
        ptr[i].shaderGroupBaseAlignment = src[start_index + i].shaderGroupBaseAlignment;
        ptr[i].maxGeometryCount = src[start_index + i].maxGeometryCount;
        ptr[i].maxInstanceCount = src[start_index + i].maxInstanceCount;
        ptr[i].maxTriangleCount = src[start_index + i].maxTriangleCount;
        ptr[i].maxDescriptorSetAccelerationStructures = src[start_index + i].maxDescriptorSetAccelerationStructures;
    }
    return ptr;
}

template <>
VkTransformMatrixKHR* CommandRecorder::CopyArray<VkTransformMatrixKHR>(const VkTransformMatrixKHR* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTransformMatrixKHR*>(m_allocator.Alloc(sizeof(VkTransformMatrixKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        std::memcpy(ptr[i].matrix, src[start_index + i].matrix, sizeof(src[start_index + i].matrix));
    }
    return ptr;
}

template <>
VkAabbPositionsKHR* CommandRecorder::CopyArray<VkAabbPositionsKHR>(const VkAabbPositionsKHR* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkAabbPositionsKHR*>(m_allocator.Alloc(sizeof(VkAabbPositionsKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].minX = src[start_index + i].minX;
        ptr[i].minY = src[start_index + i].minY;
        ptr[i].minZ = src[start_index + i].minZ;
        ptr[i].maxX = src[start_index + i].maxX;
        ptr[i].maxY = src[start_index + i].maxY;
        ptr[i].maxZ = src[start_index + i].maxZ;
    }
    return ptr;
}

template <>
VkAccelerationStructureInstanceKHR* CommandRecorder::CopyArray<VkAccelerationStructureInstanceKHR>(
    const VkAccelerationStructureInstanceKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureInstanceKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureInstanceKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].transform = src[start_index + i].transform;
        ptr[i].instanceCustomIndex = src[start_index + i].instanceCustomIndex;
        ptr[i].mask = src[start_index + i].mask;
        ptr[i].instanceShaderBindingTableRecordOffset = src[start_index + i].instanceShaderBindingTableRecordOffset;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].accelerationStructureReference = src[start_index + i].accelerationStructureReference;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(
    const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].representativeFragmentTest = src[start_index + i].representativeFragmentTest;
    }
    return ptr;
}

template <>
VkPipelineRepresentativeFragmentTestStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(
    const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineRepresentativeFragmentTestStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].representativeFragmentTestEnable = src[start_index + i].representativeFragmentTestEnable;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageViewImageFormatInfoEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImageViewImageFormatInfoEXT>(
    const VkPhysicalDeviceImageViewImageFormatInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageViewImageFormatInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageViewImageFormatInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageViewType = src[start_index + i].imageViewType;
    }
    return ptr;
}

template <>
VkFilterCubicImageViewImageFormatPropertiesEXT*
CommandRecorder::CopyArray<VkFilterCubicImageViewImageFormatPropertiesEXT>(
    const VkFilterCubicImageViewImageFormatPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFilterCubicImageViewImageFormatPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkFilterCubicImageViewImageFormatPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].filterCubic = src[start_index + i].filterCubic;
        ptr[i].filterCubicMinmax = src[start_index + i].filterCubicMinmax;
    }
    return ptr;
}

template <>
VkImportMemoryHostPointerInfoEXT* CommandRecorder::CopyArray<VkImportMemoryHostPointerInfoEXT>(
    const VkImportMemoryHostPointerInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryHostPointerInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImportMemoryHostPointerInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].pHostPointer = src[start_index + i].pHostPointer;
    }
    return ptr;
}

template <>
VkMemoryHostPointerPropertiesEXT* CommandRecorder::CopyArray<VkMemoryHostPointerPropertiesEXT>(
    const VkMemoryHostPointerPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryHostPointerPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkMemoryHostPointerPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalMemoryHostPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(
    const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minImportedHostPointerAlignment = src[start_index + i].minImportedHostPointerAlignment;
    }
    return ptr;
}

template <>
VkPipelineCompilerControlCreateInfoAMD* CommandRecorder::CopyArray<VkPipelineCompilerControlCreateInfoAMD>(
    const VkPipelineCompilerControlCreateInfoAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD*>(
        m_allocator.Alloc(sizeof(VkPipelineCompilerControlCreateInfoAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].compilerControlFlags = src[start_index + i].compilerControlFlags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderCorePropertiesAMD* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesAMD>(
    const VkPhysicalDeviceShaderCorePropertiesAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCorePropertiesAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderEngineCount = src[start_index + i].shaderEngineCount;
        ptr[i].shaderArraysPerEngineCount = src[start_index + i].shaderArraysPerEngineCount;
        ptr[i].computeUnitsPerShaderArray = src[start_index + i].computeUnitsPerShaderArray;
        ptr[i].simdPerComputeUnit = src[start_index + i].simdPerComputeUnit;
        ptr[i].wavefrontsPerSimd = src[start_index + i].wavefrontsPerSimd;
        ptr[i].wavefrontSize = src[start_index + i].wavefrontSize;
        ptr[i].sgprsPerSimd = src[start_index + i].sgprsPerSimd;
        ptr[i].minSgprAllocation = src[start_index + i].minSgprAllocation;
        ptr[i].maxSgprAllocation = src[start_index + i].maxSgprAllocation;
        ptr[i].sgprAllocationGranularity = src[start_index + i].sgprAllocationGranularity;
        ptr[i].vgprsPerSimd = src[start_index + i].vgprsPerSimd;
        ptr[i].minVgprAllocation = src[start_index + i].minVgprAllocation;
        ptr[i].maxVgprAllocation = src[start_index + i].maxVgprAllocation;
        ptr[i].vgprAllocationGranularity = src[start_index + i].vgprAllocationGranularity;
    }
    return ptr;
}

template <>
VkDeviceMemoryOverallocationCreateInfoAMD* CommandRecorder::CopyArray<VkDeviceMemoryOverallocationCreateInfoAMD>(
    const VkDeviceMemoryOverallocationCreateInfoAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD*>(
        m_allocator.Alloc(sizeof(VkDeviceMemoryOverallocationCreateInfoAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].overallocationBehavior = src[start_index + i].overallocationBehavior;
    }
    return ptr;
}

template <>
VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(
    const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxVertexAttribDivisor = src[start_index + i].maxVertexAttribDivisor;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_GGP
template <>
VkPresentFrameTokenGGP* CommandRecorder::CopyArray<VkPresentFrameTokenGGP>(const VkPresentFrameTokenGGP* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPresentFrameTokenGGP*>(m_allocator.Alloc(sizeof(VkPresentFrameTokenGGP) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].frameToken = src[start_index + i].frameToken;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_GGP

template <>
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(
    const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].computeDerivativeGroupQuads = src[start_index + i].computeDerivativeGroupQuads;
        ptr[i].computeDerivativeGroupLinear = src[start_index + i].computeDerivativeGroupLinear;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMeshShaderFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderFeaturesNV>(
    const VkPhysicalDeviceMeshShaderFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMeshShaderFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].taskShader = src[start_index + i].taskShader;
        ptr[i].meshShader = src[start_index + i].meshShader;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMeshShaderPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderPropertiesNV>(
    const VkPhysicalDeviceMeshShaderPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMeshShaderPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxDrawMeshTasksCount = src[start_index + i].maxDrawMeshTasksCount;
        ptr[i].maxTaskWorkGroupInvocations = src[start_index + i].maxTaskWorkGroupInvocations;
        std::memcpy(ptr[i].maxTaskWorkGroupSize, src[start_index + i].maxTaskWorkGroupSize,
                    sizeof(src[start_index + i].maxTaskWorkGroupSize));
        ptr[i].maxTaskTotalMemorySize = src[start_index + i].maxTaskTotalMemorySize;
        ptr[i].maxTaskOutputCount = src[start_index + i].maxTaskOutputCount;
        ptr[i].maxMeshWorkGroupInvocations = src[start_index + i].maxMeshWorkGroupInvocations;
        std::memcpy(ptr[i].maxMeshWorkGroupSize, src[start_index + i].maxMeshWorkGroupSize,
                    sizeof(src[start_index + i].maxMeshWorkGroupSize));
        ptr[i].maxMeshTotalMemorySize = src[start_index + i].maxMeshTotalMemorySize;
        ptr[i].maxMeshOutputVertices = src[start_index + i].maxMeshOutputVertices;
        ptr[i].maxMeshOutputPrimitives = src[start_index + i].maxMeshOutputPrimitives;
        ptr[i].maxMeshMultiviewViewCount = src[start_index + i].maxMeshMultiviewViewCount;
        ptr[i].meshOutputPerVertexGranularity = src[start_index + i].meshOutputPerVertexGranularity;
        ptr[i].meshOutputPerPrimitiveGranularity = src[start_index + i].meshOutputPerPrimitiveGranularity;
    }
    return ptr;
}

template <>
VkDrawMeshTasksIndirectCommandNV* CommandRecorder::CopyArray<VkDrawMeshTasksIndirectCommandNV>(
    const VkDrawMeshTasksIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrawMeshTasksIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkDrawMeshTasksIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].taskCount = src[start_index + i].taskCount;
        ptr[i].firstTask = src[start_index + i].firstTask;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderImageFootprintFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(
    const VkPhysicalDeviceShaderImageFootprintFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageFootprint = src[start_index + i].imageFootprint;
    }
    return ptr;
}

template <>
VkPipelineViewportExclusiveScissorStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(
    const VkPipelineViewportExclusiveScissorStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportExclusiveScissorStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].exclusiveScissorCount = src[start_index + i].exclusiveScissorCount;
        ptr[i].pExclusiveScissors = nullptr;
        if (src[start_index + i].pExclusiveScissors) {
            ptr[i].pExclusiveScissors = CopyArray<>(src[start_index + i].pExclusiveScissors, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceExclusiveScissorFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceExclusiveScissorFeaturesNV>(
    const VkPhysicalDeviceExclusiveScissorFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExclusiveScissorFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].exclusiveScissor = src[start_index + i].exclusiveScissor;
    }
    return ptr;
}

template <>
VkQueueFamilyCheckpointPropertiesNV* CommandRecorder::CopyArray<VkQueueFamilyCheckpointPropertiesNV>(
    const VkQueueFamilyCheckpointPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueueFamilyCheckpointPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkQueueFamilyCheckpointPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].checkpointExecutionStageMask = src[start_index + i].checkpointExecutionStageMask;
    }
    return ptr;
}

template <>
VkCheckpointDataNV* CommandRecorder::CopyArray<VkCheckpointDataNV>(const VkCheckpointDataNV* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkCheckpointDataNV*>(m_allocator.Alloc(sizeof(VkCheckpointDataNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stage = src[start_index + i].stage;
        ptr[i].pCheckpointMarker = src[start_index + i].pCheckpointMarker;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(
    const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderIntegerFunctions2 = src[start_index + i].shaderIntegerFunctions2;
    }
    return ptr;
}

template <>
VkPerformanceValueDataINTEL* CommandRecorder::CopyArray<VkPerformanceValueDataINTEL>(
    const VkPerformanceValueDataINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkPerformanceValueDataINTEL*>(m_allocator.Alloc(sizeof(VkPerformanceValueDataINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].value32 = src[start_index + i].value32;
        ptr[i].value64 = src[start_index + i].value64;
        ptr[i].valueFloat = src[start_index + i].valueFloat;
        ptr[i].valueBool = src[start_index + i].valueBool;
        ptr[i].valueString = nullptr;
        if (src[start_index + i].valueString) {
            ptr[i].valueString =
                CopyArray<>(src[start_index + i].valueString, 0, strlen(src[start_index + i].valueString) + 1);
        }
    }
    return ptr;
}

template <>
VkPerformanceValueINTEL* CommandRecorder::CopyArray<VkPerformanceValueINTEL>(const VkPerformanceValueINTEL* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceValueINTEL*>(m_allocator.Alloc(sizeof(VkPerformanceValueINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].type = src[start_index + i].type;
        ptr[i].data = src[start_index + i].data;
    }
    return ptr;
}

template <>
VkInitializePerformanceApiInfoINTEL* CommandRecorder::CopyArray<VkInitializePerformanceApiInfoINTEL>(
    const VkInitializePerformanceApiInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkInitializePerformanceApiInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkInitializePerformanceApiInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pUserData = src[start_index + i].pUserData;
    }
    return ptr;
}

template <>
VkQueryPoolPerformanceQueryCreateInfoINTEL* CommandRecorder::CopyArray<VkQueryPoolPerformanceQueryCreateInfoINTEL>(
    const VkQueryPoolPerformanceQueryCreateInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkQueryPoolPerformanceQueryCreateInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkQueryPoolPerformanceQueryCreateInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].performanceCountersSampling = src[start_index + i].performanceCountersSampling;
    }
    return ptr;
}

template <>
VkPerformanceMarkerInfoINTEL* CommandRecorder::CopyArray<VkPerformanceMarkerInfoINTEL>(
    const VkPerformanceMarkerInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceMarkerInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkPerformanceMarkerInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].marker = src[start_index + i].marker;
    }
    return ptr;
}

template <>
VkPerformanceStreamMarkerInfoINTEL* CommandRecorder::CopyArray<VkPerformanceStreamMarkerInfoINTEL>(
    const VkPerformanceStreamMarkerInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceStreamMarkerInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkPerformanceStreamMarkerInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].marker = src[start_index + i].marker;
    }
    return ptr;
}

template <>
VkPerformanceOverrideInfoINTEL* CommandRecorder::CopyArray<VkPerformanceOverrideInfoINTEL>(
    const VkPerformanceOverrideInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceOverrideInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkPerformanceOverrideInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].enable = src[start_index + i].enable;
        ptr[i].parameter = src[start_index + i].parameter;
    }
    return ptr;
}

template <>
VkPerformanceConfigurationAcquireInfoINTEL* CommandRecorder::CopyArray<VkPerformanceConfigurationAcquireInfoINTEL>(
    const VkPerformanceConfigurationAcquireInfoINTEL* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPerformanceConfigurationAcquireInfoINTEL*>(
        m_allocator.Alloc(sizeof(VkPerformanceConfigurationAcquireInfoINTEL) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
    }
    return ptr;
}

template <>
VkPhysicalDevicePCIBusInfoPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDevicePCIBusInfoPropertiesEXT>(
    const VkPhysicalDevicePCIBusInfoPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pciDomain = src[start_index + i].pciDomain;
        ptr[i].pciBus = src[start_index + i].pciBus;
        ptr[i].pciDevice = src[start_index + i].pciDevice;
        ptr[i].pciFunction = src[start_index + i].pciFunction;
    }
    return ptr;
}

template <>
VkDisplayNativeHdrSurfaceCapabilitiesAMD* CommandRecorder::CopyArray<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(
    const VkDisplayNativeHdrSurfaceCapabilitiesAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(
        m_allocator.Alloc(sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].localDimmingSupport = src[start_index + i].localDimmingSupport;
    }
    return ptr;
}

template <>
VkSwapchainDisplayNativeHdrCreateInfoAMD* CommandRecorder::CopyArray<VkSwapchainDisplayNativeHdrCreateInfoAMD>(
    const VkSwapchainDisplayNativeHdrCreateInfoAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD*>(
        m_allocator.Alloc(sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].localDimmingEnable = src[start_index + i].localDimmingEnable;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImagePipeSurfaceCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkImagePipeSurfaceCreateInfoFUCHSIA>(
    const VkImagePipeSurfaceCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImagePipeSurfaceCreateInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImagePipeSurfaceCreateInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].imagePipeHandle = src[start_index + i].imagePipeHandle;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkMetalSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkMetalSurfaceCreateInfoEXT>(
    const VkMetalSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMetalSurfaceCreateInfoEXT*>(m_allocator.Alloc(sizeof(VkMetalSurfaceCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pLayer = src[start_index + i].pLayer;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

template <>
VkPhysicalDeviceFragmentDensityMapFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(
    const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityMap = src[start_index + i].fragmentDensityMap;
        ptr[i].fragmentDensityMapDynamic = src[start_index + i].fragmentDensityMapDynamic;
        ptr[i].fragmentDensityMapNonSubsampledImages = src[start_index + i].fragmentDensityMapNonSubsampledImages;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentDensityMapPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(
    const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minFragmentDensityTexelSize = src[start_index + i].minFragmentDensityTexelSize;
        ptr[i].maxFragmentDensityTexelSize = src[start_index + i].maxFragmentDensityTexelSize;
        ptr[i].fragmentDensityInvocations = src[start_index + i].fragmentDensityInvocations;
    }
    return ptr;
}

template <>
VkRenderPassFragmentDensityMapCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassFragmentDensityMapCreateInfoEXT>(
    const VkRenderPassFragmentDensityMapCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityMapAttachment = src[start_index + i].fragmentDensityMapAttachment;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderCoreProperties2AMD* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreProperties2AMD>(
    const VkPhysicalDeviceShaderCoreProperties2AMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCoreProperties2AMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderCoreFeatures = src[start_index + i].shaderCoreFeatures;
        ptr[i].activeComputeUnitCount = src[start_index + i].activeComputeUnitCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCoherentMemoryFeaturesAMD* CommandRecorder::CopyArray<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(
    const VkPhysicalDeviceCoherentMemoryFeaturesAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceCoherentMemory = src[start_index + i].deviceCoherentMemory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(
    const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderImageInt64Atomics = src[start_index + i].shaderImageInt64Atomics;
        ptr[i].sparseImageInt64Atomics = src[start_index + i].sparseImageInt64Atomics;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryBudgetPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(
    const VkPhysicalDeviceMemoryBudgetPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].heapBudget, src[start_index + i].heapBudget, sizeof(src[start_index + i].heapBudget));
        std::memcpy(ptr[i].heapUsage, src[start_index + i].heapUsage, sizeof(src[start_index + i].heapUsage));
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryPriorityFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(
    const VkPhysicalDeviceMemoryPriorityFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryPriority = src[start_index + i].memoryPriority;
    }
    return ptr;
}

template <>
VkMemoryPriorityAllocateInfoEXT* CommandRecorder::CopyArray<VkMemoryPriorityAllocateInfoEXT>(
    const VkMemoryPriorityAllocateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryPriorityAllocateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkMemoryPriorityAllocateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].priority = src[start_index + i].priority;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(
    const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dedicatedAllocationImageAliasing = src[start_index + i].dedicatedAllocationImageAliasing;
    }
    return ptr;
}

template <>
VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(
    const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].bufferDeviceAddress = src[start_index + i].bufferDeviceAddress;
        ptr[i].bufferDeviceAddressCaptureReplay = src[start_index + i].bufferDeviceAddressCaptureReplay;
        ptr[i].bufferDeviceAddressMultiDevice = src[start_index + i].bufferDeviceAddressMultiDevice;
    }
    return ptr;
}

template <>
VkBufferDeviceAddressCreateInfoEXT* CommandRecorder::CopyArray<VkBufferDeviceAddressCreateInfoEXT>(
    const VkBufferDeviceAddressCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferDeviceAddressCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkBufferDeviceAddressCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
    }
    return ptr;
}

template <>
VkValidationFeaturesEXT* CommandRecorder::CopyArray<VkValidationFeaturesEXT>(const VkValidationFeaturesEXT* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkValidationFeaturesEXT*>(m_allocator.Alloc(sizeof(VkValidationFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].enabledValidationFeatureCount = src[start_index + i].enabledValidationFeatureCount;
        ptr[i].pEnabledValidationFeatures = nullptr;
        if (src[start_index + i].pEnabledValidationFeatures) {
            ptr[i].pEnabledValidationFeatures = CopyArray<>(src[start_index + i].pEnabledValidationFeatures, 0, 1);
        }
        ptr[i].disabledValidationFeatureCount = src[start_index + i].disabledValidationFeatureCount;
        ptr[i].pDisabledValidationFeatures = nullptr;
        if (src[start_index + i].pDisabledValidationFeatures) {
            ptr[i].pDisabledValidationFeatures = CopyArray<>(src[start_index + i].pDisabledValidationFeatures, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCooperativeMatrixPropertiesNV* CommandRecorder::CopyArray<VkCooperativeMatrixPropertiesNV>(
    const VkCooperativeMatrixPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCooperativeMatrixPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkCooperativeMatrixPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].MSize = src[start_index + i].MSize;
        ptr[i].NSize = src[start_index + i].NSize;
        ptr[i].KSize = src[start_index + i].KSize;
        ptr[i].AType = src[start_index + i].AType;
        ptr[i].BType = src[start_index + i].BType;
        ptr[i].CType = src[start_index + i].CType;
        ptr[i].DType = src[start_index + i].DType;
        ptr[i].scope = src[start_index + i].scope;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCooperativeMatrixFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(
    const VkPhysicalDeviceCooperativeMatrixFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cooperativeMatrix = src[start_index + i].cooperativeMatrix;
        ptr[i].cooperativeMatrixRobustBufferAccess = src[start_index + i].cooperativeMatrixRobustBufferAccess;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCooperativeMatrixPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(
    const VkPhysicalDeviceCooperativeMatrixPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cooperativeMatrixSupportedStages = src[start_index + i].cooperativeMatrixSupportedStages;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCoverageReductionModeFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(
    const VkPhysicalDeviceCoverageReductionModeFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].coverageReductionMode = src[start_index + i].coverageReductionMode;
    }
    return ptr;
}

template <>
VkPipelineCoverageReductionStateCreateInfoNV* CommandRecorder::CopyArray<VkPipelineCoverageReductionStateCreateInfoNV>(
    const VkPipelineCoverageReductionStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineCoverageReductionStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineCoverageReductionStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].coverageReductionMode = src[start_index + i].coverageReductionMode;
    }
    return ptr;
}

template <>
VkFramebufferMixedSamplesCombinationNV* CommandRecorder::CopyArray<VkFramebufferMixedSamplesCombinationNV>(
    const VkFramebufferMixedSamplesCombinationNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkFramebufferMixedSamplesCombinationNV*>(
        m_allocator.Alloc(sizeof(VkFramebufferMixedSamplesCombinationNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].coverageReductionMode = src[start_index + i].coverageReductionMode;
        ptr[i].rasterizationSamples = src[start_index + i].rasterizationSamples;
        ptr[i].depthStencilSamples = src[start_index + i].depthStencilSamples;
        ptr[i].colorSamples = src[start_index + i].colorSamples;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(
    const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentShaderSampleInterlock = src[start_index + i].fragmentShaderSampleInterlock;
        ptr[i].fragmentShaderPixelInterlock = src[start_index + i].fragmentShaderPixelInterlock;
        ptr[i].fragmentShaderShadingRateInterlock = src[start_index + i].fragmentShaderShadingRateInterlock;
    }
    return ptr;
}

template <>
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(
    const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].ycbcrImageArrays = src[start_index + i].ycbcrImageArrays;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProvokingVertexFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexFeaturesEXT>(
    const VkPhysicalDeviceProvokingVertexFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].provokingVertexLast = src[start_index + i].provokingVertexLast;
        ptr[i].transformFeedbackPreservesProvokingVertex =
            src[start_index + i].transformFeedbackPreservesProvokingVertex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceProvokingVertexPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexPropertiesEXT>(
    const VkPhysicalDeviceProvokingVertexPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].provokingVertexModePerPipeline = src[start_index + i].provokingVertexModePerPipeline;
        ptr[i].transformFeedbackPreservesTriangleFanProvokingVertex =
            src[start_index + i].transformFeedbackPreservesTriangleFanProvokingVertex;
    }
    return ptr;
}

template <>
VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(
    const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].provokingVertexMode = src[start_index + i].provokingVertexMode;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceFullScreenExclusiveInfoEXT* CommandRecorder::CopyArray<VkSurfaceFullScreenExclusiveInfoEXT>(
    const VkSurfaceFullScreenExclusiveInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceFullScreenExclusiveInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSurfaceFullScreenExclusiveInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fullScreenExclusive = src[start_index + i].fullScreenExclusive;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceCapabilitiesFullScreenExclusiveEXT* CommandRecorder::CopyArray<VkSurfaceCapabilitiesFullScreenExclusiveEXT>(
    const VkSurfaceCapabilitiesFullScreenExclusiveEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(
        m_allocator.Alloc(sizeof(VkSurfaceCapabilitiesFullScreenExclusiveEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fullScreenExclusiveSupported = src[start_index + i].fullScreenExclusiveSupported;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

#ifdef VK_USE_PLATFORM_WIN32_KHR
template <>
VkSurfaceFullScreenExclusiveWin32InfoEXT* CommandRecorder::CopyArray<VkSurfaceFullScreenExclusiveWin32InfoEXT>(
    const VkSurfaceFullScreenExclusiveWin32InfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceFullScreenExclusiveWin32InfoEXT*>(
        m_allocator.Alloc(sizeof(VkSurfaceFullScreenExclusiveWin32InfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hmonitor = src[start_index + i].hmonitor;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_WIN32_KHR

template <>
VkHeadlessSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkHeadlessSurfaceCreateInfoEXT>(
    const VkHeadlessSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkHeadlessSurfaceCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkHeadlessSurfaceCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>(
    const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderBufferFloat32Atomics = src[start_index + i].shaderBufferFloat32Atomics;
        ptr[i].shaderBufferFloat32AtomicAdd = src[start_index + i].shaderBufferFloat32AtomicAdd;
        ptr[i].shaderBufferFloat64Atomics = src[start_index + i].shaderBufferFloat64Atomics;
        ptr[i].shaderBufferFloat64AtomicAdd = src[start_index + i].shaderBufferFloat64AtomicAdd;
        ptr[i].shaderSharedFloat32Atomics = src[start_index + i].shaderSharedFloat32Atomics;
        ptr[i].shaderSharedFloat32AtomicAdd = src[start_index + i].shaderSharedFloat32AtomicAdd;
        ptr[i].shaderSharedFloat64Atomics = src[start_index + i].shaderSharedFloat64Atomics;
        ptr[i].shaderSharedFloat64AtomicAdd = src[start_index + i].shaderSharedFloat64AtomicAdd;
        ptr[i].shaderImageFloat32Atomics = src[start_index + i].shaderImageFloat32Atomics;
        ptr[i].shaderImageFloat32AtomicAdd = src[start_index + i].shaderImageFloat32AtomicAdd;
        ptr[i].sparseImageFloat32Atomics = src[start_index + i].sparseImageFloat32Atomics;
        ptr[i].sparseImageFloat32AtomicAdd = src[start_index + i].sparseImageFloat32AtomicAdd;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].extendedDynamicState = src[start_index + i].extendedDynamicState;
    }
    return ptr;
}

template <>
VkPhysicalDeviceHostImageCopyFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceHostImageCopyFeaturesEXT>(
    const VkPhysicalDeviceHostImageCopyFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceHostImageCopyFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceHostImageCopyFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hostImageCopy = src[start_index + i].hostImageCopy;
    }
    return ptr;
}

template <>
VkPhysicalDeviceHostImageCopyPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceHostImageCopyPropertiesEXT>(
    const VkPhysicalDeviceHostImageCopyPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceHostImageCopyPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceHostImageCopyPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].copySrcLayoutCount = src[start_index + i].copySrcLayoutCount;
        ptr[i].pCopySrcLayouts = nullptr;
        if (src[start_index + i].pCopySrcLayouts) {
            ptr[i].pCopySrcLayouts = CopyArray<>(src[start_index + i].pCopySrcLayouts, 0, 1);
        }
        ptr[i].copyDstLayoutCount = src[start_index + i].copyDstLayoutCount;
        ptr[i].pCopyDstLayouts = nullptr;
        if (src[start_index + i].pCopyDstLayouts) {
            ptr[i].pCopyDstLayouts = CopyArray<>(src[start_index + i].pCopyDstLayouts, 0, 1);
        }
        std::memcpy(ptr[i].optimalTilingLayoutUUID, src[start_index + i].optimalTilingLayoutUUID,
                    sizeof(src[start_index + i].optimalTilingLayoutUUID));
        ptr[i].identicalMemoryTypeRequirements = src[start_index + i].identicalMemoryTypeRequirements;
    }
    return ptr;
}

template <>
VkMemoryToImageCopyEXT* CommandRecorder::CopyArray<VkMemoryToImageCopyEXT>(const VkMemoryToImageCopyEXT* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryToImageCopyEXT*>(m_allocator.Alloc(sizeof(VkMemoryToImageCopyEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pHostPointer = src[start_index + i].pHostPointer;
        ptr[i].memoryRowLength = src[start_index + i].memoryRowLength;
        ptr[i].memoryImageHeight = src[start_index + i].memoryImageHeight;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
        ptr[i].imageOffset = src[start_index + i].imageOffset;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkImageToMemoryCopyEXT* CommandRecorder::CopyArray<VkImageToMemoryCopyEXT>(const VkImageToMemoryCopyEXT* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageToMemoryCopyEXT*>(m_allocator.Alloc(sizeof(VkImageToMemoryCopyEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pHostPointer = src[start_index + i].pHostPointer;
        ptr[i].memoryRowLength = src[start_index + i].memoryRowLength;
        ptr[i].memoryImageHeight = src[start_index + i].memoryImageHeight;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
        ptr[i].imageOffset = src[start_index + i].imageOffset;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkCopyMemoryToImageInfoEXT* CommandRecorder::CopyArray<VkCopyMemoryToImageInfoEXT>(
    const VkCopyMemoryToImageInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCopyMemoryToImageInfoEXT*>(m_allocator.Alloc(sizeof(VkCopyMemoryToImageInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyImageToMemoryInfoEXT* CommandRecorder::CopyArray<VkCopyImageToMemoryInfoEXT>(
    const VkCopyImageToMemoryInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCopyImageToMemoryInfoEXT*>(m_allocator.Alloc(sizeof(VkCopyImageToMemoryInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyImageToImageInfoEXT* CommandRecorder::CopyArray<VkCopyImageToImageInfoEXT>(const VkCopyImageToImageInfoEXT* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCopyImageToImageInfoEXT*>(m_allocator.Alloc(sizeof(VkCopyImageToImageInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].srcImage = src[start_index + i].srcImage;
        ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
        ptr[i].dstImage = src[start_index + i].dstImage;
        ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkHostImageLayoutTransitionInfoEXT* CommandRecorder::CopyArray<VkHostImageLayoutTransitionInfoEXT>(
    const VkHostImageLayoutTransitionInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkHostImageLayoutTransitionInfoEXT*>(
        m_allocator.Alloc(sizeof(VkHostImageLayoutTransitionInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].oldLayout = src[start_index + i].oldLayout;
        ptr[i].newLayout = src[start_index + i].newLayout;
        ptr[i].subresourceRange = src[start_index + i].subresourceRange;
    }
    return ptr;
}

template <>
VkSubresourceHostMemcpySizeEXT* CommandRecorder::CopyArray<VkSubresourceHostMemcpySizeEXT>(
    const VkSubresourceHostMemcpySizeEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubresourceHostMemcpySizeEXT*>(
        m_allocator.Alloc(sizeof(VkSubresourceHostMemcpySizeEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkHostImageCopyDevicePerformanceQueryEXT* CommandRecorder::CopyArray<VkHostImageCopyDevicePerformanceQueryEXT>(
    const VkHostImageCopyDevicePerformanceQueryEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkHostImageCopyDevicePerformanceQueryEXT*>(
        m_allocator.Alloc(sizeof(VkHostImageCopyDevicePerformanceQueryEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].optimalDeviceAccess = src[start_index + i].optimalDeviceAccess;
        ptr[i].identicalMemoryLayout = src[start_index + i].identicalMemoryLayout;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>(
    const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMapMemoryPlacedFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryMapPlaced = src[start_index + i].memoryMapPlaced;
        ptr[i].memoryMapRangePlaced = src[start_index + i].memoryMapRangePlaced;
        ptr[i].memoryUnmapReserve = src[start_index + i].memoryUnmapReserve;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>(
    const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMapMemoryPlacedPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minPlacedMemoryMapAlignment = src[start_index + i].minPlacedMemoryMapAlignment;
    }
    return ptr;
}

template <>
VkMemoryMapPlacedInfoEXT* CommandRecorder::CopyArray<VkMemoryMapPlacedInfoEXT>(const VkMemoryMapPlacedInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryMapPlacedInfoEXT*>(m_allocator.Alloc(sizeof(VkMemoryMapPlacedInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pPlacedAddress = src[start_index + i].pPlacedAddress;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>(
    const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderBufferFloat16Atomics = src[start_index + i].shaderBufferFloat16Atomics;
        ptr[i].shaderBufferFloat16AtomicAdd = src[start_index + i].shaderBufferFloat16AtomicAdd;
        ptr[i].shaderBufferFloat16AtomicMinMax = src[start_index + i].shaderBufferFloat16AtomicMinMax;
        ptr[i].shaderBufferFloat32AtomicMinMax = src[start_index + i].shaderBufferFloat32AtomicMinMax;
        ptr[i].shaderBufferFloat64AtomicMinMax = src[start_index + i].shaderBufferFloat64AtomicMinMax;
        ptr[i].shaderSharedFloat16Atomics = src[start_index + i].shaderSharedFloat16Atomics;
        ptr[i].shaderSharedFloat16AtomicAdd = src[start_index + i].shaderSharedFloat16AtomicAdd;
        ptr[i].shaderSharedFloat16AtomicMinMax = src[start_index + i].shaderSharedFloat16AtomicMinMax;
        ptr[i].shaderSharedFloat32AtomicMinMax = src[start_index + i].shaderSharedFloat32AtomicMinMax;
        ptr[i].shaderSharedFloat64AtomicMinMax = src[start_index + i].shaderSharedFloat64AtomicMinMax;
        ptr[i].shaderImageFloat32AtomicMinMax = src[start_index + i].shaderImageFloat32AtomicMinMax;
        ptr[i].sparseImageFloat32AtomicMinMax = src[start_index + i].sparseImageFloat32AtomicMinMax;
    }
    return ptr;
}

template <>
VkSurfacePresentModeEXT* CommandRecorder::CopyArray<VkSurfacePresentModeEXT>(const VkSurfacePresentModeEXT* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfacePresentModeEXT*>(m_allocator.Alloc(sizeof(VkSurfacePresentModeEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentMode = src[start_index + i].presentMode;
    }
    return ptr;
}

template <>
VkSurfacePresentScalingCapabilitiesEXT* CommandRecorder::CopyArray<VkSurfacePresentScalingCapabilitiesEXT>(
    const VkSurfacePresentScalingCapabilitiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfacePresentScalingCapabilitiesEXT*>(
        m_allocator.Alloc(sizeof(VkSurfacePresentScalingCapabilitiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportedPresentScaling = src[start_index + i].supportedPresentScaling;
        ptr[i].supportedPresentGravityX = src[start_index + i].supportedPresentGravityX;
        ptr[i].supportedPresentGravityY = src[start_index + i].supportedPresentGravityY;
        ptr[i].minScaledImageExtent = src[start_index + i].minScaledImageExtent;
        ptr[i].maxScaledImageExtent = src[start_index + i].maxScaledImageExtent;
    }
    return ptr;
}

template <>
VkSurfacePresentModeCompatibilityEXT* CommandRecorder::CopyArray<VkSurfacePresentModeCompatibilityEXT>(
    const VkSurfacePresentModeCompatibilityEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfacePresentModeCompatibilityEXT*>(
        m_allocator.Alloc(sizeof(VkSurfacePresentModeCompatibilityEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentModeCount = src[start_index + i].presentModeCount;
        ptr[i].pPresentModes = nullptr;
        if (src[start_index + i].pPresentModes) {
            ptr[i].pPresentModes = CopyArray<>(src[start_index + i].pPresentModes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT>(
    const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainMaintenance1 = src[start_index + i].swapchainMaintenance1;
    }
    return ptr;
}

template <>
VkSwapchainPresentFenceInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentFenceInfoEXT>(
    const VkSwapchainPresentFenceInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainPresentFenceInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSwapchainPresentFenceInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pFences = nullptr;
        if (src[start_index + i].pFences) {
            ptr[i].pFences = CopyArray<>(src[start_index + i].pFences, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSwapchainPresentModesCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentModesCreateInfoEXT>(
    const VkSwapchainPresentModesCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainPresentModesCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSwapchainPresentModesCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentModeCount = src[start_index + i].presentModeCount;
        ptr[i].pPresentModes = nullptr;
        if (src[start_index + i].pPresentModes) {
            ptr[i].pPresentModes = CopyArray<>(src[start_index + i].pPresentModes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSwapchainPresentModeInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentModeInfoEXT>(
    const VkSwapchainPresentModeInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainPresentModeInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSwapchainPresentModeInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchainCount = src[start_index + i].swapchainCount;
        ptr[i].pPresentModes = nullptr;
        if (src[start_index + i].pPresentModes) {
            ptr[i].pPresentModes = CopyArray<>(src[start_index + i].pPresentModes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkSwapchainPresentScalingCreateInfoEXT* CommandRecorder::CopyArray<VkSwapchainPresentScalingCreateInfoEXT>(
    const VkSwapchainPresentScalingCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainPresentScalingCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSwapchainPresentScalingCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].scalingBehavior = src[start_index + i].scalingBehavior;
        ptr[i].presentGravityX = src[start_index + i].presentGravityX;
        ptr[i].presentGravityY = src[start_index + i].presentGravityY;
    }
    return ptr;
}

template <>
VkReleaseSwapchainImagesInfoEXT* CommandRecorder::CopyArray<VkReleaseSwapchainImagesInfoEXT>(
    const VkReleaseSwapchainImagesInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkReleaseSwapchainImagesInfoEXT*>(
        m_allocator.Alloc(sizeof(VkReleaseSwapchainImagesInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].swapchain = src[start_index + i].swapchain;
        ptr[i].imageIndexCount = src[start_index + i].imageIndexCount;
        ptr[i].pImageIndices = nullptr;
        if (src[start_index + i].pImageIndices) {
            ptr[i].pImageIndices = CopyArray<>(src[start_index + i].pImageIndices, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxGraphicsShaderGroupCount = src[start_index + i].maxGraphicsShaderGroupCount;
        ptr[i].maxIndirectSequenceCount = src[start_index + i].maxIndirectSequenceCount;
        ptr[i].maxIndirectCommandsTokenCount = src[start_index + i].maxIndirectCommandsTokenCount;
        ptr[i].maxIndirectCommandsStreamCount = src[start_index + i].maxIndirectCommandsStreamCount;
        ptr[i].maxIndirectCommandsTokenOffset = src[start_index + i].maxIndirectCommandsTokenOffset;
        ptr[i].maxIndirectCommandsStreamStride = src[start_index + i].maxIndirectCommandsStreamStride;
        ptr[i].minSequencesCountBufferOffsetAlignment = src[start_index + i].minSequencesCountBufferOffsetAlignment;
        ptr[i].minSequencesIndexBufferOffsetAlignment = src[start_index + i].minSequencesIndexBufferOffsetAlignment;
        ptr[i].minIndirectCommandsBufferOffsetAlignment = src[start_index + i].minIndirectCommandsBufferOffsetAlignment;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceGeneratedCommands = src[start_index + i].deviceGeneratedCommands;
    }
    return ptr;
}

template <>
VkGraphicsShaderGroupCreateInfoNV* CommandRecorder::CopyArray<VkGraphicsShaderGroupCreateInfoNV>(
    const VkGraphicsShaderGroupCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGraphicsShaderGroupCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkGraphicsShaderGroupCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stageCount = src[start_index + i].stageCount;
        ptr[i].pStages = nullptr;
        if (src[start_index + i].pStages) {
            ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
        }
        ptr[i].pVertexInputState = src[start_index + i].pVertexInputState;
        ptr[i].pTessellationState = src[start_index + i].pTessellationState;
    }
    return ptr;
}

template <>
VkGraphicsPipelineShaderGroupsCreateInfoNV* CommandRecorder::CopyArray<VkGraphicsPipelineShaderGroupsCreateInfoNV>(
    const VkGraphicsPipelineShaderGroupsCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGraphicsPipelineShaderGroupsCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkGraphicsPipelineShaderGroupsCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].groupCount = src[start_index + i].groupCount;
        ptr[i].pGroups = nullptr;
        if (src[start_index + i].pGroups) {
            ptr[i].pGroups = CopyArray<>(src[start_index + i].pGroups, 0, 1);
        }
        ptr[i].pipelineCount = src[start_index + i].pipelineCount;
        ptr[i].pPipelines = nullptr;
        if (src[start_index + i].pPipelines) {
            ptr[i].pPipelines = CopyArray<>(src[start_index + i].pPipelines, 0, 1);
        }
    }
    return ptr;
}

template <>
VkBindShaderGroupIndirectCommandNV* CommandRecorder::CopyArray<VkBindShaderGroupIndirectCommandNV>(
    const VkBindShaderGroupIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindShaderGroupIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkBindShaderGroupIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].groupIndex = src[start_index + i].groupIndex;
    }
    return ptr;
}

template <>
VkBindIndexBufferIndirectCommandNV* CommandRecorder::CopyArray<VkBindIndexBufferIndirectCommandNV>(
    const VkBindIndexBufferIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindIndexBufferIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkBindIndexBufferIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].bufferAddress = src[start_index + i].bufferAddress;
        ptr[i].size = src[start_index + i].size;
        ptr[i].indexType = src[start_index + i].indexType;
    }
    return ptr;
}

template <>
VkBindVertexBufferIndirectCommandNV* CommandRecorder::CopyArray<VkBindVertexBufferIndirectCommandNV>(
    const VkBindVertexBufferIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindVertexBufferIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkBindVertexBufferIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].bufferAddress = src[start_index + i].bufferAddress;
        ptr[i].size = src[start_index + i].size;
        ptr[i].stride = src[start_index + i].stride;
    }
    return ptr;
}

template <>
VkSetStateFlagsIndirectCommandNV* CommandRecorder::CopyArray<VkSetStateFlagsIndirectCommandNV>(
    const VkSetStateFlagsIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSetStateFlagsIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkSetStateFlagsIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].data = src[start_index + i].data;
    }
    return ptr;
}

template <>
VkIndirectCommandsStreamNV* CommandRecorder::CopyArray<VkIndirectCommandsStreamNV>(
    const VkIndirectCommandsStreamNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkIndirectCommandsStreamNV*>(m_allocator.Alloc(sizeof(VkIndirectCommandsStreamNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
    }
    return ptr;
}

template <>
VkIndirectCommandsLayoutTokenNV* CommandRecorder::CopyArray<VkIndirectCommandsLayoutTokenNV>(
    const VkIndirectCommandsLayoutTokenNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkIndirectCommandsLayoutTokenNV*>(
        m_allocator.Alloc(sizeof(VkIndirectCommandsLayoutTokenNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].tokenType = src[start_index + i].tokenType;
        ptr[i].stream = src[start_index + i].stream;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].vertexBindingUnit = src[start_index + i].vertexBindingUnit;
        ptr[i].vertexDynamicStride = src[start_index + i].vertexDynamicStride;
        ptr[i].pushconstantPipelineLayout = src[start_index + i].pushconstantPipelineLayout;
        ptr[i].pushconstantShaderStageFlags = src[start_index + i].pushconstantShaderStageFlags;
        ptr[i].pushconstantOffset = src[start_index + i].pushconstantOffset;
        ptr[i].pushconstantSize = src[start_index + i].pushconstantSize;
        ptr[i].indirectStateFlags = src[start_index + i].indirectStateFlags;
        ptr[i].indexTypeCount = src[start_index + i].indexTypeCount;
        ptr[i].pIndexTypes = nullptr;
        if (src[start_index + i].pIndexTypes) {
            ptr[i].pIndexTypes = CopyArray<>(src[start_index + i].pIndexTypes, 0, 1);
        }
        ptr[i].pIndexTypeValues = nullptr;
        if (src[start_index + i].pIndexTypeValues) {
            ptr[i].pIndexTypeValues = CopyArray<>(src[start_index + i].pIndexTypeValues, 0, 1);
        }
    }
    return ptr;
}

template <>
VkIndirectCommandsLayoutCreateInfoNV* CommandRecorder::CopyArray<VkIndirectCommandsLayoutCreateInfoNV>(
    const VkIndirectCommandsLayoutCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkIndirectCommandsLayoutCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkIndirectCommandsLayoutCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].tokenCount = src[start_index + i].tokenCount;
        ptr[i].pTokens = nullptr;
        if (src[start_index + i].pTokens) {
            ptr[i].pTokens = CopyArray<>(src[start_index + i].pTokens, 0, 1);
        }
        ptr[i].streamCount = src[start_index + i].streamCount;
        ptr[i].pStreamStrides = nullptr;
        if (src[start_index + i].pStreamStrides) {
            ptr[i].pStreamStrides = CopyArray<>(src[start_index + i].pStreamStrides, 0, 1);
        }
    }
    return ptr;
}

template <>
VkGeneratedCommandsInfoNV* CommandRecorder::CopyArray<VkGeneratedCommandsInfoNV>(const VkGeneratedCommandsInfoNV* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkGeneratedCommandsInfoNV*>(m_allocator.Alloc(sizeof(VkGeneratedCommandsInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].pipeline = src[start_index + i].pipeline;
        ptr[i].indirectCommandsLayout = src[start_index + i].indirectCommandsLayout;
        ptr[i].streamCount = src[start_index + i].streamCount;
        ptr[i].pStreams = nullptr;
        if (src[start_index + i].pStreams) {
            ptr[i].pStreams = CopyArray<>(src[start_index + i].pStreams, 0, 1);
        }
        ptr[i].sequencesCount = src[start_index + i].sequencesCount;
        ptr[i].preprocessBuffer = src[start_index + i].preprocessBuffer;
        ptr[i].preprocessOffset = src[start_index + i].preprocessOffset;
        ptr[i].preprocessSize = src[start_index + i].preprocessSize;
        ptr[i].sequencesCountBuffer = src[start_index + i].sequencesCountBuffer;
        ptr[i].sequencesCountOffset = src[start_index + i].sequencesCountOffset;
        ptr[i].sequencesIndexBuffer = src[start_index + i].sequencesIndexBuffer;
        ptr[i].sequencesIndexOffset = src[start_index + i].sequencesIndexOffset;
    }
    return ptr;
}

template <>
VkGeneratedCommandsMemoryRequirementsInfoNV* CommandRecorder::CopyArray<VkGeneratedCommandsMemoryRequirementsInfoNV>(
    const VkGeneratedCommandsMemoryRequirementsInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGeneratedCommandsMemoryRequirementsInfoNV*>(
        m_allocator.Alloc(sizeof(VkGeneratedCommandsMemoryRequirementsInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].pipeline = src[start_index + i].pipeline;
        ptr[i].indirectCommandsLayout = src[start_index + i].indirectCommandsLayout;
        ptr[i].maxSequencesCount = src[start_index + i].maxSequencesCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceInheritedViewportScissorFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>(
    const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].inheritedViewportScissor2D = src[start_index + i].inheritedViewportScissor2D;
    }
    return ptr;
}

template <>
VkCommandBufferInheritanceViewportScissorInfoNV*
CommandRecorder::CopyArray<VkCommandBufferInheritanceViewportScissorInfoNV>(
    const VkCommandBufferInheritanceViewportScissorInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceViewportScissorInfoNV*>(
        m_allocator.Alloc(sizeof(VkCommandBufferInheritanceViewportScissorInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].viewportScissor2D = src[start_index + i].viewportScissor2D;
        ptr[i].viewportDepthCount = src[start_index + i].viewportDepthCount;
        ptr[i].pViewportDepths = src[start_index + i].pViewportDepths;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(
    const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].texelBufferAlignment = src[start_index + i].texelBufferAlignment;
    }
    return ptr;
}

template <>
VkRenderPassTransformBeginInfoQCOM* CommandRecorder::CopyArray<VkRenderPassTransformBeginInfoQCOM>(
    const VkRenderPassTransformBeginInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassTransformBeginInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkRenderPassTransformBeginInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].transform = src[start_index + i].transform;
    }
    return ptr;
}

template <>
VkCommandBufferInheritanceRenderPassTransformInfoQCOM*
CommandRecorder::CopyArray<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>(
    const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCommandBufferInheritanceRenderPassTransformInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkCommandBufferInheritanceRenderPassTransformInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].transform = src[start_index + i].transform;
        ptr[i].renderArea = src[start_index + i].renderArea;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDepthBiasControlFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthBiasControlFeaturesEXT>(
    const VkPhysicalDeviceDepthBiasControlFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthBiasControl = src[start_index + i].depthBiasControl;
        ptr[i].leastRepresentableValueForceUnormRepresentation =
            src[start_index + i].leastRepresentableValueForceUnormRepresentation;
        ptr[i].floatRepresentation = src[start_index + i].floatRepresentation;
        ptr[i].depthBiasExact = src[start_index + i].depthBiasExact;
    }
    return ptr;
}

template <>
VkDepthBiasInfoEXT* CommandRecorder::CopyArray<VkDepthBiasInfoEXT>(const VkDepthBiasInfoEXT* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkDepthBiasInfoEXT*>(m_allocator.Alloc(sizeof(VkDepthBiasInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthBiasConstantFactor = src[start_index + i].depthBiasConstantFactor;
        ptr[i].depthBiasClamp = src[start_index + i].depthBiasClamp;
        ptr[i].depthBiasSlopeFactor = src[start_index + i].depthBiasSlopeFactor;
    }
    return ptr;
}

template <>
VkDepthBiasRepresentationInfoEXT* CommandRecorder::CopyArray<VkDepthBiasRepresentationInfoEXT>(
    const VkDepthBiasRepresentationInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDepthBiasRepresentationInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDepthBiasRepresentationInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthBiasRepresentation = src[start_index + i].depthBiasRepresentation;
        ptr[i].depthBiasExact = src[start_index + i].depthBiasExact;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(
    const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceMemoryReport = src[start_index + i].deviceMemoryReport;
    }
    return ptr;
}

template <>
VkDeviceMemoryReportCallbackDataEXT* CommandRecorder::CopyArray<VkDeviceMemoryReportCallbackDataEXT>(
    const VkDeviceMemoryReportCallbackDataEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceMemoryReportCallbackDataEXT*>(
        m_allocator.Alloc(sizeof(VkDeviceMemoryReportCallbackDataEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].type = src[start_index + i].type;
        ptr[i].memoryObjectId = src[start_index + i].memoryObjectId;
        ptr[i].size = src[start_index + i].size;
        ptr[i].objectType = src[start_index + i].objectType;
        ptr[i].objectHandle = src[start_index + i].objectHandle;
        ptr[i].heapIndex = src[start_index + i].heapIndex;
    }
    return ptr;
}

template <>
VkDeviceDeviceMemoryReportCreateInfoEXT* CommandRecorder::CopyArray<VkDeviceDeviceMemoryReportCreateInfoEXT>(
    const VkDeviceDeviceMemoryReportCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pfnUserCallback = src[start_index + i].pfnUserCallback;
        ptr[i].pUserData = src[start_index + i].pUserData;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRobustness2FeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2FeaturesEXT>(
    const VkPhysicalDeviceRobustness2FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRobustness2FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].robustBufferAccess2 = src[start_index + i].robustBufferAccess2;
        ptr[i].robustImageAccess2 = src[start_index + i].robustImageAccess2;
        ptr[i].nullDescriptor = src[start_index + i].nullDescriptor;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRobustness2PropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2PropertiesEXT>(
    const VkPhysicalDeviceRobustness2PropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRobustness2PropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].robustStorageBufferAccessSizeAlignment = src[start_index + i].robustStorageBufferAccessSizeAlignment;
        ptr[i].robustUniformBufferAccessSizeAlignment = src[start_index + i].robustUniformBufferAccessSizeAlignment;
    }
    return ptr;
}

template <>
VkSamplerCustomBorderColorCreateInfoEXT* CommandRecorder::CopyArray<VkSamplerCustomBorderColorCreateInfoEXT>(
    const VkSamplerCustomBorderColorCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSamplerCustomBorderColorCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].customBorderColor = src[start_index + i].customBorderColor;
        ptr[i].format = src[start_index + i].format;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCustomBorderColorPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(
    const VkPhysicalDeviceCustomBorderColorPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxCustomBorderColorSamplers = src[start_index + i].maxCustomBorderColorSamplers;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCustomBorderColorFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(
    const VkPhysicalDeviceCustomBorderColorFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].customBorderColors = src[start_index + i].customBorderColors;
        ptr[i].customBorderColorWithoutFormat = src[start_index + i].customBorderColorWithoutFormat;
    }
    return ptr;
}

template <>
VkPhysicalDevicePresentBarrierFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDevicePresentBarrierFeaturesNV>(
    const VkPhysicalDevicePresentBarrierFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePresentBarrierFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePresentBarrierFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentBarrier = src[start_index + i].presentBarrier;
    }
    return ptr;
}

template <>
VkSurfaceCapabilitiesPresentBarrierNV* CommandRecorder::CopyArray<VkSurfaceCapabilitiesPresentBarrierNV>(
    const VkSurfaceCapabilitiesPresentBarrierNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSurfaceCapabilitiesPresentBarrierNV*>(
        m_allocator.Alloc(sizeof(VkSurfaceCapabilitiesPresentBarrierNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentBarrierSupported = src[start_index + i].presentBarrierSupported;
    }
    return ptr;
}

template <>
VkSwapchainPresentBarrierCreateInfoNV* CommandRecorder::CopyArray<VkSwapchainPresentBarrierCreateInfoNV>(
    const VkSwapchainPresentBarrierCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainPresentBarrierCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkSwapchainPresentBarrierCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentBarrierEnable = src[start_index + i].presentBarrierEnable;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDiagnosticsConfigFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>(
    const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].diagnosticsConfig = src[start_index + i].diagnosticsConfig;
    }
    return ptr;
}

template <>
VkDeviceDiagnosticsConfigCreateInfoNV* CommandRecorder::CopyArray<VkDeviceDiagnosticsConfigCreateInfoNV>(
    const VkDeviceDiagnosticsConfigCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceDiagnosticsConfigCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkDeviceDiagnosticsConfigCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkCudaModuleCreateInfoNV* CommandRecorder::CopyArray<VkCudaModuleCreateInfoNV>(const VkCudaModuleCreateInfoNV* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCudaModuleCreateInfoNV*>(m_allocator.Alloc(sizeof(VkCudaModuleCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dataSize = src[start_index + i].dataSize;
        ptr[i].pData = src[start_index + i].pData;
    }
    return ptr;
}

template <>
VkCudaFunctionCreateInfoNV* CommandRecorder::CopyArray<VkCudaFunctionCreateInfoNV>(
    const VkCudaFunctionCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkCudaFunctionCreateInfoNV*>(m_allocator.Alloc(sizeof(VkCudaFunctionCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].module = src[start_index + i].module;
        ptr[i].pName = nullptr;
        if (src[start_index + i].pName) {
            ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName) + 1);
        }
    }
    return ptr;
}

template <>
VkCudaLaunchInfoNV* CommandRecorder::CopyArray<VkCudaLaunchInfoNV>(const VkCudaLaunchInfoNV* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkCudaLaunchInfoNV*>(m_allocator.Alloc(sizeof(VkCudaLaunchInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].function = src[start_index + i].function;
        ptr[i].gridDimX = src[start_index + i].gridDimX;
        ptr[i].gridDimY = src[start_index + i].gridDimY;
        ptr[i].gridDimZ = src[start_index + i].gridDimZ;
        ptr[i].blockDimX = src[start_index + i].blockDimX;
        ptr[i].blockDimY = src[start_index + i].blockDimY;
        ptr[i].blockDimZ = src[start_index + i].blockDimZ;
        ptr[i].sharedMemBytes = src[start_index + i].sharedMemBytes;
        ptr[i].paramCount = src[start_index + i].paramCount;
        ptr[i].pParams = src[start_index + i].pParams;
        ptr[i].extraCount = src[start_index + i].extraCount;
        ptr[i].pExtras = src[start_index + i].pExtras;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCudaKernelLaunchFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCudaKernelLaunchFeaturesNV>(
    const VkPhysicalDeviceCudaKernelLaunchFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCudaKernelLaunchFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCudaKernelLaunchFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cudaKernelLaunchFeatures = src[start_index + i].cudaKernelLaunchFeatures;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCudaKernelLaunchPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCudaKernelLaunchPropertiesNV>(
    const VkPhysicalDeviceCudaKernelLaunchPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCudaKernelLaunchPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCudaKernelLaunchPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].computeCapabilityMinor = src[start_index + i].computeCapabilityMinor;
        ptr[i].computeCapabilityMajor = src[start_index + i].computeCapabilityMajor;
    }
    return ptr;
}

template <>
VkQueryLowLatencySupportNV* CommandRecorder::CopyArray<VkQueryLowLatencySupportNV>(
    const VkQueryLowLatencySupportNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkQueryLowLatencySupportNV*>(m_allocator.Alloc(sizeof(VkQueryLowLatencySupportNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pQueriedLowLatencyData = src[start_index + i].pQueriedLowLatencyData;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalObjectCreateInfoEXT* CommandRecorder::CopyArray<VkExportMetalObjectCreateInfoEXT>(
    const VkExportMetalObjectCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMetalObjectCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkExportMetalObjectCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].exportObjectType = src[start_index + i].exportObjectType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalObjectsInfoEXT* CommandRecorder::CopyArray<VkExportMetalObjectsInfoEXT>(
    const VkExportMetalObjectsInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportMetalObjectsInfoEXT*>(m_allocator.Alloc(sizeof(VkExportMetalObjectsInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalDeviceInfoEXT* CommandRecorder::CopyArray<VkExportMetalDeviceInfoEXT>(
    const VkExportMetalDeviceInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportMetalDeviceInfoEXT*>(m_allocator.Alloc(sizeof(VkExportMetalDeviceInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mtlDevice = src[start_index + i].mtlDevice;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalCommandQueueInfoEXT* CommandRecorder::CopyArray<VkExportMetalCommandQueueInfoEXT>(
    const VkExportMetalCommandQueueInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMetalCommandQueueInfoEXT*>(
        m_allocator.Alloc(sizeof(VkExportMetalCommandQueueInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queue = src[start_index + i].queue;
        ptr[i].mtlCommandQueue = src[start_index + i].mtlCommandQueue;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalBufferInfoEXT* CommandRecorder::CopyArray<VkExportMetalBufferInfoEXT>(
    const VkExportMetalBufferInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportMetalBufferInfoEXT*>(m_allocator.Alloc(sizeof(VkExportMetalBufferInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].mtlBuffer = src[start_index + i].mtlBuffer;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalBufferInfoEXT* CommandRecorder::CopyArray<VkImportMetalBufferInfoEXT>(
    const VkImportMetalBufferInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImportMetalBufferInfoEXT*>(m_allocator.Alloc(sizeof(VkImportMetalBufferInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mtlBuffer = src[start_index + i].mtlBuffer;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalTextureInfoEXT* CommandRecorder::CopyArray<VkExportMetalTextureInfoEXT>(
    const VkExportMetalTextureInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkExportMetalTextureInfoEXT*>(m_allocator.Alloc(sizeof(VkExportMetalTextureInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].imageView = src[start_index + i].imageView;
        ptr[i].bufferView = src[start_index + i].bufferView;
        ptr[i].plane = src[start_index + i].plane;
        ptr[i].mtlTexture = src[start_index + i].mtlTexture;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalTextureInfoEXT* CommandRecorder::CopyArray<VkImportMetalTextureInfoEXT>(
    const VkImportMetalTextureInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImportMetalTextureInfoEXT*>(m_allocator.Alloc(sizeof(VkImportMetalTextureInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].plane = src[start_index + i].plane;
        ptr[i].mtlTexture = src[start_index + i].mtlTexture;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalIOSurfaceInfoEXT* CommandRecorder::CopyArray<VkExportMetalIOSurfaceInfoEXT>(
    const VkExportMetalIOSurfaceInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMetalIOSurfaceInfoEXT*>(
        m_allocator.Alloc(sizeof(VkExportMetalIOSurfaceInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
        ptr[i].ioSurface = src[start_index + i].ioSurface;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalIOSurfaceInfoEXT* CommandRecorder::CopyArray<VkImportMetalIOSurfaceInfoEXT>(
    const VkImportMetalIOSurfaceInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMetalIOSurfaceInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImportMetalIOSurfaceInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].ioSurface = src[start_index + i].ioSurface;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkExportMetalSharedEventInfoEXT* CommandRecorder::CopyArray<VkExportMetalSharedEventInfoEXT>(
    const VkExportMetalSharedEventInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExportMetalSharedEventInfoEXT*>(
        m_allocator.Alloc(sizeof(VkExportMetalSharedEventInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].event = src[start_index + i].event;
        ptr[i].mtlSharedEvent = src[start_index + i].mtlSharedEvent;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

#ifdef VK_USE_PLATFORM_METAL_EXT
template <>
VkImportMetalSharedEventInfoEXT* CommandRecorder::CopyArray<VkImportMetalSharedEventInfoEXT>(
    const VkImportMetalSharedEventInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMetalSharedEventInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImportMetalSharedEventInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mtlSharedEvent = src[start_index + i].mtlSharedEvent;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_METAL_EXT

template <>
VkPhysicalDeviceDescriptorBufferPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferPropertiesEXT>(
    const VkPhysicalDeviceDescriptorBufferPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorBufferPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].combinedImageSamplerDescriptorSingleArray =
            src[start_index + i].combinedImageSamplerDescriptorSingleArray;
        ptr[i].bufferlessPushDescriptors = src[start_index + i].bufferlessPushDescriptors;
        ptr[i].allowSamplerImageViewPostSubmitCreation = src[start_index + i].allowSamplerImageViewPostSubmitCreation;
        ptr[i].descriptorBufferOffsetAlignment = src[start_index + i].descriptorBufferOffsetAlignment;
        ptr[i].maxDescriptorBufferBindings = src[start_index + i].maxDescriptorBufferBindings;
        ptr[i].maxResourceDescriptorBufferBindings = src[start_index + i].maxResourceDescriptorBufferBindings;
        ptr[i].maxSamplerDescriptorBufferBindings = src[start_index + i].maxSamplerDescriptorBufferBindings;
        ptr[i].maxEmbeddedImmutableSamplerBindings = src[start_index + i].maxEmbeddedImmutableSamplerBindings;
        ptr[i].maxEmbeddedImmutableSamplers = src[start_index + i].maxEmbeddedImmutableSamplers;
        ptr[i].bufferCaptureReplayDescriptorDataSize = src[start_index + i].bufferCaptureReplayDescriptorDataSize;
        ptr[i].imageCaptureReplayDescriptorDataSize = src[start_index + i].imageCaptureReplayDescriptorDataSize;
        ptr[i].imageViewCaptureReplayDescriptorDataSize = src[start_index + i].imageViewCaptureReplayDescriptorDataSize;
        ptr[i].samplerCaptureReplayDescriptorDataSize = src[start_index + i].samplerCaptureReplayDescriptorDataSize;
        ptr[i].accelerationStructureCaptureReplayDescriptorDataSize =
            src[start_index + i].accelerationStructureCaptureReplayDescriptorDataSize;
        ptr[i].samplerDescriptorSize = src[start_index + i].samplerDescriptorSize;
        ptr[i].combinedImageSamplerDescriptorSize = src[start_index + i].combinedImageSamplerDescriptorSize;
        ptr[i].sampledImageDescriptorSize = src[start_index + i].sampledImageDescriptorSize;
        ptr[i].storageImageDescriptorSize = src[start_index + i].storageImageDescriptorSize;
        ptr[i].uniformTexelBufferDescriptorSize = src[start_index + i].uniformTexelBufferDescriptorSize;
        ptr[i].robustUniformTexelBufferDescriptorSize = src[start_index + i].robustUniformTexelBufferDescriptorSize;
        ptr[i].storageTexelBufferDescriptorSize = src[start_index + i].storageTexelBufferDescriptorSize;
        ptr[i].robustStorageTexelBufferDescriptorSize = src[start_index + i].robustStorageTexelBufferDescriptorSize;
        ptr[i].uniformBufferDescriptorSize = src[start_index + i].uniformBufferDescriptorSize;
        ptr[i].robustUniformBufferDescriptorSize = src[start_index + i].robustUniformBufferDescriptorSize;
        ptr[i].storageBufferDescriptorSize = src[start_index + i].storageBufferDescriptorSize;
        ptr[i].robustStorageBufferDescriptorSize = src[start_index + i].robustStorageBufferDescriptorSize;
        ptr[i].inputAttachmentDescriptorSize = src[start_index + i].inputAttachmentDescriptorSize;
        ptr[i].accelerationStructureDescriptorSize = src[start_index + i].accelerationStructureDescriptorSize;
        ptr[i].maxSamplerDescriptorBufferRange = src[start_index + i].maxSamplerDescriptorBufferRange;
        ptr[i].maxResourceDescriptorBufferRange = src[start_index + i].maxResourceDescriptorBufferRange;
        ptr[i].samplerDescriptorBufferAddressSpaceSize = src[start_index + i].samplerDescriptorBufferAddressSpaceSize;
        ptr[i].resourceDescriptorBufferAddressSpaceSize = src[start_index + i].resourceDescriptorBufferAddressSpaceSize;
        ptr[i].descriptorBufferAddressSpaceSize = src[start_index + i].descriptorBufferAddressSpaceSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>(
    const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].combinedImageSamplerDensityMapDescriptorSize =
            src[start_index + i].combinedImageSamplerDensityMapDescriptorSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorBufferFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorBufferFeaturesEXT>(
    const VkPhysicalDeviceDescriptorBufferFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorBufferFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorBuffer = src[start_index + i].descriptorBuffer;
        ptr[i].descriptorBufferCaptureReplay = src[start_index + i].descriptorBufferCaptureReplay;
        ptr[i].descriptorBufferImageLayoutIgnored = src[start_index + i].descriptorBufferImageLayoutIgnored;
        ptr[i].descriptorBufferPushDescriptors = src[start_index + i].descriptorBufferPushDescriptors;
    }
    return ptr;
}

template <>
VkDescriptorAddressInfoEXT* CommandRecorder::CopyArray<VkDescriptorAddressInfoEXT>(
    const VkDescriptorAddressInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDescriptorAddressInfoEXT*>(m_allocator.Alloc(sizeof(VkDescriptorAddressInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].address = src[start_index + i].address;
        ptr[i].range = src[start_index + i].range;
        ptr[i].format = src[start_index + i].format;
    }
    return ptr;
}

template <>
VkDescriptorBufferBindingInfoEXT* CommandRecorder::CopyArray<VkDescriptorBufferBindingInfoEXT>(
    const VkDescriptorBufferBindingInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorBufferBindingInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDescriptorBufferBindingInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].address = src[start_index + i].address;
        ptr[i].usage = src[start_index + i].usage;
    }
    return ptr;
}

template <>
VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*
CommandRecorder::CopyArray<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>(
    const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT*>(
        m_allocator.Alloc(sizeof(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkDescriptorDataEXT* CommandRecorder::CopyArray<VkDescriptorDataEXT>(const VkDescriptorDataEXT* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorDataEXT*>(m_allocator.Alloc(sizeof(VkDescriptorDataEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].pSampler = src[start_index + i].pSampler;
        ptr[i].pCombinedImageSampler = src[start_index + i].pCombinedImageSampler;
        ptr[i].pInputAttachmentImage = src[start_index + i].pInputAttachmentImage;
        ptr[i].pSampledImage = src[start_index + i].pSampledImage;
        ptr[i].pStorageImage = src[start_index + i].pStorageImage;
        ptr[i].pUniformTexelBuffer = src[start_index + i].pUniformTexelBuffer;
        ptr[i].pStorageTexelBuffer = src[start_index + i].pStorageTexelBuffer;
        ptr[i].pUniformBuffer = src[start_index + i].pUniformBuffer;
        ptr[i].pStorageBuffer = src[start_index + i].pStorageBuffer;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
    }
    return ptr;
}

template <>
VkDescriptorGetInfoEXT* CommandRecorder::CopyArray<VkDescriptorGetInfoEXT>(const VkDescriptorGetInfoEXT* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorGetInfoEXT*>(m_allocator.Alloc(sizeof(VkDescriptorGetInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].data = src[start_index + i].data;
    }
    return ptr;
}

template <>
VkBufferCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkBufferCaptureDescriptorDataInfoEXT>(
    const VkBufferCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCaptureDescriptorDataInfoEXT*>(
        m_allocator.Alloc(sizeof(VkBufferCaptureDescriptorDataInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}

template <>
VkImageCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkImageCaptureDescriptorDataInfoEXT>(
    const VkImageCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCaptureDescriptorDataInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageCaptureDescriptorDataInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image = src[start_index + i].image;
    }
    return ptr;
}

template <>
VkImageViewCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkImageViewCaptureDescriptorDataInfoEXT>(
    const VkImageViewCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewCaptureDescriptorDataInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageViewCaptureDescriptorDataInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageView = src[start_index + i].imageView;
    }
    return ptr;
}

template <>
VkSamplerCaptureDescriptorDataInfoEXT* CommandRecorder::CopyArray<VkSamplerCaptureDescriptorDataInfoEXT>(
    const VkSamplerCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerCaptureDescriptorDataInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSamplerCaptureDescriptorDataInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sampler = src[start_index + i].sampler;
    }
    return ptr;
}

template <>
VkOpaqueCaptureDescriptorDataCreateInfoEXT* CommandRecorder::CopyArray<VkOpaqueCaptureDescriptorDataCreateInfoEXT>(
    const VkOpaqueCaptureDescriptorDataCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOpaqueCaptureDescriptorDataCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkOpaqueCaptureDescriptorDataCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].opaqueCaptureDescriptorData = src[start_index + i].opaqueCaptureDescriptorData;
    }
    return ptr;
}

template <>
VkAccelerationStructureCaptureDescriptorDataInfoEXT*
CommandRecorder::CopyArray<VkAccelerationStructureCaptureDescriptorDataInfoEXT>(
    const VkAccelerationStructureCaptureDescriptorDataInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureCaptureDescriptorDataInfoEXT*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureCaptureDescriptorDataInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
        ptr[i].accelerationStructureNV = src[start_index + i].accelerationStructureNV;
    }
    return ptr;
}

template <>
VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>(
    const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].graphicsPipelineLibrary = src[start_index + i].graphicsPipelineLibrary;
    }
    return ptr;
}

template <>
VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>(
    const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].graphicsPipelineLibraryFastLinking = src[start_index + i].graphicsPipelineLibraryFastLinking;
        ptr[i].graphicsPipelineLibraryIndependentInterpolationDecoration =
            src[start_index + i].graphicsPipelineLibraryIndependentInterpolationDecoration;
    }
    return ptr;
}

template <>
VkGraphicsPipelineLibraryCreateInfoEXT* CommandRecorder::CopyArray<VkGraphicsPipelineLibraryCreateInfoEXT>(
    const VkGraphicsPipelineLibraryCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGraphicsPipelineLibraryCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkGraphicsPipelineLibraryCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>(
    const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderEarlyAndLateFragmentTests = src[start_index + i].shaderEarlyAndLateFragmentTests;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>(
    const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentShadingRateEnums = src[start_index + i].fragmentShadingRateEnums;
        ptr[i].supersampleFragmentShadingRates = src[start_index + i].supersampleFragmentShadingRates;
        ptr[i].noInvocationFragmentShadingRates = src[start_index + i].noInvocationFragmentShadingRates;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>(
    const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxFragmentShadingRateInvocationCount = src[start_index + i].maxFragmentShadingRateInvocationCount;
    }
    return ptr;
}

template <>
VkPipelineFragmentShadingRateEnumStateCreateInfoNV*
CommandRecorder::CopyArray<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>(
    const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineFragmentShadingRateEnumStateCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineFragmentShadingRateEnumStateCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shadingRateType = src[start_index + i].shadingRateType;
        ptr[i].shadingRate = src[start_index + i].shadingRate;
        std::memcpy(ptr[i].combinerOps, src[start_index + i].combinerOps, sizeof(src[start_index + i].combinerOps));
    }
    return ptr;
}

template <>
VkDeviceOrHostAddressConstKHR* CommandRecorder::CopyArray<VkDeviceOrHostAddressConstKHR>(
    const VkDeviceOrHostAddressConstKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceOrHostAddressConstKHR*>(
        m_allocator.Alloc(sizeof(VkDeviceOrHostAddressConstKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].hostAddress = src[start_index + i].hostAddress;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryMotionTrianglesDataNV*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryMotionTrianglesDataNV>(
    const VkAccelerationStructureGeometryMotionTrianglesDataNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryMotionTrianglesDataNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryMotionTrianglesDataNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexData = src[start_index + i].vertexData;
    }
    return ptr;
}

template <>
VkAccelerationStructureMotionInfoNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInfoNV>(
    const VkAccelerationStructureMotionInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureMotionInfoNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureMotionInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxInstances = src[start_index + i].maxInstances;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkAccelerationStructureMatrixMotionInstanceNV*
CommandRecorder::CopyArray<VkAccelerationStructureMatrixMotionInstanceNV>(
    const VkAccelerationStructureMatrixMotionInstanceNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureMatrixMotionInstanceNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureMatrixMotionInstanceNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].transformT0 = src[start_index + i].transformT0;
        ptr[i].transformT1 = src[start_index + i].transformT1;
        ptr[i].instanceCustomIndex = src[start_index + i].instanceCustomIndex;
        ptr[i].mask = src[start_index + i].mask;
        ptr[i].instanceShaderBindingTableRecordOffset = src[start_index + i].instanceShaderBindingTableRecordOffset;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].accelerationStructureReference = src[start_index + i].accelerationStructureReference;
    }
    return ptr;
}

template <>
VkSRTDataNV* CommandRecorder::CopyArray<VkSRTDataNV>(const VkSRTDataNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSRTDataNV*>(m_allocator.Alloc(sizeof(VkSRTDataNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sx = src[start_index + i].sx;
        ptr[i].a = src[start_index + i].a;
        ptr[i].b = src[start_index + i].b;
        ptr[i].pvx = src[start_index + i].pvx;
        ptr[i].sy = src[start_index + i].sy;
        ptr[i].c = src[start_index + i].c;
        ptr[i].pvy = src[start_index + i].pvy;
        ptr[i].sz = src[start_index + i].sz;
        ptr[i].pvz = src[start_index + i].pvz;
        ptr[i].qx = src[start_index + i].qx;
        ptr[i].qy = src[start_index + i].qy;
        ptr[i].qz = src[start_index + i].qz;
        ptr[i].qw = src[start_index + i].qw;
        ptr[i].tx = src[start_index + i].tx;
        ptr[i].ty = src[start_index + i].ty;
        ptr[i].tz = src[start_index + i].tz;
    }
    return ptr;
}

template <>
VkAccelerationStructureSRTMotionInstanceNV* CommandRecorder::CopyArray<VkAccelerationStructureSRTMotionInstanceNV>(
    const VkAccelerationStructureSRTMotionInstanceNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureSRTMotionInstanceNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureSRTMotionInstanceNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].transformT0 = src[start_index + i].transformT0;
        ptr[i].transformT1 = src[start_index + i].transformT1;
        ptr[i].instanceCustomIndex = src[start_index + i].instanceCustomIndex;
        ptr[i].mask = src[start_index + i].mask;
        ptr[i].instanceShaderBindingTableRecordOffset = src[start_index + i].instanceShaderBindingTableRecordOffset;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].accelerationStructureReference = src[start_index + i].accelerationStructureReference;
    }
    return ptr;
}

template <>
VkAccelerationStructureMotionInstanceDataNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInstanceDataNV>(
    const VkAccelerationStructureMotionInstanceDataNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureMotionInstanceDataNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureMotionInstanceDataNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].staticInstance = src[start_index + i].staticInstance;
        ptr[i].matrixMotionInstance = src[start_index + i].matrixMotionInstance;
        ptr[i].srtMotionInstance = src[start_index + i].srtMotionInstance;
    }
    return ptr;
}

template <>
VkAccelerationStructureMotionInstanceNV* CommandRecorder::CopyArray<VkAccelerationStructureMotionInstanceNV>(
    const VkAccelerationStructureMotionInstanceNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureMotionInstanceNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureMotionInstanceNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].type = src[start_index + i].type;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].data = src[start_index + i].data;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>(
    const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingMotionBlur = src[start_index + i].rayTracingMotionBlur;
        ptr[i].rayTracingMotionBlurPipelineTraceRaysIndirect =
            src[start_index + i].rayTracingMotionBlurPipelineTraceRaysIndirect;
    }
    return ptr;
}

template <>
VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(
    const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].ycbcr2plane444Formats = src[start_index + i].ycbcr2plane444Formats;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(
    const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityMapDeferred = src[start_index + i].fragmentDensityMapDeferred;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(
    const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subsampledLoads = src[start_index + i].subsampledLoads;
        ptr[i].subsampledCoarseReconstructionEarlyAccess =
            src[start_index + i].subsampledCoarseReconstructionEarlyAccess;
        ptr[i].maxSubsampledArrayLayers = src[start_index + i].maxSubsampledArrayLayers;
        ptr[i].maxDescriptorSetSubsampledSamplers = src[start_index + i].maxDescriptorSetSubsampledSamplers;
    }
    return ptr;
}

template <>
VkCopyCommandTransformInfoQCOM* CommandRecorder::CopyArray<VkCopyCommandTransformInfoQCOM>(
    const VkCopyCommandTransformInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyCommandTransformInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkCopyCommandTransformInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].transform = src[start_index + i].transform;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageCompressionControlFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageCompressionControlFeaturesEXT>(
    const VkPhysicalDeviceImageCompressionControlFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageCompressionControl = src[start_index + i].imageCompressionControl;
    }
    return ptr;
}

template <>
VkImageCompressionControlEXT* CommandRecorder::CopyArray<VkImageCompressionControlEXT>(
    const VkImageCompressionControlEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCompressionControlEXT*>(
        m_allocator.Alloc(sizeof(VkImageCompressionControlEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].compressionControlPlaneCount = src[start_index + i].compressionControlPlaneCount;
        ptr[i].pFixedRateFlags = nullptr;
        if (src[start_index + i].pFixedRateFlags) {
            ptr[i].pFixedRateFlags = CopyArray<>(src[start_index + i].pFixedRateFlags, 0, 1);
        }
    }
    return ptr;
}

template <>
VkImageCompressionPropertiesEXT* CommandRecorder::CopyArray<VkImageCompressionPropertiesEXT>(
    const VkImageCompressionPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageCompressionPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkImageCompressionPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageCompressionFlags = src[start_index + i].imageCompressionFlags;
        ptr[i].imageCompressionFixedRateFlags = src[start_index + i].imageCompressionFixedRateFlags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>(
    const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentFeedbackLoopLayout = src[start_index + i].attachmentFeedbackLoopLayout;
    }
    return ptr;
}

template <>
VkPhysicalDevice4444FormatsFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDevice4444FormatsFeaturesEXT>(
    const VkPhysicalDevice4444FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevice4444FormatsFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].formatA4R4G4B4 = src[start_index + i].formatA4R4G4B4;
        ptr[i].formatA4B4G4R4 = src[start_index + i].formatA4B4G4R4;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFaultFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceFaultFeaturesEXT>(
    const VkPhysicalDeviceFaultFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFaultFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFaultFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceFault = src[start_index + i].deviceFault;
        ptr[i].deviceFaultVendorBinary = src[start_index + i].deviceFaultVendorBinary;
    }
    return ptr;
}

template <>
VkDeviceFaultCountsEXT* CommandRecorder::CopyArray<VkDeviceFaultCountsEXT>(const VkDeviceFaultCountsEXT* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceFaultCountsEXT*>(m_allocator.Alloc(sizeof(VkDeviceFaultCountsEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].addressInfoCount = src[start_index + i].addressInfoCount;
        ptr[i].vendorInfoCount = src[start_index + i].vendorInfoCount;
        ptr[i].vendorBinarySize = src[start_index + i].vendorBinarySize;
    }
    return ptr;
}

template <>
VkDeviceFaultAddressInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultAddressInfoEXT>(
    const VkDeviceFaultAddressInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDeviceFaultAddressInfoEXT*>(m_allocator.Alloc(sizeof(VkDeviceFaultAddressInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].addressType = src[start_index + i].addressType;
        ptr[i].reportedAddress = src[start_index + i].reportedAddress;
        ptr[i].addressPrecision = src[start_index + i].addressPrecision;
    }
    return ptr;
}

template <>
VkDeviceFaultVendorInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultVendorInfoEXT>(
    const VkDeviceFaultVendorInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDeviceFaultVendorInfoEXT*>(m_allocator.Alloc(sizeof(VkDeviceFaultVendorInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].vendorFaultCode = src[start_index + i].vendorFaultCode;
        ptr[i].vendorFaultData = src[start_index + i].vendorFaultData;
    }
    return ptr;
}

template <>
VkDeviceFaultInfoEXT* CommandRecorder::CopyArray<VkDeviceFaultInfoEXT>(const VkDeviceFaultInfoEXT* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceFaultInfoEXT*>(m_allocator.Alloc(sizeof(VkDeviceFaultInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].pAddressInfos = src[start_index + i].pAddressInfos;
        ptr[i].pVendorInfos = src[start_index + i].pVendorInfos;
        ptr[i].pVendorBinaryData = src[start_index + i].pVendorBinaryData;
    }
    return ptr;
}

template <>
VkDeviceFaultVendorBinaryHeaderVersionOneEXT* CommandRecorder::CopyArray<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>(
    const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceFaultVendorBinaryHeaderVersionOneEXT*>(
        m_allocator.Alloc(sizeof(VkDeviceFaultVendorBinaryHeaderVersionOneEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].headerSize = src[start_index + i].headerSize;
        ptr[i].headerVersion = src[start_index + i].headerVersion;
        ptr[i].vendorID = src[start_index + i].vendorID;
        ptr[i].deviceID = src[start_index + i].deviceID;
        ptr[i].driverVersion = src[start_index + i].driverVersion;
        std::memcpy(ptr[i].pipelineCacheUUID, src[start_index + i].pipelineCacheUUID,
                    sizeof(src[start_index + i].pipelineCacheUUID));
        ptr[i].applicationNameOffset = src[start_index + i].applicationNameOffset;
        ptr[i].applicationVersion = src[start_index + i].applicationVersion;
        ptr[i].engineNameOffset = src[start_index + i].engineNameOffset;
        ptr[i].engineVersion = src[start_index + i].engineVersion;
        ptr[i].apiVersion = src[start_index + i].apiVersion;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>(
    const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rasterizationOrderColorAttachmentAccess = src[start_index + i].rasterizationOrderColorAttachmentAccess;
        ptr[i].rasterizationOrderDepthAttachmentAccess = src[start_index + i].rasterizationOrderDepthAttachmentAccess;
        ptr[i].rasterizationOrderStencilAttachmentAccess =
            src[start_index + i].rasterizationOrderStencilAttachmentAccess;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>(
    const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].formatRgba10x6WithoutYCbCrSampler = src[start_index + i].formatRgba10x6WithoutYCbCrSampler;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
template <>
VkDirectFBSurfaceCreateInfoEXT* CommandRecorder::CopyArray<VkDirectFBSurfaceCreateInfoEXT>(
    const VkDirectFBSurfaceCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDirectFBSurfaceCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkDirectFBSurfaceCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].dfb = src[start_index + i].dfb;
        ptr[i].surface = src[start_index + i].surface;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_DIRECTFB_EXT

template <>
VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>(
    const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mutableDescriptorType = src[start_index + i].mutableDescriptorType;
    }
    return ptr;
}

template <>
VkMutableDescriptorTypeListEXT* CommandRecorder::CopyArray<VkMutableDescriptorTypeListEXT>(
    const VkMutableDescriptorTypeListEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMutableDescriptorTypeListEXT*>(
        m_allocator.Alloc(sizeof(VkMutableDescriptorTypeListEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].descriptorTypeCount = src[start_index + i].descriptorTypeCount;
        ptr[i].pDescriptorTypes = nullptr;
        if (src[start_index + i].pDescriptorTypes) {
            ptr[i].pDescriptorTypes = CopyArray<>(src[start_index + i].pDescriptorTypes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkMutableDescriptorTypeCreateInfoEXT* CommandRecorder::CopyArray<VkMutableDescriptorTypeCreateInfoEXT>(
    const VkMutableDescriptorTypeCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMutableDescriptorTypeCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkMutableDescriptorTypeCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mutableDescriptorTypeListCount = src[start_index + i].mutableDescriptorTypeListCount;
        ptr[i].pMutableDescriptorTypeLists = nullptr;
        if (src[start_index + i].pMutableDescriptorTypeLists) {
            ptr[i].pMutableDescriptorTypeLists = CopyArray<>(src[start_index + i].pMutableDescriptorTypeLists, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexInputDynamicState = src[start_index + i].vertexInputDynamicState;
    }
    return ptr;
}

template <>
VkVertexInputBindingDescription2EXT* CommandRecorder::CopyArray<VkVertexInputBindingDescription2EXT>(
    const VkVertexInputBindingDescription2EXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVertexInputBindingDescription2EXT*>(
        m_allocator.Alloc(sizeof(VkVertexInputBindingDescription2EXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].stride = src[start_index + i].stride;
        ptr[i].inputRate = src[start_index + i].inputRate;
        ptr[i].divisor = src[start_index + i].divisor;
    }
    return ptr;
}

template <>
VkVertexInputAttributeDescription2EXT* CommandRecorder::CopyArray<VkVertexInputAttributeDescription2EXT>(
    const VkVertexInputAttributeDescription2EXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkVertexInputAttributeDescription2EXT*>(
        m_allocator.Alloc(sizeof(VkVertexInputAttributeDescription2EXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].location = src[start_index + i].location;
        ptr[i].binding = src[start_index + i].binding;
        ptr[i].format = src[start_index + i].format;
        ptr[i].offset = src[start_index + i].offset;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDrmPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDrmPropertiesEXT>(
    const VkPhysicalDeviceDrmPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDrmPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDrmPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].hasPrimary = src[start_index + i].hasPrimary;
        ptr[i].hasRender = src[start_index + i].hasRender;
        ptr[i].primaryMajor = src[start_index + i].primaryMajor;
        ptr[i].primaryMinor = src[start_index + i].primaryMinor;
        ptr[i].renderMajor = src[start_index + i].renderMajor;
        ptr[i].renderMinor = src[start_index + i].renderMinor;
    }
    return ptr;
}

template <>
VkPhysicalDeviceAddressBindingReportFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAddressBindingReportFeaturesEXT>(
    const VkPhysicalDeviceAddressBindingReportFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].reportAddressBinding = src[start_index + i].reportAddressBinding;
    }
    return ptr;
}

template <>
VkDeviceAddressBindingCallbackDataEXT* CommandRecorder::CopyArray<VkDeviceAddressBindingCallbackDataEXT>(
    const VkDeviceAddressBindingCallbackDataEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceAddressBindingCallbackDataEXT*>(
        m_allocator.Alloc(sizeof(VkDeviceAddressBindingCallbackDataEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].baseAddress = src[start_index + i].baseAddress;
        ptr[i].size = src[start_index + i].size;
        ptr[i].bindingType = src[start_index + i].bindingType;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDepthClipControlFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipControlFeaturesEXT>(
    const VkPhysicalDeviceDepthClipControlFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDepthClipControlFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthClipControl = src[start_index + i].depthClipControl;
    }
    return ptr;
}

template <>
VkPipelineViewportDepthClipControlCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineViewportDepthClipControlCreateInfoEXT>(
    const VkPipelineViewportDepthClipControlCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineViewportDepthClipControlCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineViewportDepthClipControlCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].negativeOneToOne = src[start_index + i].negativeOneToOne;
    }
    return ptr;
}

template <>
VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>(
    const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].primitiveTopologyListRestart = src[start_index + i].primitiveTopologyListRestart;
        ptr[i].primitiveTopologyPatchListRestart = src[start_index + i].primitiveTopologyPatchListRestart;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportMemoryZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkImportMemoryZirconHandleInfoFUCHSIA>(
    const VkImportMemoryZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryZirconHandleInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImportMemoryZirconHandleInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].handle = src[start_index + i].handle;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkMemoryZirconHandlePropertiesFUCHSIA* CommandRecorder::CopyArray<VkMemoryZirconHandlePropertiesFUCHSIA>(
    const VkMemoryZirconHandlePropertiesFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryZirconHandlePropertiesFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkMemoryZirconHandlePropertiesFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkMemoryGetZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkMemoryGetZirconHandleInfoFUCHSIA>(
    const VkMemoryGetZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryGetZirconHandleInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkMemoryGetZirconHandleInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportSemaphoreZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkImportSemaphoreZirconHandleInfoFUCHSIA>(
    const VkImportSemaphoreZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportSemaphoreZirconHandleInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImportSemaphoreZirconHandleInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].handleType = src[start_index + i].handleType;
        ptr[i].zirconHandle = src[start_index + i].zirconHandle;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkSemaphoreGetZirconHandleInfoFUCHSIA* CommandRecorder::CopyArray<VkSemaphoreGetZirconHandleInfoFUCHSIA>(
    const VkSemaphoreGetZirconHandleInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSemaphoreGetZirconHandleInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkSemaphoreGetZirconHandleInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].semaphore = src[start_index + i].semaphore;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionCreateInfoFUCHSIA>(
    const VkBufferCollectionCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCollectionCreateInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferCollectionCreateInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].collectionToken = src[start_index + i].collectionToken;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImportMemoryBufferCollectionFUCHSIA* CommandRecorder::CopyArray<VkImportMemoryBufferCollectionFUCHSIA>(
    const VkImportMemoryBufferCollectionFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImportMemoryBufferCollectionFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImportMemoryBufferCollectionFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].collection = src[start_index + i].collection;
        ptr[i].index = src[start_index + i].index;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionImageCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionImageCreateInfoFUCHSIA>(
    const VkBufferCollectionImageCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCollectionImageCreateInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferCollectionImageCreateInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].collection = src[start_index + i].collection;
        ptr[i].index = src[start_index + i].index;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionConstraintsInfoFUCHSIA>(
    const VkBufferCollectionConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCollectionConstraintsInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferCollectionConstraintsInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minBufferCount = src[start_index + i].minBufferCount;
        ptr[i].maxBufferCount = src[start_index + i].maxBufferCount;
        ptr[i].minBufferCountForCamping = src[start_index + i].minBufferCountForCamping;
        ptr[i].minBufferCountForDedicatedSlack = src[start_index + i].minBufferCountForDedicatedSlack;
        ptr[i].minBufferCountForSharedSlack = src[start_index + i].minBufferCountForSharedSlack;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferConstraintsInfoFUCHSIA>(
    const VkBufferConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferConstraintsInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferConstraintsInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].createInfo = src[start_index + i].createInfo;
        ptr[i].requiredFormatFeatures = src[start_index + i].requiredFormatFeatures;
        ptr[i].bufferCollectionConstraints = src[start_index + i].bufferCollectionConstraints;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionBufferCreateInfoFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionBufferCreateInfoFUCHSIA>(
    const VkBufferCollectionBufferCreateInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCollectionBufferCreateInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferCollectionBufferCreateInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].collection = src[start_index + i].collection;
        ptr[i].index = src[start_index + i].index;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkSysmemColorSpaceFUCHSIA* CommandRecorder::CopyArray<VkSysmemColorSpaceFUCHSIA>(const VkSysmemColorSpaceFUCHSIA* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkSysmemColorSpaceFUCHSIA*>(m_allocator.Alloc(sizeof(VkSysmemColorSpaceFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorSpace = src[start_index + i].colorSpace;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkBufferCollectionPropertiesFUCHSIA* CommandRecorder::CopyArray<VkBufferCollectionPropertiesFUCHSIA>(
    const VkBufferCollectionPropertiesFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBufferCollectionPropertiesFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkBufferCollectionPropertiesFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
        ptr[i].bufferCount = src[start_index + i].bufferCount;
        ptr[i].createInfoIndex = src[start_index + i].createInfoIndex;
        ptr[i].sysmemPixelFormat = src[start_index + i].sysmemPixelFormat;
        ptr[i].formatFeatures = src[start_index + i].formatFeatures;
        ptr[i].sysmemColorSpaceIndex = src[start_index + i].sysmemColorSpaceIndex;
        ptr[i].samplerYcbcrConversionComponents = src[start_index + i].samplerYcbcrConversionComponents;
        ptr[i].suggestedYcbcrModel = src[start_index + i].suggestedYcbcrModel;
        ptr[i].suggestedYcbcrRange = src[start_index + i].suggestedYcbcrRange;
        ptr[i].suggestedXChromaOffset = src[start_index + i].suggestedXChromaOffset;
        ptr[i].suggestedYChromaOffset = src[start_index + i].suggestedYChromaOffset;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImageFormatConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkImageFormatConstraintsInfoFUCHSIA>(
    const VkImageFormatConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageFormatConstraintsInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImageFormatConstraintsInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageCreateInfo = src[start_index + i].imageCreateInfo;
        ptr[i].requiredFormatFeatures = src[start_index + i].requiredFormatFeatures;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].sysmemPixelFormat = src[start_index + i].sysmemPixelFormat;
        ptr[i].colorSpaceCount = src[start_index + i].colorSpaceCount;
        ptr[i].pColorSpaces = nullptr;
        if (src[start_index + i].pColorSpaces) {
            ptr[i].pColorSpaces = CopyArray<>(src[start_index + i].pColorSpaces, 0, 1);
        }
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

#ifdef VK_USE_PLATFORM_FUCHSIA
template <>
VkImageConstraintsInfoFUCHSIA* CommandRecorder::CopyArray<VkImageConstraintsInfoFUCHSIA>(
    const VkImageConstraintsInfoFUCHSIA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageConstraintsInfoFUCHSIA*>(
        m_allocator.Alloc(sizeof(VkImageConstraintsInfoFUCHSIA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].formatConstraintsCount = src[start_index + i].formatConstraintsCount;
        ptr[i].pFormatConstraints = nullptr;
        if (src[start_index + i].pFormatConstraints) {
            ptr[i].pFormatConstraints = CopyArray<>(src[start_index + i].pFormatConstraints, 0, 1);
        }
        ptr[i].bufferCollectionConstraints = src[start_index + i].bufferCollectionConstraints;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_FUCHSIA

template <>
VkSubpassShadingPipelineCreateInfoHUAWEI* CommandRecorder::CopyArray<VkSubpassShadingPipelineCreateInfoHUAWEI>(
    const VkSubpassShadingPipelineCreateInfoHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassShadingPipelineCreateInfoHUAWEI*>(
        m_allocator.Alloc(sizeof(VkSubpassShadingPipelineCreateInfoHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].renderPass = src[start_index + i].renderPass;
        ptr[i].subpass = src[start_index + i].subpass;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* CommandRecorder::CopyArray<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>(
    const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subpassShading = src[start_index + i].subpassShading;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>(
    const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxSubpassShadingWorkgroupSizeAspectRatio =
            src[start_index + i].maxSubpassShadingWorkgroupSizeAspectRatio;
    }
    return ptr;
}

template <>
VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* CommandRecorder::CopyArray<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>(
    const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].invocationMask = src[start_index + i].invocationMask;
    }
    return ptr;
}

template <>
VkMemoryGetRemoteAddressInfoNV* CommandRecorder::CopyArray<VkMemoryGetRemoteAddressInfoNV>(
    const VkMemoryGetRemoteAddressInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMemoryGetRemoteAddressInfoNV*>(
        m_allocator.Alloc(sizeof(VkMemoryGetRemoteAddressInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memory = src[start_index + i].memory;
        ptr[i].handleType = src[start_index + i].handleType;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>(
    const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalMemoryRDMA = src[start_index + i].externalMemoryRDMA;
    }
    return ptr;
}

template <>
VkPipelinePropertiesIdentifierEXT* CommandRecorder::CopyArray<VkPipelinePropertiesIdentifierEXT>(
    const VkPipelinePropertiesIdentifierEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelinePropertiesIdentifierEXT*>(
        m_allocator.Alloc(sizeof(VkPipelinePropertiesIdentifierEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].pipelineIdentifier, src[start_index + i].pipelineIdentifier,
                    sizeof(src[start_index + i].pipelineIdentifier));
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelinePropertiesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelinePropertiesFeaturesEXT>(
    const VkPhysicalDevicePipelinePropertiesFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelinePropertiesFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelinePropertiesIdentifier = src[start_index + i].pipelinePropertiesIdentifier;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFrameBoundaryFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceFrameBoundaryFeaturesEXT>(
    const VkPhysicalDeviceFrameBoundaryFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFrameBoundaryFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].frameBoundary = src[start_index + i].frameBoundary;
    }
    return ptr;
}

template <>
VkFrameBoundaryEXT* CommandRecorder::CopyArray<VkFrameBoundaryEXT>(const VkFrameBoundaryEXT* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkFrameBoundaryEXT*>(m_allocator.Alloc(sizeof(VkFrameBoundaryEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].frameID = src[start_index + i].frameID;
        ptr[i].imageCount = src[start_index + i].imageCount;
        ptr[i].pImages = nullptr;
        if (src[start_index + i].pImages) {
            ptr[i].pImages = CopyArray<>(src[start_index + i].pImages, 0, 1);
        }
        ptr[i].bufferCount = src[start_index + i].bufferCount;
        ptr[i].pBuffers = nullptr;
        if (src[start_index + i].pBuffers) {
            ptr[i].pBuffers = CopyArray<>(src[start_index + i].pBuffers, 0, 1);
        }
        ptr[i].tagName = src[start_index + i].tagName;
        ptr[i].tagSize = src[start_index + i].tagSize;
        ptr[i].pTag = src[start_index + i].pTag;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>(
    const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multisampledRenderToSingleSampled = src[start_index + i].multisampledRenderToSingleSampled;
    }
    return ptr;
}

template <>
VkSubpassResolvePerformanceQueryEXT* CommandRecorder::CopyArray<VkSubpassResolvePerformanceQueryEXT>(
    const VkSubpassResolvePerformanceQueryEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassResolvePerformanceQueryEXT*>(
        m_allocator.Alloc(sizeof(VkSubpassResolvePerformanceQueryEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].optimal = src[start_index + i].optimal;
    }
    return ptr;
}

template <>
VkMultisampledRenderToSingleSampledInfoEXT* CommandRecorder::CopyArray<VkMultisampledRenderToSingleSampledInfoEXT>(
    const VkMultisampledRenderToSingleSampledInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMultisampledRenderToSingleSampledInfoEXT*>(
        m_allocator.Alloc(sizeof(VkMultisampledRenderToSingleSampledInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multisampledRenderToSingleSampledEnable = src[start_index + i].multisampledRenderToSingleSampledEnable;
        ptr[i].rasterizationSamples = src[start_index + i].rasterizationSamples;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].extendedDynamicState2 = src[start_index + i].extendedDynamicState2;
        ptr[i].extendedDynamicState2LogicOp = src[start_index + i].extendedDynamicState2LogicOp;
        ptr[i].extendedDynamicState2PatchControlPoints = src[start_index + i].extendedDynamicState2PatchControlPoints;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenSurfaceCreateInfoQNX* CommandRecorder::CopyArray<VkScreenSurfaceCreateInfoQNX>(
    const VkScreenSurfaceCreateInfoQNX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkScreenSurfaceCreateInfoQNX*>(
        m_allocator.Alloc(sizeof(VkScreenSurfaceCreateInfoQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].context = src[start_index + i].context;
        ptr[i].window = src[start_index + i].window;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

template <>
VkPhysicalDeviceColorWriteEnableFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(
    const VkPhysicalDeviceColorWriteEnableFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorWriteEnable = src[start_index + i].colorWriteEnable;
    }
    return ptr;
}

template <>
VkPipelineColorWriteCreateInfoEXT* CommandRecorder::CopyArray<VkPipelineColorWriteCreateInfoEXT>(
    const VkPipelineColorWriteCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineColorWriteCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineColorWriteCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentCount = src[start_index + i].attachmentCount;
        ptr[i].pColorWriteEnables = nullptr;
        if (src[start_index + i].pColorWriteEnables) {
            ptr[i].pColorWriteEnables = CopyArray<>(src[start_index + i].pColorWriteEnables, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>(
    const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].primitivesGeneratedQuery = src[start_index + i].primitivesGeneratedQuery;
        ptr[i].primitivesGeneratedQueryWithRasterizerDiscard =
            src[start_index + i].primitivesGeneratedQueryWithRasterizerDiscard;
        ptr[i].primitivesGeneratedQueryWithNonZeroStreams =
            src[start_index + i].primitivesGeneratedQueryWithNonZeroStreams;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageViewMinLodFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImageViewMinLodFeaturesEXT>(
    const VkPhysicalDeviceImageViewMinLodFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minLod = src[start_index + i].minLod;
    }
    return ptr;
}

template <>
VkImageViewMinLodCreateInfoEXT* CommandRecorder::CopyArray<VkImageViewMinLodCreateInfoEXT>(
    const VkImageViewMinLodCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewMinLodCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageViewMinLodCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].minLod = src[start_index + i].minLod;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiDrawFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawFeaturesEXT>(
    const VkPhysicalDeviceMultiDrawFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiDrawFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multiDraw = src[start_index + i].multiDraw;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiDrawPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawPropertiesEXT>(
    const VkPhysicalDeviceMultiDrawPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiDrawPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxMultiDrawCount = src[start_index + i].maxMultiDrawCount;
    }
    return ptr;
}

template <>
VkMultiDrawInfoEXT* CommandRecorder::CopyArray<VkMultiDrawInfoEXT>(const VkMultiDrawInfoEXT* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkMultiDrawInfoEXT*>(m_allocator.Alloc(sizeof(VkMultiDrawInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].firstVertex = src[start_index + i].firstVertex;
        ptr[i].vertexCount = src[start_index + i].vertexCount;
    }
    return ptr;
}

template <>
VkMultiDrawIndexedInfoEXT* CommandRecorder::CopyArray<VkMultiDrawIndexedInfoEXT>(const VkMultiDrawIndexedInfoEXT* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMultiDrawIndexedInfoEXT*>(m_allocator.Alloc(sizeof(VkMultiDrawIndexedInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].firstIndex = src[start_index + i].firstIndex;
        ptr[i].indexCount = src[start_index + i].indexCount;
        ptr[i].vertexOffset = src[start_index + i].vertexOffset;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>(
    const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].image2DViewOf3D = src[start_index + i].image2DViewOf3D;
        ptr[i].sampler2DViewOf3D = src[start_index + i].sampler2DViewOf3D;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderTileImageFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderTileImageFeaturesEXT>(
    const VkPhysicalDeviceShaderTileImageFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderTileImageFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderTileImageColorReadAccess = src[start_index + i].shaderTileImageColorReadAccess;
        ptr[i].shaderTileImageDepthReadAccess = src[start_index + i].shaderTileImageDepthReadAccess;
        ptr[i].shaderTileImageStencilReadAccess = src[start_index + i].shaderTileImageStencilReadAccess;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderTileImagePropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderTileImagePropertiesEXT>(
    const VkPhysicalDeviceShaderTileImagePropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderTileImagePropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderTileImageCoherentReadAccelerated = src[start_index + i].shaderTileImageCoherentReadAccelerated;
        ptr[i].shaderTileImageReadSampleFromPixelRateInvocation =
            src[start_index + i].shaderTileImageReadSampleFromPixelRateInvocation;
        ptr[i].shaderTileImageReadFromHelperInvocation = src[start_index + i].shaderTileImageReadFromHelperInvocation;
    }
    return ptr;
}

template <>
VkMicromapUsageEXT* CommandRecorder::CopyArray<VkMicromapUsageEXT>(const VkMicromapUsageEXT* src, uint64_t start_index,
                                                                   uint64_t count) {
    auto ptr = reinterpret_cast<VkMicromapUsageEXT*>(m_allocator.Alloc(sizeof(VkMicromapUsageEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].count = src[start_index + i].count;
        ptr[i].subdivisionLevel = src[start_index + i].subdivisionLevel;
        ptr[i].format = src[start_index + i].format;
    }
    return ptr;
}

template <>
VkDeviceOrHostAddressKHR* CommandRecorder::CopyArray<VkDeviceOrHostAddressKHR>(const VkDeviceOrHostAddressKHR* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceOrHostAddressKHR*>(m_allocator.Alloc(sizeof(VkDeviceOrHostAddressKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].hostAddress = src[start_index + i].hostAddress;
    }
    return ptr;
}

template <>
VkMicromapBuildInfoEXT* CommandRecorder::CopyArray<VkMicromapBuildInfoEXT>(const VkMicromapBuildInfoEXT* src,
                                                                           uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMicromapBuildInfoEXT*>(m_allocator.Alloc(sizeof(VkMicromapBuildInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].mode = src[start_index + i].mode;
        ptr[i].dstMicromap = src[start_index + i].dstMicromap;
        ptr[i].usageCountsCount = src[start_index + i].usageCountsCount;
        ptr[i].pUsageCounts = nullptr;
        if (src[start_index + i].pUsageCounts) {
            ptr[i].pUsageCounts = CopyArray<>(src[start_index + i].pUsageCounts, 0, 1);
        }
        ptr[i].ppUsageCounts = nullptr;
        if (src[start_index + i].ppUsageCounts) {
            ptr[i].ppUsageCounts = CopyArray<>(src[start_index + i].ppUsageCounts, 0, 1);
        }
        ptr[i].data = src[start_index + i].data;
        ptr[i].scratchData = src[start_index + i].scratchData;
        ptr[i].triangleArray = src[start_index + i].triangleArray;
        ptr[i].triangleArrayStride = src[start_index + i].triangleArrayStride;
    }
    return ptr;
}

template <>
VkMicromapCreateInfoEXT* CommandRecorder::CopyArray<VkMicromapCreateInfoEXT>(const VkMicromapCreateInfoEXT* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMicromapCreateInfoEXT*>(m_allocator.Alloc(sizeof(VkMicromapCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].createFlags = src[start_index + i].createFlags;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
        ptr[i].type = src[start_index + i].type;
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
    }
    return ptr;
}

template <>
VkPhysicalDeviceOpacityMicromapFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceOpacityMicromapFeaturesEXT>(
    const VkPhysicalDeviceOpacityMicromapFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].micromap = src[start_index + i].micromap;
        ptr[i].micromapCaptureReplay = src[start_index + i].micromapCaptureReplay;
        ptr[i].micromapHostCommands = src[start_index + i].micromapHostCommands;
    }
    return ptr;
}

template <>
VkPhysicalDeviceOpacityMicromapPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceOpacityMicromapPropertiesEXT>(
    const VkPhysicalDeviceOpacityMicromapPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceOpacityMicromapPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxOpacity2StateSubdivisionLevel = src[start_index + i].maxOpacity2StateSubdivisionLevel;
        ptr[i].maxOpacity4StateSubdivisionLevel = src[start_index + i].maxOpacity4StateSubdivisionLevel;
    }
    return ptr;
}

template <>
VkMicromapVersionInfoEXT* CommandRecorder::CopyArray<VkMicromapVersionInfoEXT>(const VkMicromapVersionInfoEXT* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMicromapVersionInfoEXT*>(m_allocator.Alloc(sizeof(VkMicromapVersionInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pVersionData = nullptr;
        if (src[start_index + i].pVersionData) {
            ptr[i].pVersionData = CopyArray<>(src[start_index + i].pVersionData, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyMicromapToMemoryInfoEXT* CommandRecorder::CopyArray<VkCopyMicromapToMemoryInfoEXT>(
    const VkCopyMicromapToMemoryInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMicromapToMemoryInfoEXT*>(
        m_allocator.Alloc(sizeof(VkCopyMicromapToMemoryInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkCopyMemoryToMicromapInfoEXT* CommandRecorder::CopyArray<VkCopyMemoryToMicromapInfoEXT>(
    const VkCopyMemoryToMicromapInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMemoryToMicromapInfoEXT*>(
        m_allocator.Alloc(sizeof(VkCopyMemoryToMicromapInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkCopyMicromapInfoEXT* CommandRecorder::CopyArray<VkCopyMicromapInfoEXT>(const VkCopyMicromapInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMicromapInfoEXT*>(m_allocator.Alloc(sizeof(VkCopyMicromapInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkMicromapBuildSizesInfoEXT* CommandRecorder::CopyArray<VkMicromapBuildSizesInfoEXT>(
    const VkMicromapBuildSizesInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkMicromapBuildSizesInfoEXT*>(m_allocator.Alloc(sizeof(VkMicromapBuildSizesInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].micromapSize = src[start_index + i].micromapSize;
        ptr[i].buildScratchSize = src[start_index + i].buildScratchSize;
        ptr[i].discardable = src[start_index + i].discardable;
    }
    return ptr;
}

template <>
VkAccelerationStructureTrianglesOpacityMicromapEXT*
CommandRecorder::CopyArray<VkAccelerationStructureTrianglesOpacityMicromapEXT>(
    const VkAccelerationStructureTrianglesOpacityMicromapEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureTrianglesOpacityMicromapEXT*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureTrianglesOpacityMicromapEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].indexType = src[start_index + i].indexType;
        ptr[i].indexBuffer = src[start_index + i].indexBuffer;
        ptr[i].indexStride = src[start_index + i].indexStride;
        ptr[i].baseTriangle = src[start_index + i].baseTriangle;
        ptr[i].usageCountsCount = src[start_index + i].usageCountsCount;
        ptr[i].pUsageCounts = nullptr;
        if (src[start_index + i].pUsageCounts) {
            ptr[i].pUsageCounts = CopyArray<>(src[start_index + i].pUsageCounts, 0, 1);
        }
        ptr[i].ppUsageCounts = nullptr;
        if (src[start_index + i].ppUsageCounts) {
            ptr[i].ppUsageCounts = CopyArray<>(src[start_index + i].ppUsageCounts, 0, 1);
        }
        ptr[i].micromap = src[start_index + i].micromap;
    }
    return ptr;
}

template <>
VkMicromapTriangleEXT* CommandRecorder::CopyArray<VkMicromapTriangleEXT>(const VkMicromapTriangleEXT* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMicromapTriangleEXT*>(m_allocator.Alloc(sizeof(VkMicromapTriangleEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].dataOffset = src[start_index + i].dataOffset;
        ptr[i].subdivisionLevel = src[start_index + i].subdivisionLevel;
        ptr[i].format = src[start_index + i].format;
    }
    return ptr;
}

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceDisplacementMicromapFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDisplacementMicromapFeaturesNV>(
    const VkPhysicalDeviceDisplacementMicromapFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDisplacementMicromapFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displacementMicromap = src[start_index + i].displacementMicromap;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkPhysicalDeviceDisplacementMicromapPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDisplacementMicromapPropertiesNV>(
    const VkPhysicalDeviceDisplacementMicromapPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDisplacementMicromapPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDisplacementMicromapPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxDisplacementMicromapSubdivisionLevel = src[start_index + i].maxDisplacementMicromapSubdivisionLevel;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
template <>
VkAccelerationStructureTrianglesDisplacementMicromapNV*
CommandRecorder::CopyArray<VkAccelerationStructureTrianglesDisplacementMicromapNV>(
    const VkAccelerationStructureTrianglesDisplacementMicromapNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureTrianglesDisplacementMicromapNV*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureTrianglesDisplacementMicromapNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].displacementBiasAndScaleFormat = src[start_index + i].displacementBiasAndScaleFormat;
        ptr[i].displacementVectorFormat = src[start_index + i].displacementVectorFormat;
        ptr[i].displacementBiasAndScaleBuffer = src[start_index + i].displacementBiasAndScaleBuffer;
        ptr[i].displacementBiasAndScaleStride = src[start_index + i].displacementBiasAndScaleStride;
        ptr[i].displacementVectorBuffer = src[start_index + i].displacementVectorBuffer;
        ptr[i].displacementVectorStride = src[start_index + i].displacementVectorStride;
        ptr[i].displacedMicromapPrimitiveFlags = src[start_index + i].displacedMicromapPrimitiveFlags;
        ptr[i].displacedMicromapPrimitiveFlagsStride = src[start_index + i].displacedMicromapPrimitiveFlagsStride;
        ptr[i].indexType = src[start_index + i].indexType;
        ptr[i].indexBuffer = src[start_index + i].indexBuffer;
        ptr[i].indexStride = src[start_index + i].indexStride;
        ptr[i].baseTriangle = src[start_index + i].baseTriangle;
        ptr[i].usageCountsCount = src[start_index + i].usageCountsCount;
        ptr[i].pUsageCounts = nullptr;
        if (src[start_index + i].pUsageCounts) {
            ptr[i].pUsageCounts = CopyArray<>(src[start_index + i].pUsageCounts, 0, 1);
        }
        ptr[i].ppUsageCounts = nullptr;
        if (src[start_index + i].ppUsageCounts) {
            ptr[i].ppUsageCounts = CopyArray<>(src[start_index + i].ppUsageCounts, 0, 1);
        }
        ptr[i].micromap = src[start_index + i].micromap;
    }
    return ptr;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

template <>
VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].clustercullingShader = src[start_index + i].clustercullingShader;
        ptr[i].multiviewClusterCullingShader = src[start_index + i].multiviewClusterCullingShader;
    }
    return ptr;
}

template <>
VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].maxWorkGroupCount, src[start_index + i].maxWorkGroupCount,
                    sizeof(src[start_index + i].maxWorkGroupCount));
        std::memcpy(ptr[i].maxWorkGroupSize, src[start_index + i].maxWorkGroupSize,
                    sizeof(src[start_index + i].maxWorkGroupSize));
        ptr[i].maxOutputClusterCount = src[start_index + i].maxOutputClusterCount;
        ptr[i].indirectBufferOffsetAlignment = src[start_index + i].indirectBufferOffsetAlignment;
    }
    return ptr;
}

template <>
VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*
CommandRecorder::CopyArray<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>(
    const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].clusterShadingRate = src[start_index + i].clusterShadingRate;
    }
    return ptr;
}

template <>
VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>(
    const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].borderColorSwizzle = src[start_index + i].borderColorSwizzle;
        ptr[i].borderColorSwizzleFromImage = src[start_index + i].borderColorSwizzleFromImage;
    }
    return ptr;
}

template <>
VkSamplerBorderColorComponentMappingCreateInfoEXT*
CommandRecorder::CopyArray<VkSamplerBorderColorComponentMappingCreateInfoEXT>(
    const VkSamplerBorderColorComponentMappingCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerBorderColorComponentMappingCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkSamplerBorderColorComponentMappingCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].components = src[start_index + i].components;
        ptr[i].srgb = src[start_index + i].srgb;
    }
    return ptr;
}

template <>
VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>(
    const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pageableDeviceLocalMemory = src[start_index + i].pageableDeviceLocalMemory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderCorePropertiesARM* CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesARM>(
    const VkPhysicalDeviceShaderCorePropertiesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCorePropertiesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pixelRate = src[start_index + i].pixelRate;
        ptr[i].texelRate = src[start_index + i].texelRate;
        ptr[i].fmaRate = src[start_index + i].fmaRate;
    }
    return ptr;
}

template <>
VkDeviceQueueShaderCoreControlCreateInfoARM* CommandRecorder::CopyArray<VkDeviceQueueShaderCoreControlCreateInfoARM>(
    const VkDeviceQueueShaderCoreControlCreateInfoARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDeviceQueueShaderCoreControlCreateInfoARM*>(
        m_allocator.Alloc(sizeof(VkDeviceQueueShaderCoreControlCreateInfoARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderCoreCount = src[start_index + i].shaderCoreCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSchedulingControlsFeaturesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceSchedulingControlsFeaturesARM>(
    const VkPhysicalDeviceSchedulingControlsFeaturesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSchedulingControlsFeaturesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSchedulingControlsFeaturesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].schedulingControls = src[start_index + i].schedulingControls;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSchedulingControlsPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceSchedulingControlsPropertiesARM>(
    const VkPhysicalDeviceSchedulingControlsPropertiesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSchedulingControlsPropertiesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSchedulingControlsPropertiesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].schedulingControlsFlags = src[start_index + i].schedulingControlsFlags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>(
    const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageSlicedViewOf3D = src[start_index + i].imageSlicedViewOf3D;
    }
    return ptr;
}

template <>
VkImageViewSlicedCreateInfoEXT* CommandRecorder::CopyArray<VkImageViewSlicedCreateInfoEXT>(
    const VkImageViewSlicedCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewSlicedCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkImageViewSlicedCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].sliceOffset = src[start_index + i].sliceOffset;
        ptr[i].sliceCount = src[start_index + i].sliceCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>(
    const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorSetHostMapping = src[start_index + i].descriptorSetHostMapping;
    }
    return ptr;
}

template <>
VkDescriptorSetBindingReferenceVALVE* CommandRecorder::CopyArray<VkDescriptorSetBindingReferenceVALVE>(
    const VkDescriptorSetBindingReferenceVALVE* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetBindingReferenceVALVE*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetBindingReferenceVALVE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorSetLayout = src[start_index + i].descriptorSetLayout;
        ptr[i].binding = src[start_index + i].binding;
    }
    return ptr;
}

template <>
VkDescriptorSetLayoutHostMappingInfoVALVE* CommandRecorder::CopyArray<VkDescriptorSetLayoutHostMappingInfoVALVE>(
    const VkDescriptorSetLayoutHostMappingInfoVALVE* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDescriptorSetLayoutHostMappingInfoVALVE*>(
        m_allocator.Alloc(sizeof(VkDescriptorSetLayoutHostMappingInfoVALVE) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorOffset = src[start_index + i].descriptorOffset;
        ptr[i].descriptorSize = src[start_index + i].descriptorSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>(
    const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].depthClampZeroOne = src[start_index + i].depthClampZeroOne;
    }
    return ptr;
}

template <>
VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>(
    const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].nonSeamlessCubeMap = src[start_index + i].nonSeamlessCubeMap;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRenderPassStripedFeaturesARM* CommandRecorder::CopyArray<VkPhysicalDeviceRenderPassStripedFeaturesARM>(
    const VkPhysicalDeviceRenderPassStripedFeaturesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRenderPassStripedFeaturesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRenderPassStripedFeaturesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].renderPassStriped = src[start_index + i].renderPassStriped;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRenderPassStripedPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceRenderPassStripedPropertiesARM>(
    const VkPhysicalDeviceRenderPassStripedPropertiesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRenderPassStripedPropertiesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRenderPassStripedPropertiesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].renderPassStripeGranularity = src[start_index + i].renderPassStripeGranularity;
        ptr[i].maxRenderPassStripes = src[start_index + i].maxRenderPassStripes;
    }
    return ptr;
}

template <>
VkRenderPassStripeInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeInfoARM>(const VkRenderPassStripeInfoARM* src,
                                                                                 uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkRenderPassStripeInfoARM*>(m_allocator.Alloc(sizeof(VkRenderPassStripeInfoARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stripeArea = src[start_index + i].stripeArea;
    }
    return ptr;
}

template <>
VkRenderPassStripeBeginInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeBeginInfoARM>(
    const VkRenderPassStripeBeginInfoARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassStripeBeginInfoARM*>(
        m_allocator.Alloc(sizeof(VkRenderPassStripeBeginInfoARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stripeInfoCount = src[start_index + i].stripeInfoCount;
        ptr[i].pStripeInfos = nullptr;
        if (src[start_index + i].pStripeInfos) {
            ptr[i].pStripeInfos = CopyArray<>(src[start_index + i].pStripeInfos, 0, 1);
        }
    }
    return ptr;
}

template <>
VkRenderPassStripeSubmitInfoARM* CommandRecorder::CopyArray<VkRenderPassStripeSubmitInfoARM>(
    const VkRenderPassStripeSubmitInfoARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassStripeSubmitInfoARM*>(
        m_allocator.Alloc(sizeof(VkRenderPassStripeSubmitInfoARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].stripeSemaphoreInfoCount = src[start_index + i].stripeSemaphoreInfoCount;
        ptr[i].pStripeSemaphoreInfos = nullptr;
        if (src[start_index + i].pStripeSemaphoreInfos) {
            ptr[i].pStripeSemaphoreInfos = CopyArray<>(src[start_index + i].pStripeSemaphoreInfos, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>(
    const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityMapOffset = src[start_index + i].fragmentDensityMapOffset;
    }
    return ptr;
}

template <>
VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>(
    const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityOffsetGranularity = src[start_index + i].fragmentDensityOffsetGranularity;
    }
    return ptr;
}

template <>
VkSubpassFragmentDensityMapOffsetEndInfoQCOM* CommandRecorder::CopyArray<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>(
    const VkSubpassFragmentDensityMapOffsetEndInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSubpassFragmentDensityMapOffsetEndInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkSubpassFragmentDensityMapOffsetEndInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].fragmentDensityOffsetCount = src[start_index + i].fragmentDensityOffsetCount;
        ptr[i].pFragmentDensityOffsets = nullptr;
        if (src[start_index + i].pFragmentDensityOffsets) {
            ptr[i].pFragmentDensityOffsets = CopyArray<>(src[start_index + i].pFragmentDensityOffsets, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyMemoryIndirectCommandNV* CommandRecorder::CopyArray<VkCopyMemoryIndirectCommandNV>(
    const VkCopyMemoryIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMemoryIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkCopyMemoryIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcAddress = src[start_index + i].srcAddress;
        ptr[i].dstAddress = src[start_index + i].dstAddress;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkCopyMemoryToImageIndirectCommandNV* CommandRecorder::CopyArray<VkCopyMemoryToImageIndirectCommandNV>(
    const VkCopyMemoryToImageIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMemoryToImageIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkCopyMemoryToImageIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcAddress = src[start_index + i].srcAddress;
        ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;
        ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;
        ptr[i].imageSubresource = src[start_index + i].imageSubresource;
        ptr[i].imageOffset = src[start_index + i].imageOffset;
        ptr[i].imageExtent = src[start_index + i].imageExtent;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>(
    const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].indirectCopy = src[start_index + i].indirectCopy;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>(
    const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportedQueues = src[start_index + i].supportedQueues;
    }
    return ptr;
}

template <>
VkDecompressMemoryRegionNV* CommandRecorder::CopyArray<VkDecompressMemoryRegionNV>(
    const VkDecompressMemoryRegionNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkDecompressMemoryRegionNV*>(m_allocator.Alloc(sizeof(VkDecompressMemoryRegionNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcAddress = src[start_index + i].srcAddress;
        ptr[i].dstAddress = src[start_index + i].dstAddress;
        ptr[i].compressedSize = src[start_index + i].compressedSize;
        ptr[i].decompressedSize = src[start_index + i].decompressedSize;
        ptr[i].decompressionMethod = src[start_index + i].decompressionMethod;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryDecompressionFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceMemoryDecompressionFeaturesNV>(
    const VkPhysicalDeviceMemoryDecompressionFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryDecompressionFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].memoryDecompression = src[start_index + i].memoryDecompression;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMemoryDecompressionPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceMemoryDecompressionPropertiesNV>(
    const VkPhysicalDeviceMemoryDecompressionPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryDecompressionPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].decompressionMethods = src[start_index + i].decompressionMethods;
        ptr[i].maxDecompressionIndirectCount = src[start_index + i].maxDecompressionIndirectCount;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>(
    const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceGeneratedCompute = src[start_index + i].deviceGeneratedCompute;
        ptr[i].deviceGeneratedComputePipelines = src[start_index + i].deviceGeneratedComputePipelines;
        ptr[i].deviceGeneratedComputeCaptureReplay = src[start_index + i].deviceGeneratedComputeCaptureReplay;
    }
    return ptr;
}

template <>
VkComputePipelineIndirectBufferInfoNV* CommandRecorder::CopyArray<VkComputePipelineIndirectBufferInfoNV>(
    const VkComputePipelineIndirectBufferInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkComputePipelineIndirectBufferInfoNV*>(
        m_allocator.Alloc(sizeof(VkComputePipelineIndirectBufferInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].size = src[start_index + i].size;
        ptr[i].pipelineDeviceAddressCaptureReplay = src[start_index + i].pipelineDeviceAddressCaptureReplay;
    }
    return ptr;
}

template <>
VkPipelineIndirectDeviceAddressInfoNV* CommandRecorder::CopyArray<VkPipelineIndirectDeviceAddressInfoNV>(
    const VkPipelineIndirectDeviceAddressInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineIndirectDeviceAddressInfoNV*>(
        m_allocator.Alloc(sizeof(VkPipelineIndirectDeviceAddressInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
        ptr[i].pipeline = src[start_index + i].pipeline;
    }
    return ptr;
}

template <>
VkBindPipelineIndirectCommandNV* CommandRecorder::CopyArray<VkBindPipelineIndirectCommandNV>(
    const VkBindPipelineIndirectCommandNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBindPipelineIndirectCommandNV*>(
        m_allocator.Alloc(sizeof(VkBindPipelineIndirectCommandNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].pipelineAddress = src[start_index + i].pipelineAddress;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLinearColorAttachmentFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>(
    const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].linearColorAttachment = src[start_index + i].linearColorAttachment;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>(
    const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageCompressionControlSwapchain = src[start_index + i].imageCompressionControlSwapchain;
    }
    return ptr;
}

template <>
VkImageViewSampleWeightCreateInfoQCOM* CommandRecorder::CopyArray<VkImageViewSampleWeightCreateInfoQCOM>(
    const VkImageViewSampleWeightCreateInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageViewSampleWeightCreateInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkImageViewSampleWeightCreateInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].filterCenter = src[start_index + i].filterCenter;
        ptr[i].filterSize = src[start_index + i].filterSize;
        ptr[i].numPhases = src[start_index + i].numPhases;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageProcessingFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessingFeaturesQCOM>(
    const VkPhysicalDeviceImageProcessingFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageProcessingFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].textureSampleWeighted = src[start_index + i].textureSampleWeighted;
        ptr[i].textureBoxFilter = src[start_index + i].textureBoxFilter;
        ptr[i].textureBlockMatch = src[start_index + i].textureBlockMatch;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageProcessingPropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessingPropertiesQCOM>(
    const VkPhysicalDeviceImageProcessingPropertiesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageProcessingPropertiesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxWeightFilterPhases = src[start_index + i].maxWeightFilterPhases;
        ptr[i].maxWeightFilterDimension = src[start_index + i].maxWeightFilterDimension;
        ptr[i].maxBlockMatchRegion = src[start_index + i].maxBlockMatchRegion;
        ptr[i].maxBoxFilterBlockSize = src[start_index + i].maxBoxFilterBlockSize;
    }
    return ptr;
}

template <>
VkPhysicalDeviceNestedCommandBufferFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>(
    const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceNestedCommandBufferFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceNestedCommandBufferFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].nestedCommandBuffer = src[start_index + i].nestedCommandBuffer;
        ptr[i].nestedCommandBufferRendering = src[start_index + i].nestedCommandBufferRendering;
        ptr[i].nestedCommandBufferSimultaneousUse = src[start_index + i].nestedCommandBufferSimultaneousUse;
    }
    return ptr;
}

template <>
VkPhysicalDeviceNestedCommandBufferPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceNestedCommandBufferPropertiesEXT>(
    const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceNestedCommandBufferPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceNestedCommandBufferPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxCommandBufferNestingLevel = src[start_index + i].maxCommandBufferNestingLevel;
    }
    return ptr;
}

template <>
VkExternalMemoryAcquireUnmodifiedEXT* CommandRecorder::CopyArray<VkExternalMemoryAcquireUnmodifiedEXT>(
    const VkExternalMemoryAcquireUnmodifiedEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalMemoryAcquireUnmodifiedEXT*>(
        m_allocator.Alloc(sizeof(VkExternalMemoryAcquireUnmodifiedEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].acquireUnmodifiedMemory = src[start_index + i].acquireUnmodifiedMemory;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>(
    const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].extendedDynamicState3TessellationDomainOrigin =
            src[start_index + i].extendedDynamicState3TessellationDomainOrigin;
        ptr[i].extendedDynamicState3DepthClampEnable = src[start_index + i].extendedDynamicState3DepthClampEnable;
        ptr[i].extendedDynamicState3PolygonMode = src[start_index + i].extendedDynamicState3PolygonMode;
        ptr[i].extendedDynamicState3RasterizationSamples =
            src[start_index + i].extendedDynamicState3RasterizationSamples;
        ptr[i].extendedDynamicState3SampleMask = src[start_index + i].extendedDynamicState3SampleMask;
        ptr[i].extendedDynamicState3AlphaToCoverageEnable =
            src[start_index + i].extendedDynamicState3AlphaToCoverageEnable;
        ptr[i].extendedDynamicState3AlphaToOneEnable = src[start_index + i].extendedDynamicState3AlphaToOneEnable;
        ptr[i].extendedDynamicState3LogicOpEnable = src[start_index + i].extendedDynamicState3LogicOpEnable;
        ptr[i].extendedDynamicState3ColorBlendEnable = src[start_index + i].extendedDynamicState3ColorBlendEnable;
        ptr[i].extendedDynamicState3ColorBlendEquation = src[start_index + i].extendedDynamicState3ColorBlendEquation;
        ptr[i].extendedDynamicState3ColorWriteMask = src[start_index + i].extendedDynamicState3ColorWriteMask;
        ptr[i].extendedDynamicState3RasterizationStream = src[start_index + i].extendedDynamicState3RasterizationStream;
        ptr[i].extendedDynamicState3ConservativeRasterizationMode =
            src[start_index + i].extendedDynamicState3ConservativeRasterizationMode;
        ptr[i].extendedDynamicState3ExtraPrimitiveOverestimationSize =
            src[start_index + i].extendedDynamicState3ExtraPrimitiveOverestimationSize;
        ptr[i].extendedDynamicState3DepthClipEnable = src[start_index + i].extendedDynamicState3DepthClipEnable;
        ptr[i].extendedDynamicState3SampleLocationsEnable =
            src[start_index + i].extendedDynamicState3SampleLocationsEnable;
        ptr[i].extendedDynamicState3ColorBlendAdvanced = src[start_index + i].extendedDynamicState3ColorBlendAdvanced;
        ptr[i].extendedDynamicState3ProvokingVertexMode = src[start_index + i].extendedDynamicState3ProvokingVertexMode;
        ptr[i].extendedDynamicState3LineRasterizationMode =
            src[start_index + i].extendedDynamicState3LineRasterizationMode;
        ptr[i].extendedDynamicState3LineStippleEnable = src[start_index + i].extendedDynamicState3LineStippleEnable;
        ptr[i].extendedDynamicState3DepthClipNegativeOneToOne =
            src[start_index + i].extendedDynamicState3DepthClipNegativeOneToOne;
        ptr[i].extendedDynamicState3ViewportWScalingEnable =
            src[start_index + i].extendedDynamicState3ViewportWScalingEnable;
        ptr[i].extendedDynamicState3ViewportSwizzle = src[start_index + i].extendedDynamicState3ViewportSwizzle;
        ptr[i].extendedDynamicState3CoverageToColorEnable =
            src[start_index + i].extendedDynamicState3CoverageToColorEnable;
        ptr[i].extendedDynamicState3CoverageToColorLocation =
            src[start_index + i].extendedDynamicState3CoverageToColorLocation;
        ptr[i].extendedDynamicState3CoverageModulationMode =
            src[start_index + i].extendedDynamicState3CoverageModulationMode;
        ptr[i].extendedDynamicState3CoverageModulationTableEnable =
            src[start_index + i].extendedDynamicState3CoverageModulationTableEnable;
        ptr[i].extendedDynamicState3CoverageModulationTable =
            src[start_index + i].extendedDynamicState3CoverageModulationTable;
        ptr[i].extendedDynamicState3CoverageReductionMode =
            src[start_index + i].extendedDynamicState3CoverageReductionMode;
        ptr[i].extendedDynamicState3RepresentativeFragmentTestEnable =
            src[start_index + i].extendedDynamicState3RepresentativeFragmentTestEnable;
        ptr[i].extendedDynamicState3ShadingRateImageEnable =
            src[start_index + i].extendedDynamicState3ShadingRateImageEnable;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>(
    const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dynamicPrimitiveTopologyUnrestricted = src[start_index + i].dynamicPrimitiveTopologyUnrestricted;
    }
    return ptr;
}

template <>
VkColorBlendEquationEXT* CommandRecorder::CopyArray<VkColorBlendEquationEXT>(const VkColorBlendEquationEXT* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkColorBlendEquationEXT*>(m_allocator.Alloc(sizeof(VkColorBlendEquationEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].srcColorBlendFactor = src[start_index + i].srcColorBlendFactor;
        ptr[i].dstColorBlendFactor = src[start_index + i].dstColorBlendFactor;
        ptr[i].colorBlendOp = src[start_index + i].colorBlendOp;
        ptr[i].srcAlphaBlendFactor = src[start_index + i].srcAlphaBlendFactor;
        ptr[i].dstAlphaBlendFactor = src[start_index + i].dstAlphaBlendFactor;
        ptr[i].alphaBlendOp = src[start_index + i].alphaBlendOp;
    }
    return ptr;
}

template <>
VkColorBlendAdvancedEXT* CommandRecorder::CopyArray<VkColorBlendAdvancedEXT>(const VkColorBlendAdvancedEXT* src,
                                                                             uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkColorBlendAdvancedEXT*>(m_allocator.Alloc(sizeof(VkColorBlendAdvancedEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].advancedBlendOp = src[start_index + i].advancedBlendOp;
        ptr[i].srcPremultiplied = src[start_index + i].srcPremultiplied;
        ptr[i].dstPremultiplied = src[start_index + i].dstPremultiplied;
        ptr[i].blendOverlap = src[start_index + i].blendOverlap;
        ptr[i].clampResults = src[start_index + i].clampResults;
    }
    return ptr;
}

template <>
VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>(
    const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].subpassMergeFeedback = src[start_index + i].subpassMergeFeedback;
    }
    return ptr;
}

template <>
VkRenderPassCreationControlEXT* CommandRecorder::CopyArray<VkRenderPassCreationControlEXT>(
    const VkRenderPassCreationControlEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassCreationControlEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassCreationControlEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].disallowMerging = src[start_index + i].disallowMerging;
    }
    return ptr;
}

template <>
VkRenderPassCreationFeedbackInfoEXT* CommandRecorder::CopyArray<VkRenderPassCreationFeedbackInfoEXT>(
    const VkRenderPassCreationFeedbackInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassCreationFeedbackInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassCreationFeedbackInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].postMergeSubpassCount = src[start_index + i].postMergeSubpassCount;
    }
    return ptr;
}

template <>
VkRenderPassCreationFeedbackCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassCreationFeedbackCreateInfoEXT>(
    const VkRenderPassCreationFeedbackCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassCreationFeedbackCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassCreationFeedbackCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pRenderPassFeedback = src[start_index + i].pRenderPassFeedback;
    }
    return ptr;
}

template <>
VkRenderPassSubpassFeedbackInfoEXT* CommandRecorder::CopyArray<VkRenderPassSubpassFeedbackInfoEXT>(
    const VkRenderPassSubpassFeedbackInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassSubpassFeedbackInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassSubpassFeedbackInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].subpassMergeStatus = src[start_index + i].subpassMergeStatus;
        std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
        ptr[i].postMergeIndex = src[start_index + i].postMergeIndex;
    }
    return ptr;
}

template <>
VkRenderPassSubpassFeedbackCreateInfoEXT* CommandRecorder::CopyArray<VkRenderPassSubpassFeedbackCreateInfoEXT>(
    const VkRenderPassSubpassFeedbackCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRenderPassSubpassFeedbackCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkRenderPassSubpassFeedbackCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pSubpassFeedback = src[start_index + i].pSubpassFeedback;
    }
    return ptr;
}

template <>
VkDirectDriverLoadingInfoLUNARG* CommandRecorder::CopyArray<VkDirectDriverLoadingInfoLUNARG>(
    const VkDirectDriverLoadingInfoLUNARG* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDirectDriverLoadingInfoLUNARG*>(
        m_allocator.Alloc(sizeof(VkDirectDriverLoadingInfoLUNARG) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].pfnGetInstanceProcAddr = src[start_index + i].pfnGetInstanceProcAddr;
    }
    return ptr;
}

template <>
VkDirectDriverLoadingListLUNARG* CommandRecorder::CopyArray<VkDirectDriverLoadingListLUNARG>(
    const VkDirectDriverLoadingListLUNARG* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDirectDriverLoadingListLUNARG*>(
        m_allocator.Alloc(sizeof(VkDirectDriverLoadingListLUNARG) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].mode = src[start_index + i].mode;
        ptr[i].driverCount = src[start_index + i].driverCount;
        ptr[i].pDrivers = nullptr;
        if (src[start_index + i].pDrivers) {
            ptr[i].pDrivers = CopyArray<>(src[start_index + i].pDrivers, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>(
    const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderModuleIdentifier = src[start_index + i].shaderModuleIdentifier;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>(
    const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].shaderModuleIdentifierAlgorithmUUID,
                    src[start_index + i].shaderModuleIdentifierAlgorithmUUID,
                    sizeof(src[start_index + i].shaderModuleIdentifierAlgorithmUUID));
    }
    return ptr;
}

template <>
VkPipelineShaderStageModuleIdentifierCreateInfoEXT*
CommandRecorder::CopyArray<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>(
    const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPipelineShaderStageModuleIdentifierCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkPipelineShaderStageModuleIdentifierCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].identifierSize = src[start_index + i].identifierSize;
        ptr[i].pIdentifier = nullptr;
        if (src[start_index + i].pIdentifier) {
            ptr[i].pIdentifier = CopyArray<>(src[start_index + i].pIdentifier, 0, 1);
        }
    }
    return ptr;
}

template <>
VkShaderModuleIdentifierEXT* CommandRecorder::CopyArray<VkShaderModuleIdentifierEXT>(
    const VkShaderModuleIdentifierEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkShaderModuleIdentifierEXT*>(m_allocator.Alloc(sizeof(VkShaderModuleIdentifierEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].identifierSize = src[start_index + i].identifierSize;
        std::memcpy(ptr[i].identifier, src[start_index + i].identifier, sizeof(src[start_index + i].identifier));
    }
    return ptr;
}

template <>
VkPhysicalDeviceOpticalFlowFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceOpticalFlowFeaturesNV>(
    const VkPhysicalDeviceOpticalFlowFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceOpticalFlowFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].opticalFlow = src[start_index + i].opticalFlow;
    }
    return ptr;
}

template <>
VkPhysicalDeviceOpticalFlowPropertiesNV* CommandRecorder::CopyArray<VkPhysicalDeviceOpticalFlowPropertiesNV>(
    const VkPhysicalDeviceOpticalFlowPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceOpticalFlowPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportedOutputGridSizes = src[start_index + i].supportedOutputGridSizes;
        ptr[i].supportedHintGridSizes = src[start_index + i].supportedHintGridSizes;
        ptr[i].hintSupported = src[start_index + i].hintSupported;
        ptr[i].costSupported = src[start_index + i].costSupported;
        ptr[i].bidirectionalFlowSupported = src[start_index + i].bidirectionalFlowSupported;
        ptr[i].globalFlowSupported = src[start_index + i].globalFlowSupported;
        ptr[i].minWidth = src[start_index + i].minWidth;
        ptr[i].minHeight = src[start_index + i].minHeight;
        ptr[i].maxWidth = src[start_index + i].maxWidth;
        ptr[i].maxHeight = src[start_index + i].maxHeight;
        ptr[i].maxNumRegionsOfInterest = src[start_index + i].maxNumRegionsOfInterest;
    }
    return ptr;
}

template <>
VkOpticalFlowImageFormatInfoNV* CommandRecorder::CopyArray<VkOpticalFlowImageFormatInfoNV>(
    const VkOpticalFlowImageFormatInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOpticalFlowImageFormatInfoNV*>(
        m_allocator.Alloc(sizeof(VkOpticalFlowImageFormatInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].usage = src[start_index + i].usage;
    }
    return ptr;
}

template <>
VkOpticalFlowImageFormatPropertiesNV* CommandRecorder::CopyArray<VkOpticalFlowImageFormatPropertiesNV>(
    const VkOpticalFlowImageFormatPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOpticalFlowImageFormatPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkOpticalFlowImageFormatPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
    }
    return ptr;
}

template <>
VkOpticalFlowSessionCreateInfoNV* CommandRecorder::CopyArray<VkOpticalFlowSessionCreateInfoNV>(
    const VkOpticalFlowSessionCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOpticalFlowSessionCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkOpticalFlowSessionCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].imageFormat = src[start_index + i].imageFormat;
        ptr[i].flowVectorFormat = src[start_index + i].flowVectorFormat;
        ptr[i].costFormat = src[start_index + i].costFormat;
        ptr[i].outputGridSize = src[start_index + i].outputGridSize;
        ptr[i].hintGridSize = src[start_index + i].hintGridSize;
        ptr[i].performanceLevel = src[start_index + i].performanceLevel;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkOpticalFlowSessionCreatePrivateDataInfoNV* CommandRecorder::CopyArray<VkOpticalFlowSessionCreatePrivateDataInfoNV>(
    const VkOpticalFlowSessionCreatePrivateDataInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkOpticalFlowSessionCreatePrivateDataInfoNV*>(
        m_allocator.Alloc(sizeof(VkOpticalFlowSessionCreatePrivateDataInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].id = src[start_index + i].id;
        ptr[i].size = src[start_index + i].size;
        ptr[i].pPrivateData = src[start_index + i].pPrivateData;
    }
    return ptr;
}

template <>
VkOpticalFlowExecuteInfoNV* CommandRecorder::CopyArray<VkOpticalFlowExecuteInfoNV>(
    const VkOpticalFlowExecuteInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkOpticalFlowExecuteInfoNV*>(m_allocator.Alloc(sizeof(VkOpticalFlowExecuteInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].regionCount = src[start_index + i].regionCount;
        ptr[i].pRegions = nullptr;
        if (src[start_index + i].pRegions) {
            ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceLegacyDitheringFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceLegacyDitheringFeaturesEXT>(
    const VkPhysicalDeviceLegacyDitheringFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].legacyDithering = src[start_index + i].legacyDithering;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>(
    const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineProtectedAccess = src[start_index + i].pipelineProtectedAccess;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>(
    const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalFormatResolveFeaturesANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalFormatResolve = src[start_index + i].externalFormatResolve;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>(
    const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalFormatResolvePropertiesANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].nullColorAttachmentWithExternalFormatResolve =
            src[start_index + i].nullColorAttachmentWithExternalFormatResolve;
        ptr[i].externalFormatResolveChromaOffsetX = src[start_index + i].externalFormatResolveChromaOffsetX;
        ptr[i].externalFormatResolveChromaOffsetY = src[start_index + i].externalFormatResolveChromaOffsetY;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

#ifdef VK_USE_PLATFORM_ANDROID_KHR
template <>
VkAndroidHardwareBufferFormatResolvePropertiesANDROID*
CommandRecorder::CopyArray<VkAndroidHardwareBufferFormatResolvePropertiesANDROID>(
    const VkAndroidHardwareBufferFormatResolvePropertiesANDROID* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAndroidHardwareBufferFormatResolvePropertiesANDROID*>(
        m_allocator.Alloc(sizeof(VkAndroidHardwareBufferFormatResolvePropertiesANDROID) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].colorAttachmentFormat = src[start_index + i].colorAttachmentFormat;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_ANDROID_KHR

template <>
VkPhysicalDeviceShaderObjectFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderObjectFeaturesEXT>(
    const VkPhysicalDeviceShaderObjectFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderObjectFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderObject = src[start_index + i].shaderObject;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderObjectPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceShaderObjectPropertiesEXT>(
    const VkPhysicalDeviceShaderObjectPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderObjectPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        std::memcpy(ptr[i].shaderBinaryUUID, src[start_index + i].shaderBinaryUUID,
                    sizeof(src[start_index + i].shaderBinaryUUID));
        ptr[i].shaderBinaryVersion = src[start_index + i].shaderBinaryVersion;
    }
    return ptr;
}

template <>
VkShaderCreateInfoEXT* CommandRecorder::CopyArray<VkShaderCreateInfoEXT>(const VkShaderCreateInfoEXT* src,
                                                                         uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkShaderCreateInfoEXT*>(m_allocator.Alloc(sizeof(VkShaderCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stage = src[start_index + i].stage;
        ptr[i].nextStage = src[start_index + i].nextStage;
        ptr[i].codeType = src[start_index + i].codeType;
        ptr[i].codeSize = src[start_index + i].codeSize;
        ptr[i].pCode = src[start_index + i].pCode;
        ptr[i].pName = nullptr;
        if (src[start_index + i].pName) {
            ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName) + 1);
        }
        ptr[i].setLayoutCount = src[start_index + i].setLayoutCount;
        ptr[i].pSetLayouts = nullptr;
        if (src[start_index + i].pSetLayouts) {
            ptr[i].pSetLayouts = CopyArray<>(src[start_index + i].pSetLayouts, 0, 1);
        }
        ptr[i].pushConstantRangeCount = src[start_index + i].pushConstantRangeCount;
        ptr[i].pPushConstantRanges = nullptr;
        if (src[start_index + i].pPushConstantRanges) {
            ptr[i].pPushConstantRanges = CopyArray<>(src[start_index + i].pPushConstantRanges, 0, 1);
        }
        ptr[i].pSpecializationInfo = src[start_index + i].pSpecializationInfo;
    }
    return ptr;
}

template <>
VkPhysicalDeviceTilePropertiesFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceTilePropertiesFeaturesQCOM>(
    const VkPhysicalDeviceTilePropertiesFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].tileProperties = src[start_index + i].tileProperties;
    }
    return ptr;
}

template <>
VkTilePropertiesQCOM* CommandRecorder::CopyArray<VkTilePropertiesQCOM>(const VkTilePropertiesQCOM* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTilePropertiesQCOM*>(m_allocator.Alloc(sizeof(VkTilePropertiesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].tileSize = src[start_index + i].tileSize;
        ptr[i].apronSize = src[start_index + i].apronSize;
        ptr[i].origin = src[start_index + i].origin;
    }
    return ptr;
}

template <>
VkPhysicalDeviceAmigoProfilingFeaturesSEC* CommandRecorder::CopyArray<VkPhysicalDeviceAmigoProfilingFeaturesSEC>(
    const VkPhysicalDeviceAmigoProfilingFeaturesSEC* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].amigoProfiling = src[start_index + i].amigoProfiling;
    }
    return ptr;
}

template <>
VkAmigoProfilingSubmitInfoSEC* CommandRecorder::CopyArray<VkAmigoProfilingSubmitInfoSEC>(
    const VkAmigoProfilingSubmitInfoSEC* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAmigoProfilingSubmitInfoSEC*>(
        m_allocator.Alloc(sizeof(VkAmigoProfilingSubmitInfoSEC) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].firstDrawTimestamp = src[start_index + i].firstDrawTimestamp;
        ptr[i].swapBufferTimestamp = src[start_index + i].swapBufferTimestamp;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>(
    const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multiviewPerViewViewports = src[start_index + i].multiviewPerViewViewports;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>(
    const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingInvocationReorderReorderingHint =
            src[start_index + i].rayTracingInvocationReorderReorderingHint;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>(
    const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingInvocationReorder = src[start_index + i].rayTracingInvocationReorder;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>(
    const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].extendedSparseAddressSpace = src[start_index + i].extendedSparseAddressSpace;
    }
    return ptr;
}

template <>
VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>(
    const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].extendedSparseAddressSpaceSize = src[start_index + i].extendedSparseAddressSpaceSize;
        ptr[i].extendedSparseImageUsageFlags = src[start_index + i].extendedSparseImageUsageFlags;
        ptr[i].extendedSparseBufferUsageFlags = src[start_index + i].extendedSparseBufferUsageFlags;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>(
    const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].legacyVertexAttributes = src[start_index + i].legacyVertexAttributes;
    }
    return ptr;
}

template <>
VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>(
    const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].nativeUnalignedPerformance = src[start_index + i].nativeUnalignedPerformance;
    }
    return ptr;
}

template <>
VkLayerSettingEXT* CommandRecorder::CopyArray<VkLayerSettingEXT>(const VkLayerSettingEXT* src, uint64_t start_index,
                                                                 uint64_t count) {
    auto ptr = reinterpret_cast<VkLayerSettingEXT*>(m_allocator.Alloc(sizeof(VkLayerSettingEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].pLayerName = nullptr;
        if (src[start_index + i].pLayerName) {
            ptr[i].pLayerName =
                CopyArray<>(src[start_index + i].pLayerName, 0, strlen(src[start_index + i].pLayerName) + 1);
        }
        ptr[i].pSettingName = nullptr;
        if (src[start_index + i].pSettingName) {
            ptr[i].pSettingName =
                CopyArray<>(src[start_index + i].pSettingName, 0, strlen(src[start_index + i].pSettingName) + 1);
        }
        ptr[i].type = src[start_index + i].type;
        ptr[i].valueCount = src[start_index + i].valueCount;
        ptr[i].pValues = src[start_index + i].pValues;
    }
    return ptr;
}

template <>
VkLayerSettingsCreateInfoEXT* CommandRecorder::CopyArray<VkLayerSettingsCreateInfoEXT>(
    const VkLayerSettingsCreateInfoEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLayerSettingsCreateInfoEXT*>(
        m_allocator.Alloc(sizeof(VkLayerSettingsCreateInfoEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].settingCount = src[start_index + i].settingCount;
        ptr[i].pSettings = nullptr;
        if (src[start_index + i].pSettings) {
            ptr[i].pSettings = CopyArray<>(src[start_index + i].pSettings, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>(
    const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderCoreBuiltins = src[start_index + i].shaderCoreBuiltins;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>(
    const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderCoreMask = src[start_index + i].shaderCoreMask;
        ptr[i].shaderCoreCount = src[start_index + i].shaderCoreCount;
        ptr[i].shaderWarpsPerCore = src[start_index + i].shaderWarpsPerCore;
    }
    return ptr;
}

template <>
VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>(
    const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pipelineLibraryGroupHandles = src[start_index + i].pipelineLibraryGroupHandles;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>(
    const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].dynamicRenderingUnusedAttachments = src[start_index + i].dynamicRenderingUnusedAttachments;
    }
    return ptr;
}

template <>
VkLatencySleepModeInfoNV* CommandRecorder::CopyArray<VkLatencySleepModeInfoNV>(const VkLatencySleepModeInfoNV* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLatencySleepModeInfoNV*>(m_allocator.Alloc(sizeof(VkLatencySleepModeInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].lowLatencyMode = src[start_index + i].lowLatencyMode;
        ptr[i].lowLatencyBoost = src[start_index + i].lowLatencyBoost;
        ptr[i].minimumIntervalUs = src[start_index + i].minimumIntervalUs;
    }
    return ptr;
}

template <>
VkLatencySleepInfoNV* CommandRecorder::CopyArray<VkLatencySleepInfoNV>(const VkLatencySleepInfoNV* src,
                                                                       uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLatencySleepInfoNV*>(m_allocator.Alloc(sizeof(VkLatencySleepInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].signalSemaphore = src[start_index + i].signalSemaphore;
        ptr[i].value = src[start_index + i].value;
    }
    return ptr;
}

template <>
VkSetLatencyMarkerInfoNV* CommandRecorder::CopyArray<VkSetLatencyMarkerInfoNV>(const VkSetLatencyMarkerInfoNV* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSetLatencyMarkerInfoNV*>(m_allocator.Alloc(sizeof(VkSetLatencyMarkerInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentID = src[start_index + i].presentID;
        ptr[i].marker = src[start_index + i].marker;
    }
    return ptr;
}

template <>
VkLatencyTimingsFrameReportNV* CommandRecorder::CopyArray<VkLatencyTimingsFrameReportNV>(
    const VkLatencyTimingsFrameReportNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLatencyTimingsFrameReportNV*>(
        m_allocator.Alloc(sizeof(VkLatencyTimingsFrameReportNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentID = src[start_index + i].presentID;
        ptr[i].inputSampleTimeUs = src[start_index + i].inputSampleTimeUs;
        ptr[i].simStartTimeUs = src[start_index + i].simStartTimeUs;
        ptr[i].simEndTimeUs = src[start_index + i].simEndTimeUs;
        ptr[i].renderSubmitStartTimeUs = src[start_index + i].renderSubmitStartTimeUs;
        ptr[i].renderSubmitEndTimeUs = src[start_index + i].renderSubmitEndTimeUs;
        ptr[i].presentStartTimeUs = src[start_index + i].presentStartTimeUs;
        ptr[i].presentEndTimeUs = src[start_index + i].presentEndTimeUs;
        ptr[i].driverStartTimeUs = src[start_index + i].driverStartTimeUs;
        ptr[i].driverEndTimeUs = src[start_index + i].driverEndTimeUs;
        ptr[i].osRenderQueueStartTimeUs = src[start_index + i].osRenderQueueStartTimeUs;
        ptr[i].osRenderQueueEndTimeUs = src[start_index + i].osRenderQueueEndTimeUs;
        ptr[i].gpuRenderStartTimeUs = src[start_index + i].gpuRenderStartTimeUs;
        ptr[i].gpuRenderEndTimeUs = src[start_index + i].gpuRenderEndTimeUs;
    }
    return ptr;
}

template <>
VkGetLatencyMarkerInfoNV* CommandRecorder::CopyArray<VkGetLatencyMarkerInfoNV>(const VkGetLatencyMarkerInfoNV* src,
                                                                               uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkGetLatencyMarkerInfoNV*>(m_allocator.Alloc(sizeof(VkGetLatencyMarkerInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].timingCount = src[start_index + i].timingCount;
        ptr[i].pTimings = nullptr;
        if (src[start_index + i].pTimings) {
            ptr[i].pTimings = CopyArray<>(src[start_index + i].pTimings, 0, 1);
        }
    }
    return ptr;
}

template <>
VkLatencySubmissionPresentIdNV* CommandRecorder::CopyArray<VkLatencySubmissionPresentIdNV>(
    const VkLatencySubmissionPresentIdNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLatencySubmissionPresentIdNV*>(
        m_allocator.Alloc(sizeof(VkLatencySubmissionPresentIdNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentID = src[start_index + i].presentID;
    }
    return ptr;
}

template <>
VkSwapchainLatencyCreateInfoNV* CommandRecorder::CopyArray<VkSwapchainLatencyCreateInfoNV>(
    const VkSwapchainLatencyCreateInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSwapchainLatencyCreateInfoNV*>(
        m_allocator.Alloc(sizeof(VkSwapchainLatencyCreateInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].latencyModeEnable = src[start_index + i].latencyModeEnable;
    }
    return ptr;
}

template <>
VkOutOfBandQueueTypeInfoNV* CommandRecorder::CopyArray<VkOutOfBandQueueTypeInfoNV>(
    const VkOutOfBandQueueTypeInfoNV* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkOutOfBandQueueTypeInfoNV*>(m_allocator.Alloc(sizeof(VkOutOfBandQueueTypeInfoNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].queueType = src[start_index + i].queueType;
    }
    return ptr;
}

template <>
VkLatencySurfaceCapabilitiesNV* CommandRecorder::CopyArray<VkLatencySurfaceCapabilitiesNV>(
    const VkLatencySurfaceCapabilitiesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkLatencySurfaceCapabilitiesNV*>(
        m_allocator.Alloc(sizeof(VkLatencySurfaceCapabilitiesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].presentModeCount = src[start_index + i].presentModeCount;
        ptr[i].pPresentModes = nullptr;
        if (src[start_index + i].pPresentModes) {
            ptr[i].pPresentModes = CopyArray<>(src[start_index + i].pPresentModes, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>(
    const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].multiviewPerViewRenderAreas = src[start_index + i].multiviewPerViewRenderAreas;
    }
    return ptr;
}

template <>
VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*
CommandRecorder::CopyArray<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>(
    const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].perViewRenderAreaCount = src[start_index + i].perViewRenderAreaCount;
        ptr[i].pPerViewRenderAreas = nullptr;
        if (src[start_index + i].pPerViewRenderAreas) {
            ptr[i].pPerViewRenderAreas = CopyArray<>(src[start_index + i].pPerViewRenderAreas, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDevicePerStageDescriptorSetFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>(
    const VkPhysicalDevicePerStageDescriptorSetFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDevicePerStageDescriptorSetFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDevicePerStageDescriptorSetFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].perStageDescriptorSet = src[start_index + i].perStageDescriptorSet;
        ptr[i].dynamicPipelineLayout = src[start_index + i].dynamicPipelineLayout;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageProcessing2FeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessing2FeaturesQCOM>(
    const VkPhysicalDeviceImageProcessing2FeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageProcessing2FeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].textureBlockMatch2 = src[start_index + i].textureBlockMatch2;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageProcessing2PropertiesQCOM*
CommandRecorder::CopyArray<VkPhysicalDeviceImageProcessing2PropertiesQCOM>(
    const VkPhysicalDeviceImageProcessing2PropertiesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageProcessing2PropertiesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxBlockMatchWindow = src[start_index + i].maxBlockMatchWindow;
    }
    return ptr;
}

template <>
VkSamplerBlockMatchWindowCreateInfoQCOM* CommandRecorder::CopyArray<VkSamplerBlockMatchWindowCreateInfoQCOM>(
    const VkSamplerBlockMatchWindowCreateInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerBlockMatchWindowCreateInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkSamplerBlockMatchWindowCreateInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].windowExtent = src[start_index + i].windowExtent;
        ptr[i].windowCompareMode = src[start_index + i].windowCompareMode;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCubicWeightsFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceCubicWeightsFeaturesQCOM>(
    const VkPhysicalDeviceCubicWeightsFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCubicWeightsFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].selectableCubicWeights = src[start_index + i].selectableCubicWeights;
    }
    return ptr;
}

template <>
VkSamplerCubicWeightsCreateInfoQCOM* CommandRecorder::CopyArray<VkSamplerCubicWeightsCreateInfoQCOM>(
    const VkSamplerCubicWeightsCreateInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerCubicWeightsCreateInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkSamplerCubicWeightsCreateInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cubicWeights = src[start_index + i].cubicWeights;
    }
    return ptr;
}

template <>
VkBlitImageCubicWeightsInfoQCOM* CommandRecorder::CopyArray<VkBlitImageCubicWeightsInfoQCOM>(
    const VkBlitImageCubicWeightsInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkBlitImageCubicWeightsInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkBlitImageCubicWeightsInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cubicWeights = src[start_index + i].cubicWeights;
    }
    return ptr;
}

template <>
VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>(
    const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].ycbcrDegamma = src[start_index + i].ycbcrDegamma;
    }
    return ptr;
}

template <>
VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*
CommandRecorder::CopyArray<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>(
    const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM*>(
        m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].enableYDegamma = src[start_index + i].enableYDegamma;
        ptr[i].enableCbCrDegamma = src[start_index + i].enableCbCrDegamma;
    }
    return ptr;
}

template <>
VkPhysicalDeviceCubicClampFeaturesQCOM* CommandRecorder::CopyArray<VkPhysicalDeviceCubicClampFeaturesQCOM>(
    const VkPhysicalDeviceCubicClampFeaturesQCOM* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceCubicClampFeaturesQCOM*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].cubicRangeClamp = src[start_index + i].cubicRangeClamp;
    }
    return ptr;
}

template <>
VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>(
    const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].attachmentFeedbackLoopDynamicState = src[start_index + i].attachmentFeedbackLoopDynamicState;
    }
    return ptr;
}

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenBufferPropertiesQNX* CommandRecorder::CopyArray<VkScreenBufferPropertiesQNX>(
    const VkScreenBufferPropertiesQNX* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkScreenBufferPropertiesQNX*>(m_allocator.Alloc(sizeof(VkScreenBufferPropertiesQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].allocationSize = src[start_index + i].allocationSize;
        ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkScreenBufferFormatPropertiesQNX* CommandRecorder::CopyArray<VkScreenBufferFormatPropertiesQNX>(
    const VkScreenBufferFormatPropertiesQNX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkScreenBufferFormatPropertiesQNX*>(
        m_allocator.Alloc(sizeof(VkScreenBufferFormatPropertiesQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].format = src[start_index + i].format;
        ptr[i].externalFormat = src[start_index + i].externalFormat;
        ptr[i].screenUsage = src[start_index + i].screenUsage;
        ptr[i].formatFeatures = src[start_index + i].formatFeatures;
        ptr[i].samplerYcbcrConversionComponents = src[start_index + i].samplerYcbcrConversionComponents;
        ptr[i].suggestedYcbcrModel = src[start_index + i].suggestedYcbcrModel;
        ptr[i].suggestedYcbcrRange = src[start_index + i].suggestedYcbcrRange;
        ptr[i].suggestedXChromaOffset = src[start_index + i].suggestedXChromaOffset;
        ptr[i].suggestedYChromaOffset = src[start_index + i].suggestedYChromaOffset;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkImportScreenBufferInfoQNX* CommandRecorder::CopyArray<VkImportScreenBufferInfoQNX>(
    const VkImportScreenBufferInfoQNX* src, uint64_t start_index, uint64_t count) {
    auto ptr =
        reinterpret_cast<VkImportScreenBufferInfoQNX*>(m_allocator.Alloc(sizeof(VkImportScreenBufferInfoQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].buffer = src[start_index + i].buffer;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkExternalFormatQNX* CommandRecorder::CopyArray<VkExternalFormatQNX>(const VkExternalFormatQNX* src,
                                                                     uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkExternalFormatQNX*>(m_allocator.Alloc(sizeof(VkExternalFormatQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].externalFormat = src[start_index + i].externalFormat;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

#ifdef VK_USE_PLATFORM_SCREEN_QNX
template <>
VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*
CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>(
    const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].screenBufferImport = src[start_index + i].screenBufferImport;
    }
    return ptr;
}
#endif  // VK_USE_PLATFORM_SCREEN_QNX

template <>
VkPhysicalDeviceLayeredDriverPropertiesMSFT* CommandRecorder::CopyArray<VkPhysicalDeviceLayeredDriverPropertiesMSFT>(
    const VkPhysicalDeviceLayeredDriverPropertiesMSFT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceLayeredDriverPropertiesMSFT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].underlyingAPI = src[start_index + i].underlyingAPI;
    }
    return ptr;
}

template <>
VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>(
    const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].descriptorPoolOverallocation = src[start_index + i].descriptorPoolOverallocation;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRawAccessChainsFeaturesNV* CommandRecorder::CopyArray<VkPhysicalDeviceRawAccessChainsFeaturesNV>(
    const VkPhysicalDeviceRawAccessChainsFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRawAccessChainsFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRawAccessChainsFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderRawAccessChains = src[start_index + i].shaderRawAccessChains;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>(
    const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderFloat16VectorAtomics = src[start_index + i].shaderFloat16VectorAtomics;
    }
    return ptr;
}

template <>
VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*
CommandRecorder::CopyArray<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>(
    const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderReplicatedComposites = src[start_index + i].shaderReplicatedComposites;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingValidationFeaturesNV*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingValidationFeaturesNV>(
    const VkPhysicalDeviceRayTracingValidationFeaturesNV* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingValidationFeaturesNV*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingValidationFeaturesNV) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingValidation = src[start_index + i].rayTracingValidation;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageAlignmentControlFeaturesMESA*
CommandRecorder::CopyArray<VkPhysicalDeviceImageAlignmentControlFeaturesMESA>(
    const VkPhysicalDeviceImageAlignmentControlFeaturesMESA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageAlignmentControlFeaturesMESA*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageAlignmentControlFeaturesMESA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].imageAlignmentControl = src[start_index + i].imageAlignmentControl;
    }
    return ptr;
}

template <>
VkPhysicalDeviceImageAlignmentControlPropertiesMESA*
CommandRecorder::CopyArray<VkPhysicalDeviceImageAlignmentControlPropertiesMESA>(
    const VkPhysicalDeviceImageAlignmentControlPropertiesMESA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceImageAlignmentControlPropertiesMESA*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceImageAlignmentControlPropertiesMESA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].supportedImageAlignmentMask = src[start_index + i].supportedImageAlignmentMask;
    }
    return ptr;
}

template <>
VkImageAlignmentControlCreateInfoMESA* CommandRecorder::CopyArray<VkImageAlignmentControlCreateInfoMESA>(
    const VkImageAlignmentControlCreateInfoMESA* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkImageAlignmentControlCreateInfoMESA*>(
        m_allocator.Alloc(sizeof(VkImageAlignmentControlCreateInfoMESA) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maximumRequestedAlignment = src[start_index + i].maximumRequestedAlignment;
    }
    return ptr;
}

template <>
VkAccelerationStructureBuildRangeInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildRangeInfoKHR>(
    const VkAccelerationStructureBuildRangeInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureBuildRangeInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureBuildRangeInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].primitiveCount = src[start_index + i].primitiveCount;
        ptr[i].primitiveOffset = src[start_index + i].primitiveOffset;
        ptr[i].firstVertex = src[start_index + i].firstVertex;
        ptr[i].transformOffset = src[start_index + i].transformOffset;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryTrianglesDataKHR*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryTrianglesDataKHR>(
    const VkAccelerationStructureGeometryTrianglesDataKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryTrianglesDataKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryTrianglesDataKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].vertexFormat = src[start_index + i].vertexFormat;
        ptr[i].vertexData = src[start_index + i].vertexData;
        ptr[i].vertexStride = src[start_index + i].vertexStride;
        ptr[i].maxVertex = src[start_index + i].maxVertex;
        ptr[i].indexType = src[start_index + i].indexType;
        ptr[i].indexData = src[start_index + i].indexData;
        ptr[i].transformData = src[start_index + i].transformData;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryAabbsDataKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryAabbsDataKHR>(
    const VkAccelerationStructureGeometryAabbsDataKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryAabbsDataKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryAabbsDataKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].data = src[start_index + i].data;
        ptr[i].stride = src[start_index + i].stride;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryInstancesDataKHR*
CommandRecorder::CopyArray<VkAccelerationStructureGeometryInstancesDataKHR>(
    const VkAccelerationStructureGeometryInstancesDataKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryInstancesDataKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryInstancesDataKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].arrayOfPointers = src[start_index + i].arrayOfPointers;
        ptr[i].data = src[start_index + i].data;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryDataKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryDataKHR>(
    const VkAccelerationStructureGeometryDataKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryDataKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryDataKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].triangles = src[start_index + i].triangles;
        ptr[i].aabbs = src[start_index + i].aabbs;
        ptr[i].instances = src[start_index + i].instances;
    }
    return ptr;
}

template <>
VkAccelerationStructureGeometryKHR* CommandRecorder::CopyArray<VkAccelerationStructureGeometryKHR>(
    const VkAccelerationStructureGeometryKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureGeometryKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].geometryType = src[start_index + i].geometryType;
        ptr[i].geometry = src[start_index + i].geometry;
        ptr[i].flags = src[start_index + i].flags;
    }
    return ptr;
}

template <>
VkAccelerationStructureBuildGeometryInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildGeometryInfoKHR>(
    const VkAccelerationStructureBuildGeometryInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureBuildGeometryInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureBuildGeometryInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].mode = src[start_index + i].mode;
        ptr[i].srcAccelerationStructure = src[start_index + i].srcAccelerationStructure;
        ptr[i].dstAccelerationStructure = src[start_index + i].dstAccelerationStructure;
        ptr[i].geometryCount = src[start_index + i].geometryCount;
        ptr[i].pGeometries = nullptr;
        if (src[start_index + i].pGeometries) {
            ptr[i].pGeometries = CopyArray<>(src[start_index + i].pGeometries, 0, 1);
        }
        ptr[i].ppGeometries = nullptr;
        if (src[start_index + i].ppGeometries) {
            ptr[i].ppGeometries = CopyArray<>(src[start_index + i].ppGeometries, 0, 1);
        }
        ptr[i].scratchData = src[start_index + i].scratchData;
    }
    return ptr;
}

template <>
VkAccelerationStructureCreateInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoKHR>(
    const VkAccelerationStructureCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].createFlags = src[start_index + i].createFlags;
        ptr[i].buffer = src[start_index + i].buffer;
        ptr[i].offset = src[start_index + i].offset;
        ptr[i].size = src[start_index + i].size;
        ptr[i].type = src[start_index + i].type;
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
    }
    return ptr;
}

template <>
VkWriteDescriptorSetAccelerationStructureKHR* CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureKHR>(
    const VkWriteDescriptorSetAccelerationStructureKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR*>(
        m_allocator.Alloc(sizeof(VkWriteDescriptorSetAccelerationStructureKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructureCount = src[start_index + i].accelerationStructureCount;
        ptr[i].pAccelerationStructures = nullptr;
        if (src[start_index + i].pAccelerationStructures) {
            ptr[i].pAccelerationStructures = CopyArray<>(src[start_index + i].pAccelerationStructures, 0, 1);
        }
    }
    return ptr;
}

template <>
VkPhysicalDeviceAccelerationStructureFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(
    const VkPhysicalDeviceAccelerationStructureFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
        ptr[i].accelerationStructureCaptureReplay = src[start_index + i].accelerationStructureCaptureReplay;
        ptr[i].accelerationStructureIndirectBuild = src[start_index + i].accelerationStructureIndirectBuild;
        ptr[i].accelerationStructureHostCommands = src[start_index + i].accelerationStructureHostCommands;
        ptr[i].descriptorBindingAccelerationStructureUpdateAfterBind =
            src[start_index + i].descriptorBindingAccelerationStructureUpdateAfterBind;
    }
    return ptr;
}

template <>
VkPhysicalDeviceAccelerationStructurePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(
    const VkPhysicalDeviceAccelerationStructurePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxGeometryCount = src[start_index + i].maxGeometryCount;
        ptr[i].maxInstanceCount = src[start_index + i].maxInstanceCount;
        ptr[i].maxPrimitiveCount = src[start_index + i].maxPrimitiveCount;
        ptr[i].maxPerStageDescriptorAccelerationStructures =
            src[start_index + i].maxPerStageDescriptorAccelerationStructures;
        ptr[i].maxPerStageDescriptorUpdateAfterBindAccelerationStructures =
            src[start_index + i].maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
        ptr[i].maxDescriptorSetAccelerationStructures = src[start_index + i].maxDescriptorSetAccelerationStructures;
        ptr[i].maxDescriptorSetUpdateAfterBindAccelerationStructures =
            src[start_index + i].maxDescriptorSetUpdateAfterBindAccelerationStructures;
        ptr[i].minAccelerationStructureScratchOffsetAlignment =
            src[start_index + i].minAccelerationStructureScratchOffsetAlignment;
    }
    return ptr;
}

template <>
VkAccelerationStructureDeviceAddressInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureDeviceAddressInfoKHR>(
    const VkAccelerationStructureDeviceAddressInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureDeviceAddressInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureDeviceAddressInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
    }
    return ptr;
}

template <>
VkAccelerationStructureVersionInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureVersionInfoKHR>(
    const VkAccelerationStructureVersionInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureVersionInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureVersionInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].pVersionData = nullptr;
        if (src[start_index + i].pVersionData) {
            ptr[i].pVersionData = CopyArray<>(src[start_index + i].pVersionData, 0, 1);
        }
    }
    return ptr;
}

template <>
VkCopyAccelerationStructureToMemoryInfoKHR* CommandRecorder::CopyArray<VkCopyAccelerationStructureToMemoryInfoKHR>(
    const VkCopyAccelerationStructureToMemoryInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyAccelerationStructureToMemoryInfoKHR*>(
        m_allocator.Alloc(sizeof(VkCopyAccelerationStructureToMemoryInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkCopyMemoryToAccelerationStructureInfoKHR* CommandRecorder::CopyArray<VkCopyMemoryToAccelerationStructureInfoKHR>(
    const VkCopyMemoryToAccelerationStructureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyMemoryToAccelerationStructureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkCopyMemoryToAccelerationStructureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkCopyAccelerationStructureInfoKHR* CommandRecorder::CopyArray<VkCopyAccelerationStructureInfoKHR>(
    const VkCopyAccelerationStructureInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkCopyAccelerationStructureInfoKHR*>(
        m_allocator.Alloc(sizeof(VkCopyAccelerationStructureInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].src = src[start_index + i].src;
        ptr[i].dst = src[start_index + i].dst;
        ptr[i].mode = src[start_index + i].mode;
    }
    return ptr;
}

template <>
VkAccelerationStructureBuildSizesInfoKHR* CommandRecorder::CopyArray<VkAccelerationStructureBuildSizesInfoKHR>(
    const VkAccelerationStructureBuildSizesInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkAccelerationStructureBuildSizesInfoKHR*>(
        m_allocator.Alloc(sizeof(VkAccelerationStructureBuildSizesInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].accelerationStructureSize = src[start_index + i].accelerationStructureSize;
        ptr[i].updateScratchSize = src[start_index + i].updateScratchSize;
        ptr[i].buildScratchSize = src[start_index + i].buildScratchSize;
    }
    return ptr;
}

template <>
VkRayTracingShaderGroupCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoKHR>(
    const VkRayTracingShaderGroupCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRayTracingShaderGroupCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRayTracingShaderGroupCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].type = src[start_index + i].type;
        ptr[i].generalShader = src[start_index + i].generalShader;
        ptr[i].closestHitShader = src[start_index + i].closestHitShader;
        ptr[i].anyHitShader = src[start_index + i].anyHitShader;
        ptr[i].intersectionShader = src[start_index + i].intersectionShader;
        ptr[i].pShaderGroupCaptureReplayHandle = src[start_index + i].pShaderGroupCaptureReplayHandle;
    }
    return ptr;
}

template <>
VkRayTracingPipelineInterfaceCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingPipelineInterfaceCreateInfoKHR>(
    const VkRayTracingPipelineInterfaceCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRayTracingPipelineInterfaceCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxPipelineRayPayloadSize = src[start_index + i].maxPipelineRayPayloadSize;
        ptr[i].maxPipelineRayHitAttributeSize = src[start_index + i].maxPipelineRayHitAttributeSize;
    }
    return ptr;
}

template <>
VkRayTracingPipelineCreateInfoKHR* CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoKHR>(
    const VkRayTracingPipelineCreateInfoKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkRayTracingPipelineCreateInfoKHR*>(
        m_allocator.Alloc(sizeof(VkRayTracingPipelineCreateInfoKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].flags = src[start_index + i].flags;
        ptr[i].stageCount = src[start_index + i].stageCount;
        ptr[i].pStages = nullptr;
        if (src[start_index + i].pStages) {
            ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
        }
        ptr[i].groupCount = src[start_index + i].groupCount;
        ptr[i].pGroups = nullptr;
        if (src[start_index + i].pGroups) {
            ptr[i].pGroups = CopyArray<>(src[start_index + i].pGroups, 0, 1);
        }
        ptr[i].maxPipelineRayRecursionDepth = src[start_index + i].maxPipelineRayRecursionDepth;
        ptr[i].pLibraryInfo = src[start_index + i].pLibraryInfo;
        ptr[i].pLibraryInterface = src[start_index + i].pLibraryInterface;
        ptr[i].pDynamicState = src[start_index + i].pDynamicState;
        ptr[i].layout = src[start_index + i].layout;
        ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
        ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingPipelineFeaturesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(
    const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayTracingPipeline = src[start_index + i].rayTracingPipeline;
        ptr[i].rayTracingPipelineShaderGroupHandleCaptureReplay =
            src[start_index + i].rayTracingPipelineShaderGroupHandleCaptureReplay;
        ptr[i].rayTracingPipelineShaderGroupHandleCaptureReplayMixed =
            src[start_index + i].rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
        ptr[i].rayTracingPipelineTraceRaysIndirect = src[start_index + i].rayTracingPipelineTraceRaysIndirect;
        ptr[i].rayTraversalPrimitiveCulling = src[start_index + i].rayTraversalPrimitiveCulling;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayTracingPipelinePropertiesKHR*
CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(
    const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].shaderGroupHandleSize = src[start_index + i].shaderGroupHandleSize;
        ptr[i].maxRayRecursionDepth = src[start_index + i].maxRayRecursionDepth;
        ptr[i].maxShaderGroupStride = src[start_index + i].maxShaderGroupStride;
        ptr[i].shaderGroupBaseAlignment = src[start_index + i].shaderGroupBaseAlignment;
        ptr[i].shaderGroupHandleCaptureReplaySize = src[start_index + i].shaderGroupHandleCaptureReplaySize;
        ptr[i].maxRayDispatchInvocationCount = src[start_index + i].maxRayDispatchInvocationCount;
        ptr[i].shaderGroupHandleAlignment = src[start_index + i].shaderGroupHandleAlignment;
        ptr[i].maxRayHitAttributeSize = src[start_index + i].maxRayHitAttributeSize;
    }
    return ptr;
}

template <>
VkStridedDeviceAddressRegionKHR* CommandRecorder::CopyArray<VkStridedDeviceAddressRegionKHR>(
    const VkStridedDeviceAddressRegionKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkStridedDeviceAddressRegionKHR*>(
        m_allocator.Alloc(sizeof(VkStridedDeviceAddressRegionKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].deviceAddress = src[start_index + i].deviceAddress;
        ptr[i].stride = src[start_index + i].stride;
        ptr[i].size = src[start_index + i].size;
    }
    return ptr;
}

template <>
VkTraceRaysIndirectCommandKHR* CommandRecorder::CopyArray<VkTraceRaysIndirectCommandKHR>(
    const VkTraceRaysIndirectCommandKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkTraceRaysIndirectCommandKHR*>(
        m_allocator.Alloc(sizeof(VkTraceRaysIndirectCommandKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].width = src[start_index + i].width;
        ptr[i].height = src[start_index + i].height;
        ptr[i].depth = src[start_index + i].depth;
    }
    return ptr;
}

template <>
VkPhysicalDeviceRayQueryFeaturesKHR* CommandRecorder::CopyArray<VkPhysicalDeviceRayQueryFeaturesKHR>(
    const VkPhysicalDeviceRayQueryFeaturesKHR* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceRayQueryFeaturesKHR) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].rayQuery = src[start_index + i].rayQuery;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMeshShaderFeaturesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderFeaturesEXT>(
    const VkPhysicalDeviceMeshShaderFeaturesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMeshShaderFeaturesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].taskShader = src[start_index + i].taskShader;
        ptr[i].meshShader = src[start_index + i].meshShader;
        ptr[i].multiviewMeshShader = src[start_index + i].multiviewMeshShader;
        ptr[i].primitiveFragmentShadingRateMeshShader = src[start_index + i].primitiveFragmentShadingRateMeshShader;
        ptr[i].meshShaderQueries = src[start_index + i].meshShaderQueries;
    }
    return ptr;
}

template <>
VkPhysicalDeviceMeshShaderPropertiesEXT* CommandRecorder::CopyArray<VkPhysicalDeviceMeshShaderPropertiesEXT>(
    const VkPhysicalDeviceMeshShaderPropertiesEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkPhysicalDeviceMeshShaderPropertiesEXT*>(
        m_allocator.Alloc(sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].sType = src[start_index + i].sType;
        ptr[i].pNext = src[start_index + i].pNext;
        ptr[i].maxTaskWorkGroupTotalCount = src[start_index + i].maxTaskWorkGroupTotalCount;
        std::memcpy(ptr[i].maxTaskWorkGroupCount, src[start_index + i].maxTaskWorkGroupCount,
                    sizeof(src[start_index + i].maxTaskWorkGroupCount));
        ptr[i].maxTaskWorkGroupInvocations = src[start_index + i].maxTaskWorkGroupInvocations;
        std::memcpy(ptr[i].maxTaskWorkGroupSize, src[start_index + i].maxTaskWorkGroupSize,
                    sizeof(src[start_index + i].maxTaskWorkGroupSize));
        ptr[i].maxTaskPayloadSize = src[start_index + i].maxTaskPayloadSize;
        ptr[i].maxTaskSharedMemorySize = src[start_index + i].maxTaskSharedMemorySize;
        ptr[i].maxTaskPayloadAndSharedMemorySize = src[start_index + i].maxTaskPayloadAndSharedMemorySize;
        ptr[i].maxMeshWorkGroupTotalCount = src[start_index + i].maxMeshWorkGroupTotalCount;
        std::memcpy(ptr[i].maxMeshWorkGroupCount, src[start_index + i].maxMeshWorkGroupCount,
                    sizeof(src[start_index + i].maxMeshWorkGroupCount));
        ptr[i].maxMeshWorkGroupInvocations = src[start_index + i].maxMeshWorkGroupInvocations;
        std::memcpy(ptr[i].maxMeshWorkGroupSize, src[start_index + i].maxMeshWorkGroupSize,
                    sizeof(src[start_index + i].maxMeshWorkGroupSize));
        ptr[i].maxMeshSharedMemorySize = src[start_index + i].maxMeshSharedMemorySize;
        ptr[i].maxMeshPayloadAndSharedMemorySize = src[start_index + i].maxMeshPayloadAndSharedMemorySize;
        ptr[i].maxMeshOutputMemorySize = src[start_index + i].maxMeshOutputMemorySize;
        ptr[i].maxMeshPayloadAndOutputMemorySize = src[start_index + i].maxMeshPayloadAndOutputMemorySize;
        ptr[i].maxMeshOutputComponents = src[start_index + i].maxMeshOutputComponents;
        ptr[i].maxMeshOutputVertices = src[start_index + i].maxMeshOutputVertices;
        ptr[i].maxMeshOutputPrimitives = src[start_index + i].maxMeshOutputPrimitives;
        ptr[i].maxMeshOutputLayers = src[start_index + i].maxMeshOutputLayers;
        ptr[i].maxMeshMultiviewViewCount = src[start_index + i].maxMeshMultiviewViewCount;
        ptr[i].meshOutputPerVertexGranularity = src[start_index + i].meshOutputPerVertexGranularity;
        ptr[i].meshOutputPerPrimitiveGranularity = src[start_index + i].meshOutputPerPrimitiveGranularity;
        ptr[i].maxPreferredTaskWorkGroupInvocations = src[start_index + i].maxPreferredTaskWorkGroupInvocations;
        ptr[i].maxPreferredMeshWorkGroupInvocations = src[start_index + i].maxPreferredMeshWorkGroupInvocations;
        ptr[i].prefersLocalInvocationVertexOutput = src[start_index + i].prefersLocalInvocationVertexOutput;
        ptr[i].prefersLocalInvocationPrimitiveOutput = src[start_index + i].prefersLocalInvocationPrimitiveOutput;
        ptr[i].prefersCompactVertexOutput = src[start_index + i].prefersCompactVertexOutput;
        ptr[i].prefersCompactPrimitiveOutput = src[start_index + i].prefersCompactPrimitiveOutput;
    }
    return ptr;
}

template <>
VkDrawMeshTasksIndirectCommandEXT* CommandRecorder::CopyArray<VkDrawMeshTasksIndirectCommandEXT>(
    const VkDrawMeshTasksIndirectCommandEXT* src, uint64_t start_index, uint64_t count) {
    auto ptr = reinterpret_cast<VkDrawMeshTasksIndirectCommandEXT*>(
        m_allocator.Alloc(sizeof(VkDrawMeshTasksIndirectCommandEXT) * count));
    for (uint64_t i = 0; i < count; ++i) {
        ptr[i].groupCountX = src[start_index + i].groupCountX;
        ptr[i].groupCountY = src[start_index + i].groupCountY;
        ptr[i].groupCountZ = src[start_index + i].groupCountZ;
    }
    return ptr;
}

BeginCommandBufferArgs* CommandRecorder::RecordBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                                                  const VkCommandBufferBeginInfo* pBeginInfo) {
    auto* args = Alloc<BeginCommandBufferArgs>();
    args->commandBuffer = commandBuffer;
    if (pBeginInfo) {
        args->pBeginInfo = CopyArray(pBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

EndCommandBufferArgs* CommandRecorder::RecordEndCommandBuffer(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<EndCommandBufferArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

ResetCommandBufferArgs* CommandRecorder::RecordResetCommandBuffer(VkCommandBuffer commandBuffer,
                                                                  VkCommandBufferResetFlags flags) {
    auto* args = Alloc<ResetCommandBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->flags = flags;
    return args;
}

CmdBindPipelineArgs* CommandRecorder::RecordCmdBindPipeline(VkCommandBuffer commandBuffer,
                                                            VkPipelineBindPoint pipelineBindPoint,
                                                            VkPipeline pipeline) {
    auto* args = Alloc<CmdBindPipelineArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->pipeline = pipeline;
    return args;
}

CmdSetViewportArgs* CommandRecorder::RecordCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                          uint32_t viewportCount, const VkViewport* pViewports) {
    auto* args = Alloc<CmdSetViewportArgs>();
    args->commandBuffer = commandBuffer;
    args->firstViewport = firstViewport;
    args->viewportCount = viewportCount;
    if (pViewports) {
        args->pViewports = CopyArray(pViewports, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetScissorArgs* CommandRecorder::RecordCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor,
                                                        uint32_t scissorCount, const VkRect2D* pScissors) {
    auto* args = Alloc<CmdSetScissorArgs>();
    args->commandBuffer = commandBuffer;
    args->firstScissor = firstScissor;
    args->scissorCount = scissorCount;
    if (pScissors) {
        args->pScissors = CopyArray(pScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(scissorCount));
    }
    return args;
}

CmdSetLineWidthArgs* CommandRecorder::RecordCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    auto* args = Alloc<CmdSetLineWidthArgs>();
    args->commandBuffer = commandBuffer;
    args->lineWidth = lineWidth;
    return args;
}

CmdSetDepthBiasArgs* CommandRecorder::RecordCmdSetDepthBias(VkCommandBuffer commandBuffer,
                                                            float depthBiasConstantFactor, float depthBiasClamp,
                                                            float depthBiasSlopeFactor) {
    auto* args = Alloc<CmdSetDepthBiasArgs>();
    args->commandBuffer = commandBuffer;
    args->depthBiasConstantFactor = depthBiasConstantFactor;
    args->depthBiasClamp = depthBiasClamp;
    args->depthBiasSlopeFactor = depthBiasSlopeFactor;
    return args;
}

CmdSetBlendConstantsArgs* CommandRecorder::RecordCmdSetBlendConstants(VkCommandBuffer commandBuffer,
                                                                      const float blendConstants[4]) {
    auto* args = Alloc<CmdSetBlendConstantsArgs>();
    args->commandBuffer = commandBuffer;
    for (uint32_t i = 0; i < 4; ++i) {
        args->blendConstants[i] = blendConstants[i];
    }
    return args;
}

CmdSetDepthBoundsArgs* CommandRecorder::RecordCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds,
                                                                float maxDepthBounds) {
    auto* args = Alloc<CmdSetDepthBoundsArgs>();
    args->commandBuffer = commandBuffer;
    args->minDepthBounds = minDepthBounds;
    args->maxDepthBounds = maxDepthBounds;
    return args;
}

CmdSetStencilCompareMaskArgs* CommandRecorder::RecordCmdSetStencilCompareMask(VkCommandBuffer commandBuffer,
                                                                              VkStencilFaceFlags faceMask,
                                                                              uint32_t compareMask) {
    auto* args = Alloc<CmdSetStencilCompareMaskArgs>();
    args->commandBuffer = commandBuffer;
    args->faceMask = faceMask;
    args->compareMask = compareMask;
    return args;
}

CmdSetStencilWriteMaskArgs* CommandRecorder::RecordCmdSetStencilWriteMask(VkCommandBuffer commandBuffer,
                                                                          VkStencilFaceFlags faceMask,
                                                                          uint32_t writeMask) {
    auto* args = Alloc<CmdSetStencilWriteMaskArgs>();
    args->commandBuffer = commandBuffer;
    args->faceMask = faceMask;
    args->writeMask = writeMask;
    return args;
}

CmdSetStencilReferenceArgs* CommandRecorder::RecordCmdSetStencilReference(VkCommandBuffer commandBuffer,
                                                                          VkStencilFaceFlags faceMask,
                                                                          uint32_t reference) {
    auto* args = Alloc<CmdSetStencilReferenceArgs>();
    args->commandBuffer = commandBuffer;
    args->faceMask = faceMask;
    args->reference = reference;
    return args;
}

CmdBindDescriptorSetsArgs* CommandRecorder::RecordCmdBindDescriptorSets(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet,
    uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount,
    const uint32_t* pDynamicOffsets) {
    auto* args = Alloc<CmdBindDescriptorSetsArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->layout = layout;
    args->firstSet = firstSet;
    args->descriptorSetCount = descriptorSetCount;
    if (pDescriptorSets) {
        args->pDescriptorSets =
            CopyArray(pDescriptorSets, static_cast<uint64_t>(0U), static_cast<uint64_t>(descriptorSetCount));
    }
    args->dynamicOffsetCount = dynamicOffsetCount;
    if (pDynamicOffsets) {
        args->pDynamicOffsets =
            CopyArray(pDynamicOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(dynamicOffsetCount));
    }
    return args;
}

CmdBindIndexBufferArgs* CommandRecorder::RecordCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                  VkDeviceSize offset, VkIndexType indexType) {
    auto* args = Alloc<CmdBindIndexBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->indexType = indexType;
    return args;
}

CmdBindVertexBuffersArgs* CommandRecorder::RecordCmdBindVertexBuffers(VkCommandBuffer commandBuffer,
                                                                      uint32_t firstBinding, uint32_t bindingCount,
                                                                      const VkBuffer* pBuffers,
                                                                      const VkDeviceSize* pOffsets) {
    auto* args = Alloc<CmdBindVertexBuffersArgs>();
    args->commandBuffer = commandBuffer;
    args->firstBinding = firstBinding;
    args->bindingCount = bindingCount;
    if (pBuffers) {
        args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pOffsets) {
        args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    return args;
}

CmdDrawArgs* CommandRecorder::RecordCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
                                            uint32_t firstVertex, uint32_t firstInstance) {
    auto* args = Alloc<CmdDrawArgs>();
    args->commandBuffer = commandBuffer;
    args->vertexCount = vertexCount;
    args->instanceCount = instanceCount;
    args->firstVertex = firstVertex;
    args->firstInstance = firstInstance;
    return args;
}

CmdDrawIndexedArgs* CommandRecorder::RecordCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount,
                                                          uint32_t instanceCount, uint32_t firstIndex,
                                                          int32_t vertexOffset, uint32_t firstInstance) {
    auto* args = Alloc<CmdDrawIndexedArgs>();
    args->commandBuffer = commandBuffer;
    args->indexCount = indexCount;
    args->instanceCount = instanceCount;
    args->firstIndex = firstIndex;
    args->vertexOffset = vertexOffset;
    args->firstInstance = firstInstance;
    return args;
}

CmdDrawIndirectArgs* CommandRecorder::RecordCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                            VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndirectArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->drawCount = drawCount;
    args->stride = stride;
    return args;
}

CmdDrawIndexedIndirectArgs* CommandRecorder::RecordCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer,
                                                                          VkBuffer buffer, VkDeviceSize offset,
                                                                          uint32_t drawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndexedIndirectArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->drawCount = drawCount;
    args->stride = stride;
    return args;
}

CmdDispatchArgs* CommandRecorder::RecordCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                                    uint32_t groupCountY, uint32_t groupCountZ) {
    auto* args = Alloc<CmdDispatchArgs>();
    args->commandBuffer = commandBuffer;
    args->groupCountX = groupCountX;
    args->groupCountY = groupCountY;
    args->groupCountZ = groupCountZ;
    return args;
}

CmdDispatchIndirectArgs* CommandRecorder::RecordCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                    VkDeviceSize offset) {
    auto* args = Alloc<CmdDispatchIndirectArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    return args;
}

CmdCopyBufferArgs* CommandRecorder::RecordCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                                        VkBuffer dstBuffer, uint32_t regionCount,
                                                        const VkBufferCopy* pRegions) {
    auto* args = Alloc<CmdCopyBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->srcBuffer = srcBuffer;
    args->dstBuffer = dstBuffer;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    return args;
}

CmdCopyImageArgs* CommandRecorder::RecordCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                      VkImageLayout srcImageLayout, VkImage dstImage,
                                                      VkImageLayout dstImageLayout, uint32_t regionCount,
                                                      const VkImageCopy* pRegions) {
    auto* args = Alloc<CmdCopyImageArgs>();
    args->commandBuffer = commandBuffer;
    args->srcImage = srcImage;
    args->srcImageLayout = srcImageLayout;
    args->dstImage = dstImage;
    args->dstImageLayout = dstImageLayout;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    return args;
}

CmdBlitImageArgs* CommandRecorder::RecordCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                      VkImageLayout srcImageLayout, VkImage dstImage,
                                                      VkImageLayout dstImageLayout, uint32_t regionCount,
                                                      const VkImageBlit* pRegions, VkFilter filter) {
    auto* args = Alloc<CmdBlitImageArgs>();
    args->commandBuffer = commandBuffer;
    args->srcImage = srcImage;
    args->srcImageLayout = srcImageLayout;
    args->dstImage = dstImage;
    args->dstImageLayout = dstImageLayout;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    args->filter = filter;
    return args;
}

CmdCopyBufferToImageArgs* CommandRecorder::RecordCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                                                      VkImage dstImage, VkImageLayout dstImageLayout,
                                                                      uint32_t regionCount,
                                                                      const VkBufferImageCopy* pRegions) {
    auto* args = Alloc<CmdCopyBufferToImageArgs>();
    args->commandBuffer = commandBuffer;
    args->srcBuffer = srcBuffer;
    args->dstImage = dstImage;
    args->dstImageLayout = dstImageLayout;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    return args;
}

CmdCopyImageToBufferArgs* CommandRecorder::RecordCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                                      VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                                                      uint32_t regionCount,
                                                                      const VkBufferImageCopy* pRegions) {
    auto* args = Alloc<CmdCopyImageToBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->srcImage = srcImage;
    args->srcImageLayout = srcImageLayout;
    args->dstBuffer = dstBuffer;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    return args;
}

CmdUpdateBufferArgs* CommandRecorder::RecordCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                                            VkDeviceSize dstOffset, VkDeviceSize dataSize,
                                                            const void* pData) {
    auto* args = Alloc<CmdUpdateBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->dstBuffer = dstBuffer;
    args->dstOffset = dstOffset;
    args->dataSize = dataSize;
    args->pData =
        CopyArray(reinterpret_cast<const uint8_t*>(pData), static_cast<uint64_t>(0U), static_cast<uint64_t>(dataSize));
    return args;
}

CmdFillBufferArgs* CommandRecorder::RecordCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer,
                                                        VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    auto* args = Alloc<CmdFillBufferArgs>();
    args->commandBuffer = commandBuffer;
    args->dstBuffer = dstBuffer;
    args->dstOffset = dstOffset;
    args->size = size;
    args->data = data;
    return args;
}

CmdClearColorImageArgs* CommandRecorder::RecordCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image,
                                                                  VkImageLayout imageLayout,
                                                                  const VkClearColorValue* pColor, uint32_t rangeCount,
                                                                  const VkImageSubresourceRange* pRanges) {
    auto* args = Alloc<CmdClearColorImageArgs>();
    args->commandBuffer = commandBuffer;
    args->image = image;
    args->imageLayout = imageLayout;
    if (pColor) {
        args->pColor = CopyArray(pColor, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->rangeCount = rangeCount;
    if (pRanges) {
        args->pRanges = CopyArray(pRanges, static_cast<uint64_t>(0U), static_cast<uint64_t>(rangeCount));
    }
    return args;
}

CmdClearDepthStencilImageArgs* CommandRecorder::RecordCmdClearDepthStencilImage(
    VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
    const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
    auto* args = Alloc<CmdClearDepthStencilImageArgs>();
    args->commandBuffer = commandBuffer;
    args->image = image;
    args->imageLayout = imageLayout;
    if (pDepthStencil) {
        args->pDepthStencil = CopyArray(pDepthStencil, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->rangeCount = rangeCount;
    if (pRanges) {
        args->pRanges = CopyArray(pRanges, static_cast<uint64_t>(0U), static_cast<uint64_t>(rangeCount));
    }
    return args;
}

CmdClearAttachmentsArgs* CommandRecorder::RecordCmdClearAttachments(VkCommandBuffer commandBuffer,
                                                                    uint32_t attachmentCount,
                                                                    const VkClearAttachment* pAttachments,
                                                                    uint32_t rectCount, const VkClearRect* pRects) {
    auto* args = Alloc<CmdClearAttachmentsArgs>();
    args->commandBuffer = commandBuffer;
    args->attachmentCount = attachmentCount;
    if (pAttachments) {
        args->pAttachments = CopyArray(pAttachments, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    args->rectCount = rectCount;
    if (pRects) {
        args->pRects = CopyArray(pRects, static_cast<uint64_t>(0U), static_cast<uint64_t>(rectCount));
    }
    return args;
}

CmdResolveImageArgs* CommandRecorder::RecordCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage,
                                                            VkImageLayout srcImageLayout, VkImage dstImage,
                                                            VkImageLayout dstImageLayout, uint32_t regionCount,
                                                            const VkImageResolve* pRegions) {
    auto* args = Alloc<CmdResolveImageArgs>();
    args->commandBuffer = commandBuffer;
    args->srcImage = srcImage;
    args->srcImageLayout = srcImageLayout;
    args->dstImage = dstImage;
    args->dstImageLayout = dstImageLayout;
    args->regionCount = regionCount;
    if (pRegions) {
        args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
    return args;
}

CmdSetEventArgs* CommandRecorder::RecordCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                                                    VkPipelineStageFlags stageMask) {
    auto* args = Alloc<CmdSetEventArgs>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    args->stageMask = stageMask;
    return args;
}

CmdResetEventArgs* CommandRecorder::RecordCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event,
                                                        VkPipelineStageFlags stageMask) {
    auto* args = Alloc<CmdResetEventArgs>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    args->stageMask = stageMask;
    return args;
}

CmdWaitEventsArgs* CommandRecorder::RecordCmdWaitEvents(
    VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask,
    VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    auto* args = Alloc<CmdWaitEventsArgs>();
    args->commandBuffer = commandBuffer;
    args->eventCount = eventCount;
    if (pEvents) {
        args->pEvents = CopyArray(pEvents, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
    args->srcStageMask = srcStageMask;
    args->dstStageMask = dstStageMask;
    args->memoryBarrierCount = memoryBarrierCount;
    if (pMemoryBarriers) {
        args->pMemoryBarriers =
            CopyArray(pMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(memoryBarrierCount));
    }
    args->bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    if (pBufferMemoryBarriers) {
        args->pBufferMemoryBarriers = CopyArray(pBufferMemoryBarriers, static_cast<uint64_t>(0U),
                                                static_cast<uint64_t>(bufferMemoryBarrierCount));
    }
    args->imageMemoryBarrierCount = imageMemoryBarrierCount;
    if (pImageMemoryBarriers) {
        args->pImageMemoryBarriers =
            CopyArray(pImageMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(imageMemoryBarrierCount));
    }
    return args;
}

CmdPipelineBarrierArgs* CommandRecorder::RecordCmdPipelineBarrier(
    VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
    VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers,
    uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers,
    uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
    auto* args = Alloc<CmdPipelineBarrierArgs>();
    args->commandBuffer = commandBuffer;
    args->srcStageMask = srcStageMask;
    args->dstStageMask = dstStageMask;
    args->dependencyFlags = dependencyFlags;
    args->memoryBarrierCount = memoryBarrierCount;
    if (pMemoryBarriers) {
        args->pMemoryBarriers =
            CopyArray(pMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(memoryBarrierCount));
    }
    args->bufferMemoryBarrierCount = bufferMemoryBarrierCount;
    if (pBufferMemoryBarriers) {
        args->pBufferMemoryBarriers = CopyArray(pBufferMemoryBarriers, static_cast<uint64_t>(0U),
                                                static_cast<uint64_t>(bufferMemoryBarrierCount));
    }
    args->imageMemoryBarrierCount = imageMemoryBarrierCount;
    if (pImageMemoryBarriers) {
        args->pImageMemoryBarriers =
            CopyArray(pImageMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(imageMemoryBarrierCount));
    }
    return args;
}

CmdBeginQueryArgs* CommandRecorder::RecordCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                        uint32_t query, VkQueryControlFlags flags) {
    auto* args = Alloc<CmdBeginQueryArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->query = query;
    args->flags = flags;
    return args;
}

CmdEndQueryArgs* CommandRecorder::RecordCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                    uint32_t query) {
    auto* args = Alloc<CmdEndQueryArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->query = query;
    return args;
}

CmdResetQueryPoolArgs* CommandRecorder::RecordCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                                                uint32_t firstQuery, uint32_t queryCount) {
    auto* args = Alloc<CmdResetQueryPoolArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->firstQuery = firstQuery;
    args->queryCount = queryCount;
    return args;
}

CmdWriteTimestampArgs* CommandRecorder::RecordCmdWriteTimestamp(VkCommandBuffer commandBuffer,
                                                                VkPipelineStageFlagBits pipelineStage,
                                                                VkQueryPool queryPool, uint32_t query) {
    auto* args = Alloc<CmdWriteTimestampArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineStage = pipelineStage;
    args->queryPool = queryPool;
    args->query = query;
    return args;
}

CmdCopyQueryPoolResultsArgs* CommandRecorder::RecordCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer,
                                                                            VkQueryPool queryPool, uint32_t firstQuery,
                                                                            uint32_t queryCount, VkBuffer dstBuffer,
                                                                            VkDeviceSize dstOffset, VkDeviceSize stride,
                                                                            VkQueryResultFlags flags) {
    auto* args = Alloc<CmdCopyQueryPoolResultsArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->firstQuery = firstQuery;
    args->queryCount = queryCount;
    args->dstBuffer = dstBuffer;
    args->dstOffset = dstOffset;
    args->stride = stride;
    args->flags = flags;
    return args;
}

CmdPushConstantsArgs* CommandRecorder::RecordCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                                              VkShaderStageFlags stageFlags, uint32_t offset,
                                                              uint32_t size, const void* pValues) {
    auto* args = Alloc<CmdPushConstantsArgs>();
    args->commandBuffer = commandBuffer;
    args->layout = layout;
    args->stageFlags = stageFlags;
    args->offset = offset;
    args->size = size;
    args->pValues =
        CopyArray(reinterpret_cast<const uint8_t*>(pValues), static_cast<uint64_t>(0U), static_cast<uint64_t>(size));
    return args;
}

CmdBeginRenderPassArgs* CommandRecorder::RecordCmdBeginRenderPass(VkCommandBuffer commandBuffer,
                                                                  const VkRenderPassBeginInfo* pRenderPassBegin,
                                                                  VkSubpassContents contents) {
    auto* args = Alloc<CmdBeginRenderPassArgs>();
    args->commandBuffer = commandBuffer;
    if (pRenderPassBegin) {
        args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->contents = contents;
    return args;
}

CmdNextSubpassArgs* CommandRecorder::RecordCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    auto* args = Alloc<CmdNextSubpassArgs>();
    args->commandBuffer = commandBuffer;
    args->contents = contents;
    return args;
}

CmdEndRenderPassArgs* CommandRecorder::RecordCmdEndRenderPass(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdEndRenderPassArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdExecuteCommandsArgs* CommandRecorder::RecordCmdExecuteCommands(VkCommandBuffer commandBuffer,
                                                                  uint32_t commandBufferCount,
                                                                  const VkCommandBuffer* pCommandBuffers) {
    auto* args = Alloc<CmdExecuteCommandsArgs>();
    args->commandBuffer = commandBuffer;
    args->commandBufferCount = commandBufferCount;
    if (pCommandBuffers) {
        args->pCommandBuffers =
            CopyArray(pCommandBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(commandBufferCount));
    }
    return args;
}

CmdSetDeviceMaskArgs* CommandRecorder::RecordCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    auto* args = Alloc<CmdSetDeviceMaskArgs>();
    args->commandBuffer = commandBuffer;
    args->deviceMask = deviceMask;
    return args;
}

CmdDispatchBaseArgs* CommandRecorder::RecordCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                                            uint32_t baseGroupY, uint32_t baseGroupZ,
                                                            uint32_t groupCountX, uint32_t groupCountY,
                                                            uint32_t groupCountZ) {
    auto* args = Alloc<CmdDispatchBaseArgs>();
    args->commandBuffer = commandBuffer;
    args->baseGroupX = baseGroupX;
    args->baseGroupY = baseGroupY;
    args->baseGroupZ = baseGroupZ;
    args->groupCountX = groupCountX;
    args->groupCountY = groupCountY;
    args->groupCountZ = groupCountZ;
    return args;
}

CmdDrawIndirectCountArgs* CommandRecorder::RecordCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                                                      VkDeviceSize offset, VkBuffer countBuffer,
                                                                      VkDeviceSize countBufferOffset,
                                                                      uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndirectCountArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdDrawIndexedIndirectCountArgs* CommandRecorder::RecordCmdDrawIndexedIndirectCount(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndexedIndirectCountArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdBeginRenderPass2Args* CommandRecorder::RecordCmdBeginRenderPass2(VkCommandBuffer commandBuffer,
                                                                    const VkRenderPassBeginInfo* pRenderPassBegin,
                                                                    const VkSubpassBeginInfo* pSubpassBeginInfo) {
    auto* args = Alloc<CmdBeginRenderPass2Args>();
    args->commandBuffer = commandBuffer;
    if (pRenderPassBegin) {
        args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pSubpassBeginInfo) {
        args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdNextSubpass2Args* CommandRecorder::RecordCmdNextSubpass2(VkCommandBuffer commandBuffer,
                                                            const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                            const VkSubpassEndInfo* pSubpassEndInfo) {
    auto* args = Alloc<CmdNextSubpass2Args>();
    args->commandBuffer = commandBuffer;
    if (pSubpassBeginInfo) {
        args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pSubpassEndInfo) {
        args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndRenderPass2Args* CommandRecorder::RecordCmdEndRenderPass2(VkCommandBuffer commandBuffer,
                                                                const VkSubpassEndInfo* pSubpassEndInfo) {
    auto* args = Alloc<CmdEndRenderPass2Args>();
    args->commandBuffer = commandBuffer;
    if (pSubpassEndInfo) {
        args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetEvent2Args* CommandRecorder::RecordCmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                                      const VkDependencyInfo* pDependencyInfo) {
    auto* args = Alloc<CmdSetEvent2Args>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    if (pDependencyInfo) {
        args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdResetEvent2Args* CommandRecorder::RecordCmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                                                          VkPipelineStageFlags2 stageMask) {
    auto* args = Alloc<CmdResetEvent2Args>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    args->stageMask = stageMask;
    return args;
}

CmdWaitEvents2Args* CommandRecorder::RecordCmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                                          const VkEvent* pEvents,
                                                          const VkDependencyInfo* pDependencyInfos) {
    auto* args = Alloc<CmdWaitEvents2Args>();
    args->commandBuffer = commandBuffer;
    args->eventCount = eventCount;
    if (pEvents) {
        args->pEvents = CopyArray(pEvents, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
    if (pDependencyInfos) {
        args->pDependencyInfos =
            CopyArray(pDependencyInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
    return args;
}

CmdPipelineBarrier2Args* CommandRecorder::RecordCmdPipelineBarrier2(VkCommandBuffer commandBuffer,
                                                                    const VkDependencyInfo* pDependencyInfo) {
    auto* args = Alloc<CmdPipelineBarrier2Args>();
    args->commandBuffer = commandBuffer;
    if (pDependencyInfo) {
        args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdWriteTimestamp2Args* CommandRecorder::RecordCmdWriteTimestamp2(VkCommandBuffer commandBuffer,
                                                                  VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                                                  uint32_t query) {
    auto* args = Alloc<CmdWriteTimestamp2Args>();
    args->commandBuffer = commandBuffer;
    args->stage = stage;
    args->queryPool = queryPool;
    args->query = query;
    return args;
}

CmdCopyBuffer2Args* CommandRecorder::RecordCmdCopyBuffer2(VkCommandBuffer commandBuffer,
                                                          const VkCopyBufferInfo2* pCopyBufferInfo) {
    auto* args = Alloc<CmdCopyBuffer2Args>();
    args->commandBuffer = commandBuffer;
    if (pCopyBufferInfo) {
        args->pCopyBufferInfo = CopyArray(pCopyBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyImage2Args* CommandRecorder::RecordCmdCopyImage2(VkCommandBuffer commandBuffer,
                                                        const VkCopyImageInfo2* pCopyImageInfo) {
    auto* args = Alloc<CmdCopyImage2Args>();
    args->commandBuffer = commandBuffer;
    if (pCopyImageInfo) {
        args->pCopyImageInfo = CopyArray(pCopyImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyBufferToImage2Args* CommandRecorder::RecordCmdCopyBufferToImage2(
    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    auto* args = Alloc<CmdCopyBufferToImage2Args>();
    args->commandBuffer = commandBuffer;
    if (pCopyBufferToImageInfo) {
        args->pCopyBufferToImageInfo =
            CopyArray(pCopyBufferToImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyImageToBuffer2Args* CommandRecorder::RecordCmdCopyImageToBuffer2(
    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    auto* args = Alloc<CmdCopyImageToBuffer2Args>();
    args->commandBuffer = commandBuffer;
    if (pCopyImageToBufferInfo) {
        args->pCopyImageToBufferInfo =
            CopyArray(pCopyImageToBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBlitImage2Args* CommandRecorder::RecordCmdBlitImage2(VkCommandBuffer commandBuffer,
                                                        const VkBlitImageInfo2* pBlitImageInfo) {
    auto* args = Alloc<CmdBlitImage2Args>();
    args->commandBuffer = commandBuffer;
    if (pBlitImageInfo) {
        args->pBlitImageInfo = CopyArray(pBlitImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdResolveImage2Args* CommandRecorder::RecordCmdResolveImage2(VkCommandBuffer commandBuffer,
                                                              const VkResolveImageInfo2* pResolveImageInfo) {
    auto* args = Alloc<CmdResolveImage2Args>();
    args->commandBuffer = commandBuffer;
    if (pResolveImageInfo) {
        args->pResolveImageInfo = CopyArray(pResolveImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBeginRenderingArgs* CommandRecorder::RecordCmdBeginRendering(VkCommandBuffer commandBuffer,
                                                                const VkRenderingInfo* pRenderingInfo) {
    auto* args = Alloc<CmdBeginRenderingArgs>();
    args->commandBuffer = commandBuffer;
    if (pRenderingInfo) {
        args->pRenderingInfo = CopyArray(pRenderingInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndRenderingArgs* CommandRecorder::RecordCmdEndRendering(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdEndRenderingArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdSetCullModeArgs* CommandRecorder::RecordCmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    auto* args = Alloc<CmdSetCullModeArgs>();
    args->commandBuffer = commandBuffer;
    args->cullMode = cullMode;
    return args;
}

CmdSetFrontFaceArgs* CommandRecorder::RecordCmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    auto* args = Alloc<CmdSetFrontFaceArgs>();
    args->commandBuffer = commandBuffer;
    args->frontFace = frontFace;
    return args;
}

CmdSetPrimitiveTopologyArgs* CommandRecorder::RecordCmdSetPrimitiveTopology(VkCommandBuffer commandBuffer,
                                                                            VkPrimitiveTopology primitiveTopology) {
    auto* args = Alloc<CmdSetPrimitiveTopologyArgs>();
    args->commandBuffer = commandBuffer;
    args->primitiveTopology = primitiveTopology;
    return args;
}

CmdSetViewportWithCountArgs* CommandRecorder::RecordCmdSetViewportWithCount(VkCommandBuffer commandBuffer,
                                                                            uint32_t viewportCount,
                                                                            const VkViewport* pViewports) {
    auto* args = Alloc<CmdSetViewportWithCountArgs>();
    args->commandBuffer = commandBuffer;
    args->viewportCount = viewportCount;
    if (pViewports) {
        args->pViewports = CopyArray(pViewports, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetScissorWithCountArgs* CommandRecorder::RecordCmdSetScissorWithCount(VkCommandBuffer commandBuffer,
                                                                          uint32_t scissorCount,
                                                                          const VkRect2D* pScissors) {
    auto* args = Alloc<CmdSetScissorWithCountArgs>();
    args->commandBuffer = commandBuffer;
    args->scissorCount = scissorCount;
    if (pScissors) {
        args->pScissors = CopyArray(pScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(scissorCount));
    }
    return args;
}

CmdBindVertexBuffers2Args* CommandRecorder::RecordCmdBindVertexBuffers2(
    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    auto* args = Alloc<CmdBindVertexBuffers2Args>();
    args->commandBuffer = commandBuffer;
    args->firstBinding = firstBinding;
    args->bindingCount = bindingCount;
    if (pBuffers) {
        args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pOffsets) {
        args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pSizes) {
        args->pSizes = CopyArray(pSizes, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pStrides) {
        args->pStrides = CopyArray(pStrides, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    return args;
}

CmdSetDepthTestEnableArgs* CommandRecorder::RecordCmdSetDepthTestEnable(VkCommandBuffer commandBuffer,
                                                                        VkBool32 depthTestEnable) {
    auto* args = Alloc<CmdSetDepthTestEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->depthTestEnable = depthTestEnable;
    return args;
}

CmdSetDepthWriteEnableArgs* CommandRecorder::RecordCmdSetDepthWriteEnable(VkCommandBuffer commandBuffer,
                                                                          VkBool32 depthWriteEnable) {
    auto* args = Alloc<CmdSetDepthWriteEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->depthWriteEnable = depthWriteEnable;
    return args;
}

CmdSetDepthCompareOpArgs* CommandRecorder::RecordCmdSetDepthCompareOp(VkCommandBuffer commandBuffer,
                                                                      VkCompareOp depthCompareOp) {
    auto* args = Alloc<CmdSetDepthCompareOpArgs>();
    args->commandBuffer = commandBuffer;
    args->depthCompareOp = depthCompareOp;
    return args;
}

CmdSetDepthBoundsTestEnableArgs* CommandRecorder::RecordCmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer,
                                                                                    VkBool32 depthBoundsTestEnable) {
    auto* args = Alloc<CmdSetDepthBoundsTestEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->depthBoundsTestEnable = depthBoundsTestEnable;
    return args;
}

CmdSetStencilTestEnableArgs* CommandRecorder::RecordCmdSetStencilTestEnable(VkCommandBuffer commandBuffer,
                                                                            VkBool32 stencilTestEnable) {
    auto* args = Alloc<CmdSetStencilTestEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->stencilTestEnable = stencilTestEnable;
    return args;
}

CmdSetStencilOpArgs* CommandRecorder::RecordCmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                                            VkStencilOp failOp, VkStencilOp passOp,
                                                            VkStencilOp depthFailOp, VkCompareOp compareOp) {
    auto* args = Alloc<CmdSetStencilOpArgs>();
    args->commandBuffer = commandBuffer;
    args->faceMask = faceMask;
    args->failOp = failOp;
    args->passOp = passOp;
    args->depthFailOp = depthFailOp;
    args->compareOp = compareOp;
    return args;
}

CmdSetRasterizerDiscardEnableArgs* CommandRecorder::RecordCmdSetRasterizerDiscardEnable(
    VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    auto* args = Alloc<CmdSetRasterizerDiscardEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->rasterizerDiscardEnable = rasterizerDiscardEnable;
    return args;
}

CmdSetDepthBiasEnableArgs* CommandRecorder::RecordCmdSetDepthBiasEnable(VkCommandBuffer commandBuffer,
                                                                        VkBool32 depthBiasEnable) {
    auto* args = Alloc<CmdSetDepthBiasEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->depthBiasEnable = depthBiasEnable;
    return args;
}

CmdSetPrimitiveRestartEnableArgs* CommandRecorder::RecordCmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer,
                                                                                      VkBool32 primitiveRestartEnable) {
    auto* args = Alloc<CmdSetPrimitiveRestartEnableArgs>();
    args->commandBuffer = commandBuffer;
    args->primitiveRestartEnable = primitiveRestartEnable;
    return args;
}

CmdBeginVideoCodingKHRArgs* CommandRecorder::RecordCmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                                          const VkVideoBeginCodingInfoKHR* pBeginInfo) {
    auto* args = Alloc<CmdBeginVideoCodingKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pBeginInfo) {
        args->pBeginInfo = CopyArray(pBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndVideoCodingKHRArgs* CommandRecorder::RecordCmdEndVideoCodingKHR(VkCommandBuffer commandBuffer,
                                                                      const VkVideoEndCodingInfoKHR* pEndCodingInfo) {
    auto* args = Alloc<CmdEndVideoCodingKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pEndCodingInfo) {
        args->pEndCodingInfo = CopyArray(pEndCodingInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdControlVideoCodingKHRArgs* CommandRecorder::RecordCmdControlVideoCodingKHR(
    VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR* pCodingControlInfo) {
    auto* args = Alloc<CmdControlVideoCodingKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pCodingControlInfo) {
        args->pCodingControlInfo = CopyArray(pCodingControlInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDecodeVideoKHRArgs* CommandRecorder::RecordCmdDecodeVideoKHR(VkCommandBuffer commandBuffer,
                                                                const VkVideoDecodeInfoKHR* pDecodeInfo) {
    auto* args = Alloc<CmdDecodeVideoKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pDecodeInfo) {
        args->pDecodeInfo = CopyArray(pDecodeInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBeginRenderingKHRArgs* CommandRecorder::RecordCmdBeginRenderingKHR(VkCommandBuffer commandBuffer,
                                                                      const VkRenderingInfo* pRenderingInfo) {
    auto* args = Alloc<CmdBeginRenderingKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pRenderingInfo) {
        args->pRenderingInfo = CopyArray(pRenderingInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndRenderingKHRArgs* CommandRecorder::RecordCmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdEndRenderingKHRArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdSetDeviceMaskKHRArgs* CommandRecorder::RecordCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer,
                                                                    uint32_t deviceMask) {
    auto* args = Alloc<CmdSetDeviceMaskKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->deviceMask = deviceMask;
    return args;
}

CmdDispatchBaseKHRArgs* CommandRecorder::RecordCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX,
                                                                  uint32_t baseGroupY, uint32_t baseGroupZ,
                                                                  uint32_t groupCountX, uint32_t groupCountY,
                                                                  uint32_t groupCountZ) {
    auto* args = Alloc<CmdDispatchBaseKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->baseGroupX = baseGroupX;
    args->baseGroupY = baseGroupY;
    args->baseGroupZ = baseGroupZ;
    args->groupCountX = groupCountX;
    args->groupCountY = groupCountY;
    args->groupCountZ = groupCountZ;
    return args;
}

CmdPushDescriptorSetKHRArgs* CommandRecorder::RecordCmdPushDescriptorSetKHR(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set,
    uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) {
    auto* args = Alloc<CmdPushDescriptorSetKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->layout = layout;
    args->set = set;
    args->descriptorWriteCount = descriptorWriteCount;
    if (pDescriptorWrites) {
        args->pDescriptorWrites =
            CopyArray(pDescriptorWrites, static_cast<uint64_t>(0U), static_cast<uint64_t>(descriptorWriteCount));
    }
    return args;
}

CmdPushDescriptorSetWithTemplateKHRArgs* CommandRecorder::RecordCmdPushDescriptorSetWithTemplateKHR(
    VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout,
    uint32_t set, const void* pData) {
    auto* args = Alloc<CmdPushDescriptorSetWithTemplateKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->descriptorUpdateTemplate = descriptorUpdateTemplate;
    args->layout = layout;
    args->set = set;
    args->pData = pData;
    return args;
}

CmdBeginRenderPass2KHRArgs* CommandRecorder::RecordCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                                          const VkRenderPassBeginInfo* pRenderPassBegin,
                                                                          const VkSubpassBeginInfo* pSubpassBeginInfo) {
    auto* args = Alloc<CmdBeginRenderPass2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pRenderPassBegin) {
        args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pSubpassBeginInfo) {
        args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdNextSubpass2KHRArgs* CommandRecorder::RecordCmdNextSubpass2KHR(VkCommandBuffer commandBuffer,
                                                                  const VkSubpassBeginInfo* pSubpassBeginInfo,
                                                                  const VkSubpassEndInfo* pSubpassEndInfo) {
    auto* args = Alloc<CmdNextSubpass2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pSubpassBeginInfo) {
        args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pSubpassEndInfo) {
        args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndRenderPass2KHRArgs* CommandRecorder::RecordCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer,
                                                                      const VkSubpassEndInfo* pSubpassEndInfo) {
    auto* args = Alloc<CmdEndRenderPass2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pSubpassEndInfo) {
        args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDrawIndirectCountKHRArgs* CommandRecorder::RecordCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer,
                                                                            VkBuffer buffer, VkDeviceSize offset,
                                                                            VkBuffer countBuffer,
                                                                            VkDeviceSize countBufferOffset,
                                                                            uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndirectCountKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdDrawIndexedIndirectCountKHRArgs* CommandRecorder::RecordCmdDrawIndexedIndirectCountKHR(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndexedIndirectCountKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdSetFragmentShadingRateKHRArgs* CommandRecorder::RecordCmdSetFragmentShadingRateKHR(
    VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    auto* args = Alloc<CmdSetFragmentShadingRateKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pFragmentSize) {
        args->pFragmentSize = CopyArray(pFragmentSize, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    for (uint32_t i = 0; i < 2; ++i) {
        args->combinerOps[i] = combinerOps[i];
    }
    return args;
}

CmdSetRenderingAttachmentLocationsKHRArgs* CommandRecorder::RecordCmdSetRenderingAttachmentLocationsKHR(
    VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfoKHR* pLocationInfo) {
    auto* args = Alloc<CmdSetRenderingAttachmentLocationsKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pLocationInfo) {
        args->pLocationInfo = CopyArray(pLocationInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetRenderingInputAttachmentIndicesKHRArgs* CommandRecorder::RecordCmdSetRenderingInputAttachmentIndicesKHR(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR* pInputAttachmentIndexInfo) {
    auto* args = Alloc<CmdSetRenderingInputAttachmentIndicesKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pInputAttachmentIndexInfo) {
        args->pInputAttachmentIndexInfo =
            CopyArray(pInputAttachmentIndexInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEncodeVideoKHRArgs* CommandRecorder::RecordCmdEncodeVideoKHR(VkCommandBuffer commandBuffer,
                                                                const VkVideoEncodeInfoKHR* pEncodeInfo) {
    auto* args = Alloc<CmdEncodeVideoKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pEncodeInfo) {
        args->pEncodeInfo = CopyArray(pEncodeInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetEvent2KHRArgs* CommandRecorder::RecordCmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                                            const VkDependencyInfo* pDependencyInfo) {
    auto* args = Alloc<CmdSetEvent2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    if (pDependencyInfo) {
        args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdResetEvent2KHRArgs* CommandRecorder::RecordCmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                                                VkPipelineStageFlags2 stageMask) {
    auto* args = Alloc<CmdResetEvent2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->event = event;
    args->stageMask = stageMask;
    return args;
}

CmdWaitEvents2KHRArgs* CommandRecorder::RecordCmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount,
                                                                const VkEvent* pEvents,
                                                                const VkDependencyInfo* pDependencyInfos) {
    auto* args = Alloc<CmdWaitEvents2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->eventCount = eventCount;
    if (pEvents) {
        args->pEvents = CopyArray(pEvents, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
    if (pDependencyInfos) {
        args->pDependencyInfos =
            CopyArray(pDependencyInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
    return args;
}

CmdPipelineBarrier2KHRArgs* CommandRecorder::RecordCmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer,
                                                                          const VkDependencyInfo* pDependencyInfo) {
    auto* args = Alloc<CmdPipelineBarrier2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pDependencyInfo) {
        args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdWriteTimestamp2KHRArgs* CommandRecorder::RecordCmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer,
                                                                        VkPipelineStageFlags2 stage,
                                                                        VkQueryPool queryPool, uint32_t query) {
    auto* args = Alloc<CmdWriteTimestamp2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->stage = stage;
    args->queryPool = queryPool;
    args->query = query;
    return args;
}

CmdWriteBufferMarker2AMDArgs* CommandRecorder::RecordCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer,
                                                                              VkPipelineStageFlags2 stage,
                                                                              VkBuffer dstBuffer,
                                                                              VkDeviceSize dstOffset, uint32_t marker) {
    auto* args = Alloc<CmdWriteBufferMarker2AMDArgs>();
    args->commandBuffer = commandBuffer;
    args->stage = stage;
    args->dstBuffer = dstBuffer;
    args->dstOffset = dstOffset;
    args->marker = marker;
    return args;
}

CmdCopyBuffer2KHRArgs* CommandRecorder::RecordCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer,
                                                                const VkCopyBufferInfo2* pCopyBufferInfo) {
    auto* args = Alloc<CmdCopyBuffer2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pCopyBufferInfo) {
        args->pCopyBufferInfo = CopyArray(pCopyBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyImage2KHRArgs* CommandRecorder::RecordCmdCopyImage2KHR(VkCommandBuffer commandBuffer,
                                                              const VkCopyImageInfo2* pCopyImageInfo) {
    auto* args = Alloc<CmdCopyImage2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pCopyImageInfo) {
        args->pCopyImageInfo = CopyArray(pCopyImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyBufferToImage2KHRArgs* CommandRecorder::RecordCmdCopyBufferToImage2KHR(
    VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo) {
    auto* args = Alloc<CmdCopyBufferToImage2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pCopyBufferToImageInfo) {
        args->pCopyBufferToImageInfo =
            CopyArray(pCopyBufferToImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyImageToBuffer2KHRArgs* CommandRecorder::RecordCmdCopyImageToBuffer2KHR(
    VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo) {
    auto* args = Alloc<CmdCopyImageToBuffer2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pCopyImageToBufferInfo) {
        args->pCopyImageToBufferInfo =
            CopyArray(pCopyImageToBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBlitImage2KHRArgs* CommandRecorder::RecordCmdBlitImage2KHR(VkCommandBuffer commandBuffer,
                                                              const VkBlitImageInfo2* pBlitImageInfo) {
    auto* args = Alloc<CmdBlitImage2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pBlitImageInfo) {
        args->pBlitImageInfo = CopyArray(pBlitImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdResolveImage2KHRArgs* CommandRecorder::RecordCmdResolveImage2KHR(VkCommandBuffer commandBuffer,
                                                                    const VkResolveImageInfo2* pResolveImageInfo) {
    auto* args = Alloc<CmdResolveImage2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pResolveImageInfo) {
        args->pResolveImageInfo = CopyArray(pResolveImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdTraceRaysIndirect2KHRArgs* CommandRecorder::RecordCmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer,
                                                                              VkDeviceAddress indirectDeviceAddress) {
    auto* args = Alloc<CmdTraceRaysIndirect2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->indirectDeviceAddress = indirectDeviceAddress;
    return args;
}

CmdBindIndexBuffer2KHRArgs* CommandRecorder::RecordCmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer,
                                                                          VkBuffer buffer, VkDeviceSize offset,
                                                                          VkDeviceSize size, VkIndexType indexType) {
    auto* args = Alloc<CmdBindIndexBuffer2KHRArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->size = size;
    args->indexType = indexType;
    return args;
}

CmdSetLineStippleKHRArgs* CommandRecorder::RecordCmdSetLineStippleKHR(VkCommandBuffer commandBuffer,
                                                                      uint32_t lineStippleFactor,
                                                                      uint16_t lineStipplePattern) {
    auto* args = Alloc<CmdSetLineStippleKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->lineStippleFactor = lineStippleFactor;
    args->lineStipplePattern = lineStipplePattern;
    return args;
}

CmdBindDescriptorSets2KHRArgs* CommandRecorder::RecordCmdBindDescriptorSets2KHR(
    VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfoKHR* pBindDescriptorSetsInfo) {
    auto* args = Alloc<CmdBindDescriptorSets2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pBindDescriptorSetsInfo) {
        args->pBindDescriptorSetsInfo =
            CopyArray(pBindDescriptorSetsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdPushConstants2KHRArgs* CommandRecorder::RecordCmdPushConstants2KHR(
    VkCommandBuffer commandBuffer, const VkPushConstantsInfoKHR* pPushConstantsInfo) {
    auto* args = Alloc<CmdPushConstants2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pPushConstantsInfo) {
        args->pPushConstantsInfo = CopyArray(pPushConstantsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdPushDescriptorSet2KHRArgs* CommandRecorder::RecordCmdPushDescriptorSet2KHR(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfoKHR* pPushDescriptorSetInfo) {
    auto* args = Alloc<CmdPushDescriptorSet2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pPushDescriptorSetInfo) {
        args->pPushDescriptorSetInfo =
            CopyArray(pPushDescriptorSetInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdPushDescriptorSetWithTemplate2KHRArgs* CommandRecorder::RecordCmdPushDescriptorSetWithTemplate2KHR(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfoKHR* pPushDescriptorSetWithTemplateInfo) {
    auto* args = Alloc<CmdPushDescriptorSetWithTemplate2KHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pPushDescriptorSetWithTemplateInfo) {
        args->pPushDescriptorSetWithTemplateInfo =
            CopyArray(pPushDescriptorSetWithTemplateInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetDescriptorBufferOffsets2EXTArgs* CommandRecorder::RecordCmdSetDescriptorBufferOffsets2EXT(
    VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT* pSetDescriptorBufferOffsetsInfo) {
    auto* args = Alloc<CmdSetDescriptorBufferOffsets2EXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pSetDescriptorBufferOffsetsInfo) {
        args->pSetDescriptorBufferOffsetsInfo =
            CopyArray(pSetDescriptorBufferOffsetsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindDescriptorBufferEmbeddedSamplers2EXTArgs* CommandRecorder::RecordCmdBindDescriptorBufferEmbeddedSamplers2EXT(
    VkCommandBuffer commandBuffer,
    const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* pBindDescriptorBufferEmbeddedSamplersInfo) {
    auto* args = Alloc<CmdBindDescriptorBufferEmbeddedSamplers2EXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pBindDescriptorBufferEmbeddedSamplersInfo) {
        args->pBindDescriptorBufferEmbeddedSamplersInfo =
            CopyArray(pBindDescriptorBufferEmbeddedSamplersInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDebugMarkerBeginEXTArgs* CommandRecorder::RecordCmdDebugMarkerBeginEXT(
    VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
    auto* args = Alloc<CmdDebugMarkerBeginEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pMarkerInfo) {
        args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDebugMarkerEndEXTArgs* CommandRecorder::RecordCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdDebugMarkerEndEXTArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdDebugMarkerInsertEXTArgs* CommandRecorder::RecordCmdDebugMarkerInsertEXT(
    VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
    auto* args = Alloc<CmdDebugMarkerInsertEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pMarkerInfo) {
        args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindTransformFeedbackBuffersEXTArgs* CommandRecorder::RecordCmdBindTransformFeedbackBuffersEXT(
    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes) {
    auto* args = Alloc<CmdBindTransformFeedbackBuffersEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstBinding = firstBinding;
    args->bindingCount = bindingCount;
    if (pBuffers) {
        args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pOffsets) {
        args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pSizes) {
        args->pSizes = CopyArray(pSizes, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    return args;
}

CmdBeginTransformFeedbackEXTArgs* CommandRecorder::RecordCmdBeginTransformFeedbackEXT(
    VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
    auto* args = Alloc<CmdBeginTransformFeedbackEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstCounterBuffer = firstCounterBuffer;
    args->counterBufferCount = counterBufferCount;
    if (pCounterBuffers) {
        args->pCounterBuffers =
            CopyArray(pCounterBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(counterBufferCount));
    }
    if (pCounterBufferOffsets) {
        args->pCounterBufferOffsets =
            CopyArray(pCounterBufferOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(counterBufferCount));
    }
    return args;
}

CmdEndTransformFeedbackEXTArgs* CommandRecorder::RecordCmdEndTransformFeedbackEXT(
    VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount,
    const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets) {
    auto* args = Alloc<CmdEndTransformFeedbackEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstCounterBuffer = firstCounterBuffer;
    args->counterBufferCount = counterBufferCount;
    if (pCounterBuffers) {
        args->pCounterBuffers =
            CopyArray(pCounterBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(counterBufferCount));
    }
    if (pCounterBufferOffsets) {
        args->pCounterBufferOffsets =
            CopyArray(pCounterBufferOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(counterBufferCount));
    }
    return args;
}

CmdBeginQueryIndexedEXTArgs* CommandRecorder::RecordCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer,
                                                                            VkQueryPool queryPool, uint32_t query,
                                                                            VkQueryControlFlags flags, uint32_t index) {
    auto* args = Alloc<CmdBeginQueryIndexedEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->query = query;
    args->flags = flags;
    args->index = index;
    return args;
}

CmdEndQueryIndexedEXTArgs* CommandRecorder::RecordCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer,
                                                                        VkQueryPool queryPool, uint32_t query,
                                                                        uint32_t index) {
    auto* args = Alloc<CmdEndQueryIndexedEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->queryPool = queryPool;
    args->query = query;
    args->index = index;
    return args;
}

CmdDrawIndirectByteCountEXTArgs* CommandRecorder::RecordCmdDrawIndirectByteCountEXT(
    VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer,
    VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) {
    auto* args = Alloc<CmdDrawIndirectByteCountEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->instanceCount = instanceCount;
    args->firstInstance = firstInstance;
    args->counterBuffer = counterBuffer;
    args->counterBufferOffset = counterBufferOffset;
    args->counterOffset = counterOffset;
    args->vertexStride = vertexStride;
    return args;
}

CmdCuLaunchKernelNVXArgs* CommandRecorder::RecordCmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer,
                                                                      const VkCuLaunchInfoNVX* pLaunchInfo) {
    auto* args = Alloc<CmdCuLaunchKernelNVXArgs>();
    args->commandBuffer = commandBuffer;
    if (pLaunchInfo) {
        args->pLaunchInfo = CopyArray(pLaunchInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdDrawIndirectCountAMDArgs* CommandRecorder::RecordCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer,
                                                                            VkBuffer buffer, VkDeviceSize offset,
                                                                            VkBuffer countBuffer,
                                                                            VkDeviceSize countBufferOffset,
                                                                            uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndirectCountAMDArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdDrawIndexedIndirectCountAMDArgs* CommandRecorder::RecordCmdDrawIndexedIndirectCountAMD(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawIndexedIndirectCountAMDArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdBeginConditionalRenderingEXTArgs* CommandRecorder::RecordCmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin) {
    auto* args = Alloc<CmdBeginConditionalRenderingEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pConditionalRenderingBegin) {
        args->pConditionalRenderingBegin =
            CopyArray(pConditionalRenderingBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndConditionalRenderingEXTArgs* CommandRecorder::RecordCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdEndConditionalRenderingEXTArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdSetViewportWScalingNVArgs* CommandRecorder::RecordCmdSetViewportWScalingNV(
    VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
    const VkViewportWScalingNV* pViewportWScalings) {
    auto* args = Alloc<CmdSetViewportWScalingNVArgs>();
    args->commandBuffer = commandBuffer;
    args->firstViewport = firstViewport;
    args->viewportCount = viewportCount;
    if (pViewportWScalings) {
        args->pViewportWScalings =
            CopyArray(pViewportWScalings, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetDiscardRectangleEXTArgs* CommandRecorder::RecordCmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer,
                                                                                uint32_t firstDiscardRectangle,
                                                                                uint32_t discardRectangleCount,
                                                                                const VkRect2D* pDiscardRectangles) {
    auto* args = Alloc<CmdSetDiscardRectangleEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstDiscardRectangle = firstDiscardRectangle;
    args->discardRectangleCount = discardRectangleCount;
    if (pDiscardRectangles) {
        args->pDiscardRectangles =
            CopyArray(pDiscardRectangles, static_cast<uint64_t>(0U), static_cast<uint64_t>(discardRectangleCount));
    }
    return args;
}

CmdSetDiscardRectangleEnableEXTArgs* CommandRecorder::RecordCmdSetDiscardRectangleEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) {
    auto* args = Alloc<CmdSetDiscardRectangleEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->discardRectangleEnable = discardRectangleEnable;
    return args;
}

CmdSetDiscardRectangleModeEXTArgs* CommandRecorder::RecordCmdSetDiscardRectangleModeEXT(
    VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) {
    auto* args = Alloc<CmdSetDiscardRectangleModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->discardRectangleMode = discardRectangleMode;
    return args;
}

CmdBeginDebugUtilsLabelEXTArgs* CommandRecorder::RecordCmdBeginDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto* args = Alloc<CmdBeginDebugUtilsLabelEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pLabelInfo) {
        args->pLabelInfo = CopyArray(pLabelInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdEndDebugUtilsLabelEXTArgs* CommandRecorder::RecordCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdEndDebugUtilsLabelEXTArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdInsertDebugUtilsLabelEXTArgs* CommandRecorder::RecordCmdInsertDebugUtilsLabelEXT(
    VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
    auto* args = Alloc<CmdInsertDebugUtilsLabelEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pLabelInfo) {
        args->pLabelInfo = CopyArray(pLabelInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

#ifdef VK_ENABLE_BETA_EXTENSIONS
CmdInitializeGraphScratchMemoryAMDXArgs* CommandRecorder::RecordCmdInitializeGraphScratchMemoryAMDX(
    VkCommandBuffer commandBuffer, VkDeviceAddress scratch) {
    auto* args = Alloc<CmdInitializeGraphScratchMemoryAMDXArgs>();
    args->commandBuffer = commandBuffer;
    args->scratch = scratch;
    return args;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
CmdDispatchGraphAMDXArgs* CommandRecorder::RecordCmdDispatchGraphAMDX(VkCommandBuffer commandBuffer,
                                                                      VkDeviceAddress scratch,
                                                                      const VkDispatchGraphCountInfoAMDX* pCountInfo) {
    auto* args = Alloc<CmdDispatchGraphAMDXArgs>();
    args->commandBuffer = commandBuffer;
    args->scratch = scratch;
    if (pCountInfo) {
        args->pCountInfo = CopyArray(pCountInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
CmdDispatchGraphIndirectAMDXArgs* CommandRecorder::RecordCmdDispatchGraphIndirectAMDX(
    VkCommandBuffer commandBuffer, VkDeviceAddress scratch, const VkDispatchGraphCountInfoAMDX* pCountInfo) {
    auto* args = Alloc<CmdDispatchGraphIndirectAMDXArgs>();
    args->commandBuffer = commandBuffer;
    args->scratch = scratch;
    if (pCountInfo) {
        args->pCountInfo = CopyArray(pCountInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

#ifdef VK_ENABLE_BETA_EXTENSIONS
CmdDispatchGraphIndirectCountAMDXArgs* CommandRecorder::RecordCmdDispatchGraphIndirectCountAMDX(
    VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceAddress countInfo) {
    auto* args = Alloc<CmdDispatchGraphIndirectCountAMDXArgs>();
    args->commandBuffer = commandBuffer;
    args->scratch = scratch;
    args->countInfo = countInfo;
    return args;
}
#endif  // VK_ENABLE_BETA_EXTENSIONS

CmdSetSampleLocationsEXTArgs* CommandRecorder::RecordCmdSetSampleLocationsEXT(
    VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
    auto* args = Alloc<CmdSetSampleLocationsEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pSampleLocationsInfo) {
        args->pSampleLocationsInfo =
            CopyArray(pSampleLocationsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindShadingRateImageNVArgs* CommandRecorder::RecordCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer,
                                                                                VkImageView imageView,
                                                                                VkImageLayout imageLayout) {
    auto* args = Alloc<CmdBindShadingRateImageNVArgs>();
    args->commandBuffer = commandBuffer;
    args->imageView = imageView;
    args->imageLayout = imageLayout;
    return args;
}

CmdSetViewportShadingRatePaletteNVArgs* CommandRecorder::RecordCmdSetViewportShadingRatePaletteNV(
    VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
    const VkShadingRatePaletteNV* pShadingRatePalettes) {
    auto* args = Alloc<CmdSetViewportShadingRatePaletteNVArgs>();
    args->commandBuffer = commandBuffer;
    args->firstViewport = firstViewport;
    args->viewportCount = viewportCount;
    if (pShadingRatePalettes) {
        args->pShadingRatePalettes =
            CopyArray(pShadingRatePalettes, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetCoarseSampleOrderNVArgs* CommandRecorder::RecordCmdSetCoarseSampleOrderNV(
    VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount,
    const VkCoarseSampleOrderCustomNV* pCustomSampleOrders) {
    auto* args = Alloc<CmdSetCoarseSampleOrderNVArgs>();
    args->commandBuffer = commandBuffer;
    args->sampleOrderType = sampleOrderType;
    args->customSampleOrderCount = customSampleOrderCount;
    if (pCustomSampleOrders) {
        args->pCustomSampleOrders =
            CopyArray(pCustomSampleOrders, static_cast<uint64_t>(0U), static_cast<uint64_t>(customSampleOrderCount));
    }
    return args;
}

CmdBuildAccelerationStructureNVArgs* CommandRecorder::RecordCmdBuildAccelerationStructureNV(
    VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData,
    VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src,
    VkBuffer scratch, VkDeviceSize scratchOffset) {
    auto* args = Alloc<CmdBuildAccelerationStructureNVArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->instanceData = instanceData;
    args->instanceOffset = instanceOffset;
    args->update = update;
    args->dst = dst;
    args->src = src;
    args->scratch = scratch;
    args->scratchOffset = scratchOffset;
    return args;
}

CmdCopyAccelerationStructureNVArgs* CommandRecorder::RecordCmdCopyAccelerationStructureNV(
    VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src,
    VkCopyAccelerationStructureModeKHR mode) {
    auto* args = Alloc<CmdCopyAccelerationStructureNVArgs>();
    args->commandBuffer = commandBuffer;
    args->dst = dst;
    args->src = src;
    args->mode = mode;
    return args;
}

CmdTraceRaysNVArgs* CommandRecorder::RecordCmdTraceRaysNV(
    VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset,
    VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride,
    VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride,
    VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset,
    VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) {
    auto* args = Alloc<CmdTraceRaysNVArgs>();
    args->commandBuffer = commandBuffer;
    args->raygenShaderBindingTableBuffer = raygenShaderBindingTableBuffer;
    args->raygenShaderBindingOffset = raygenShaderBindingOffset;
    args->missShaderBindingTableBuffer = missShaderBindingTableBuffer;
    args->missShaderBindingOffset = missShaderBindingOffset;
    args->missShaderBindingStride = missShaderBindingStride;
    args->hitShaderBindingTableBuffer = hitShaderBindingTableBuffer;
    args->hitShaderBindingOffset = hitShaderBindingOffset;
    args->hitShaderBindingStride = hitShaderBindingStride;
    args->callableShaderBindingTableBuffer = callableShaderBindingTableBuffer;
    args->callableShaderBindingOffset = callableShaderBindingOffset;
    args->callableShaderBindingStride = callableShaderBindingStride;
    args->width = width;
    args->height = height;
    args->depth = depth;
    return args;
}

CmdWriteAccelerationStructuresPropertiesNVArgs* CommandRecorder::RecordCmdWriteAccelerationStructuresPropertiesNV(
    VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount,
    const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool,
    uint32_t firstQuery) {
    auto* args = Alloc<CmdWriteAccelerationStructuresPropertiesNVArgs>();
    args->commandBuffer = commandBuffer;
    args->accelerationStructureCount = accelerationStructureCount;
    if (pAccelerationStructures) {
        args->pAccelerationStructures = CopyArray(pAccelerationStructures, static_cast<uint64_t>(0U),
                                                  static_cast<uint64_t>(accelerationStructureCount));
    }
    args->queryType = queryType;
    args->queryPool = queryPool;
    args->firstQuery = firstQuery;
    return args;
}

CmdWriteBufferMarkerAMDArgs* CommandRecorder::RecordCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer,
                                                                            VkPipelineStageFlagBits pipelineStage,
                                                                            VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                                                            uint32_t marker) {
    auto* args = Alloc<CmdWriteBufferMarkerAMDArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineStage = pipelineStage;
    args->dstBuffer = dstBuffer;
    args->dstOffset = dstOffset;
    args->marker = marker;
    return args;
}

CmdDrawMeshTasksNVArgs* CommandRecorder::RecordCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount,
                                                                  uint32_t firstTask) {
    auto* args = Alloc<CmdDrawMeshTasksNVArgs>();
    args->commandBuffer = commandBuffer;
    args->taskCount = taskCount;
    args->firstTask = firstTask;
    return args;
}

CmdDrawMeshTasksIndirectNVArgs* CommandRecorder::RecordCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer,
                                                                                  VkBuffer buffer, VkDeviceSize offset,
                                                                                  uint32_t drawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawMeshTasksIndirectNVArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->drawCount = drawCount;
    args->stride = stride;
    return args;
}

CmdDrawMeshTasksIndirectCountNVArgs* CommandRecorder::RecordCmdDrawMeshTasksIndirectCountNV(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawMeshTasksIndirectCountNVArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

CmdSetExclusiveScissorEnableNVArgs* CommandRecorder::RecordCmdSetExclusiveScissorEnableNV(
    VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount,
    const VkBool32* pExclusiveScissorEnables) {
    auto* args = Alloc<CmdSetExclusiveScissorEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->firstExclusiveScissor = firstExclusiveScissor;
    args->exclusiveScissorCount = exclusiveScissorCount;
    if (pExclusiveScissorEnables) {
        args->pExclusiveScissorEnables = CopyArray(pExclusiveScissorEnables, static_cast<uint64_t>(0U),
                                                   static_cast<uint64_t>(exclusiveScissorCount));
    }
    return args;
}

CmdSetExclusiveScissorNVArgs* CommandRecorder::RecordCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer,
                                                                              uint32_t firstExclusiveScissor,
                                                                              uint32_t exclusiveScissorCount,
                                                                              const VkRect2D* pExclusiveScissors) {
    auto* args = Alloc<CmdSetExclusiveScissorNVArgs>();
    args->commandBuffer = commandBuffer;
    args->firstExclusiveScissor = firstExclusiveScissor;
    args->exclusiveScissorCount = exclusiveScissorCount;
    if (pExclusiveScissors) {
        args->pExclusiveScissors =
            CopyArray(pExclusiveScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(exclusiveScissorCount));
    }
    return args;
}

CmdSetCheckpointNVArgs* CommandRecorder::RecordCmdSetCheckpointNV(VkCommandBuffer commandBuffer,
                                                                  const void* pCheckpointMarker) {
    auto* args = Alloc<CmdSetCheckpointNVArgs>();
    args->commandBuffer = commandBuffer;
    args->pCheckpointMarker = pCheckpointMarker;
    return args;
}

CmdSetPerformanceMarkerINTELArgs* CommandRecorder::RecordCmdSetPerformanceMarkerINTEL(
    VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo) {
    auto* args = Alloc<CmdSetPerformanceMarkerINTELArgs>();
    args->commandBuffer = commandBuffer;
    if (pMarkerInfo) {
        args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetPerformanceStreamMarkerINTELArgs* CommandRecorder::RecordCmdSetPerformanceStreamMarkerINTEL(
    VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo) {
    auto* args = Alloc<CmdSetPerformanceStreamMarkerINTELArgs>();
    args->commandBuffer = commandBuffer;
    if (pMarkerInfo) {
        args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetPerformanceOverrideINTELArgs* CommandRecorder::RecordCmdSetPerformanceOverrideINTEL(
    VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo) {
    auto* args = Alloc<CmdSetPerformanceOverrideINTELArgs>();
    args->commandBuffer = commandBuffer;
    if (pOverrideInfo) {
        args->pOverrideInfo = CopyArray(pOverrideInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdSetLineStippleEXTArgs* CommandRecorder::RecordCmdSetLineStippleEXT(VkCommandBuffer commandBuffer,
                                                                      uint32_t lineStippleFactor,
                                                                      uint16_t lineStipplePattern) {
    auto* args = Alloc<CmdSetLineStippleEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->lineStippleFactor = lineStippleFactor;
    args->lineStipplePattern = lineStipplePattern;
    return args;
}

CmdSetCullModeEXTArgs* CommandRecorder::RecordCmdSetCullModeEXT(VkCommandBuffer commandBuffer,
                                                                VkCullModeFlags cullMode) {
    auto* args = Alloc<CmdSetCullModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->cullMode = cullMode;
    return args;
}

CmdSetFrontFaceEXTArgs* CommandRecorder::RecordCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer,
                                                                  VkFrontFace frontFace) {
    auto* args = Alloc<CmdSetFrontFaceEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->frontFace = frontFace;
    return args;
}

CmdSetPrimitiveTopologyEXTArgs* CommandRecorder::RecordCmdSetPrimitiveTopologyEXT(
    VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    auto* args = Alloc<CmdSetPrimitiveTopologyEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->primitiveTopology = primitiveTopology;
    return args;
}

CmdSetViewportWithCountEXTArgs* CommandRecorder::RecordCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer,
                                                                                  uint32_t viewportCount,
                                                                                  const VkViewport* pViewports) {
    auto* args = Alloc<CmdSetViewportWithCountEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->viewportCount = viewportCount;
    if (pViewports) {
        args->pViewports = CopyArray(pViewports, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetScissorWithCountEXTArgs* CommandRecorder::RecordCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer,
                                                                                uint32_t scissorCount,
                                                                                const VkRect2D* pScissors) {
    auto* args = Alloc<CmdSetScissorWithCountEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->scissorCount = scissorCount;
    if (pScissors) {
        args->pScissors = CopyArray(pScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(scissorCount));
    }
    return args;
}

CmdBindVertexBuffers2EXTArgs* CommandRecorder::RecordCmdBindVertexBuffers2EXT(
    VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers,
    const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
    auto* args = Alloc<CmdBindVertexBuffers2EXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstBinding = firstBinding;
    args->bindingCount = bindingCount;
    if (pBuffers) {
        args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pOffsets) {
        args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pSizes) {
        args->pSizes = CopyArray(pSizes, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    if (pStrides) {
        args->pStrides = CopyArray(pStrides, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
    return args;
}

CmdSetDepthTestEnableEXTArgs* CommandRecorder::RecordCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer,
                                                                              VkBool32 depthTestEnable) {
    auto* args = Alloc<CmdSetDepthTestEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthTestEnable = depthTestEnable;
    return args;
}

CmdSetDepthWriteEnableEXTArgs* CommandRecorder::RecordCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer,
                                                                                VkBool32 depthWriteEnable) {
    auto* args = Alloc<CmdSetDepthWriteEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthWriteEnable = depthWriteEnable;
    return args;
}

CmdSetDepthCompareOpEXTArgs* CommandRecorder::RecordCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer,
                                                                            VkCompareOp depthCompareOp) {
    auto* args = Alloc<CmdSetDepthCompareOpEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthCompareOp = depthCompareOp;
    return args;
}

CmdSetDepthBoundsTestEnableEXTArgs* CommandRecorder::RecordCmdSetDepthBoundsTestEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    auto* args = Alloc<CmdSetDepthBoundsTestEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthBoundsTestEnable = depthBoundsTestEnable;
    return args;
}

CmdSetStencilTestEnableEXTArgs* CommandRecorder::RecordCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer,
                                                                                  VkBool32 stencilTestEnable) {
    auto* args = Alloc<CmdSetStencilTestEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->stencilTestEnable = stencilTestEnable;
    return args;
}

CmdSetStencilOpEXTArgs* CommandRecorder::RecordCmdSetStencilOpEXT(VkCommandBuffer commandBuffer,
                                                                  VkStencilFaceFlags faceMask, VkStencilOp failOp,
                                                                  VkStencilOp passOp, VkStencilOp depthFailOp,
                                                                  VkCompareOp compareOp) {
    auto* args = Alloc<CmdSetStencilOpEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->faceMask = faceMask;
    args->failOp = failOp;
    args->passOp = passOp;
    args->depthFailOp = depthFailOp;
    args->compareOp = compareOp;
    return args;
}

CmdPreprocessGeneratedCommandsNVArgs* CommandRecorder::RecordCmdPreprocessGeneratedCommandsNV(
    VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
    auto* args = Alloc<CmdPreprocessGeneratedCommandsNVArgs>();
    args->commandBuffer = commandBuffer;
    if (pGeneratedCommandsInfo) {
        args->pGeneratedCommandsInfo =
            CopyArray(pGeneratedCommandsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdExecuteGeneratedCommandsNVArgs* CommandRecorder::RecordCmdExecuteGeneratedCommandsNV(
    VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo) {
    auto* args = Alloc<CmdExecuteGeneratedCommandsNVArgs>();
    args->commandBuffer = commandBuffer;
    args->isPreprocessed = isPreprocessed;
    if (pGeneratedCommandsInfo) {
        args->pGeneratedCommandsInfo =
            CopyArray(pGeneratedCommandsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindPipelineShaderGroupNVArgs* CommandRecorder::RecordCmdBindPipelineShaderGroupNV(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) {
    auto* args = Alloc<CmdBindPipelineShaderGroupNVArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->pipeline = pipeline;
    args->groupIndex = groupIndex;
    return args;
}

CmdSetDepthBias2EXTArgs* CommandRecorder::RecordCmdSetDepthBias2EXT(VkCommandBuffer commandBuffer,
                                                                    const VkDepthBiasInfoEXT* pDepthBiasInfo) {
    auto* args = Alloc<CmdSetDepthBias2EXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pDepthBiasInfo) {
        args->pDepthBiasInfo = CopyArray(pDepthBiasInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCudaLaunchKernelNVArgs* CommandRecorder::RecordCmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer,
                                                                        const VkCudaLaunchInfoNV* pLaunchInfo) {
    auto* args = Alloc<CmdCudaLaunchKernelNVArgs>();
    args->commandBuffer = commandBuffer;
    if (pLaunchInfo) {
        args->pLaunchInfo = CopyArray(pLaunchInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindDescriptorBuffersEXTArgs* CommandRecorder::RecordCmdBindDescriptorBuffersEXT(
    VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT* pBindingInfos) {
    auto* args = Alloc<CmdBindDescriptorBuffersEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->bufferCount = bufferCount;
    if (pBindingInfos) {
        args->pBindingInfos = CopyArray(pBindingInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(bufferCount));
    }
    return args;
}

CmdSetDescriptorBufferOffsetsEXTArgs* CommandRecorder::RecordCmdSetDescriptorBufferOffsetsEXT(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet,
    uint32_t setCount, const uint32_t* pBufferIndices, const VkDeviceSize* pOffsets) {
    auto* args = Alloc<CmdSetDescriptorBufferOffsetsEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->layout = layout;
    args->firstSet = firstSet;
    args->setCount = setCount;
    if (pBufferIndices) {
        args->pBufferIndices = CopyArray(pBufferIndices, static_cast<uint64_t>(0U), static_cast<uint64_t>(setCount));
    }
    if (pOffsets) {
        args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(setCount));
    }
    return args;
}

CmdBindDescriptorBufferEmbeddedSamplersEXTArgs* CommandRecorder::RecordCmdBindDescriptorBufferEmbeddedSamplersEXT(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) {
    auto* args = Alloc<CmdBindDescriptorBufferEmbeddedSamplersEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->layout = layout;
    args->set = set;
    return args;
}

CmdSetFragmentShadingRateEnumNVArgs* CommandRecorder::RecordCmdSetFragmentShadingRateEnumNV(
    VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate,
    const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    auto* args = Alloc<CmdSetFragmentShadingRateEnumNVArgs>();
    args->commandBuffer = commandBuffer;
    args->shadingRate = shadingRate;
    for (uint32_t i = 0; i < 2; ++i) {
        args->combinerOps[i] = combinerOps[i];
    }
    return args;
}

CmdSetVertexInputEXTArgs* CommandRecorder::RecordCmdSetVertexInputEXT(
    VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount,
    const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount,
    const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions) {
    auto* args = Alloc<CmdSetVertexInputEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->vertexBindingDescriptionCount = vertexBindingDescriptionCount;
    if (pVertexBindingDescriptions) {
        args->pVertexBindingDescriptions = CopyArray(pVertexBindingDescriptions, static_cast<uint64_t>(0U),
                                                     static_cast<uint64_t>(vertexBindingDescriptionCount));
    }
    args->vertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
    if (pVertexAttributeDescriptions) {
        args->pVertexAttributeDescriptions = CopyArray(pVertexAttributeDescriptions, static_cast<uint64_t>(0U),
                                                       static_cast<uint64_t>(vertexAttributeDescriptionCount));
    }
    return args;
}

CmdSubpassShadingHUAWEIArgs* CommandRecorder::RecordCmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) {
    auto* args = Alloc<CmdSubpassShadingHUAWEIArgs>();
    args->commandBuffer = commandBuffer;
    return args;
}

CmdBindInvocationMaskHUAWEIArgs* CommandRecorder::RecordCmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer,
                                                                                    VkImageView imageView,
                                                                                    VkImageLayout imageLayout) {
    auto* args = Alloc<CmdBindInvocationMaskHUAWEIArgs>();
    args->commandBuffer = commandBuffer;
    args->imageView = imageView;
    args->imageLayout = imageLayout;
    return args;
}

CmdSetPatchControlPointsEXTArgs* CommandRecorder::RecordCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer,
                                                                                    uint32_t patchControlPoints) {
    auto* args = Alloc<CmdSetPatchControlPointsEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->patchControlPoints = patchControlPoints;
    return args;
}

CmdSetRasterizerDiscardEnableEXTArgs* CommandRecorder::RecordCmdSetRasterizerDiscardEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    auto* args = Alloc<CmdSetRasterizerDiscardEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->rasterizerDiscardEnable = rasterizerDiscardEnable;
    return args;
}

CmdSetDepthBiasEnableEXTArgs* CommandRecorder::RecordCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer,
                                                                              VkBool32 depthBiasEnable) {
    auto* args = Alloc<CmdSetDepthBiasEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthBiasEnable = depthBiasEnable;
    return args;
}

CmdSetLogicOpEXTArgs* CommandRecorder::RecordCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    auto* args = Alloc<CmdSetLogicOpEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->logicOp = logicOp;
    return args;
}

CmdSetPrimitiveRestartEnableEXTArgs* CommandRecorder::RecordCmdSetPrimitiveRestartEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    auto* args = Alloc<CmdSetPrimitiveRestartEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->primitiveRestartEnable = primitiveRestartEnable;
    return args;
}

CmdSetColorWriteEnableEXTArgs* CommandRecorder::RecordCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer,
                                                                                uint32_t attachmentCount,
                                                                                const VkBool32* pColorWriteEnables) {
    auto* args = Alloc<CmdSetColorWriteEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->attachmentCount = attachmentCount;
    if (pColorWriteEnables) {
        args->pColorWriteEnables =
            CopyArray(pColorWriteEnables, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    return args;
}

CmdDrawMultiEXTArgs* CommandRecorder::RecordCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                                            const VkMultiDrawInfoEXT* pVertexInfo,
                                                            uint32_t instanceCount, uint32_t firstInstance,
                                                            uint32_t stride) {
    auto* args = Alloc<CmdDrawMultiEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->drawCount = drawCount;
    if (pVertexInfo) {
        args->pVertexInfo = CopyArray(pVertexInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(drawCount));
    }
    args->instanceCount = instanceCount;
    args->firstInstance = firstInstance;
    args->stride = stride;
    return args;
}

CmdDrawMultiIndexedEXTArgs* CommandRecorder::RecordCmdDrawMultiIndexedEXT(
    VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo,
    uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset) {
    auto* args = Alloc<CmdDrawMultiIndexedEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->drawCount = drawCount;
    if (pIndexInfo) {
        args->pIndexInfo = CopyArray(pIndexInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(drawCount));
    }
    args->instanceCount = instanceCount;
    args->firstInstance = firstInstance;
    args->stride = stride;
    if (pVertexOffset) {
        args->pVertexOffset = CopyArray(pVertexOffset, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBuildMicromapsEXTArgs* CommandRecorder::RecordCmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                                      const VkMicromapBuildInfoEXT* pInfos) {
    auto* args = Alloc<CmdBuildMicromapsEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->infoCount = infoCount;
    if (pInfos) {
        args->pInfos = CopyArray(pInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    return args;
}

CmdCopyMicromapEXTArgs* CommandRecorder::RecordCmdCopyMicromapEXT(VkCommandBuffer commandBuffer,
                                                                  const VkCopyMicromapInfoEXT* pInfo) {
    auto* args = Alloc<CmdCopyMicromapEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyMicromapToMemoryEXTArgs* CommandRecorder::RecordCmdCopyMicromapToMemoryEXT(
    VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT* pInfo) {
    auto* args = Alloc<CmdCopyMicromapToMemoryEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyMemoryToMicromapEXTArgs* CommandRecorder::RecordCmdCopyMemoryToMicromapEXT(
    VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT* pInfo) {
    auto* args = Alloc<CmdCopyMemoryToMicromapEXTArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdWriteMicromapsPropertiesEXTArgs* CommandRecorder::RecordCmdWriteMicromapsPropertiesEXT(
    VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT* pMicromaps, VkQueryType queryType,
    VkQueryPool queryPool, uint32_t firstQuery) {
    auto* args = Alloc<CmdWriteMicromapsPropertiesEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->micromapCount = micromapCount;
    if (pMicromaps) {
        args->pMicromaps = CopyArray(pMicromaps, static_cast<uint64_t>(0U), static_cast<uint64_t>(micromapCount));
    }
    args->queryType = queryType;
    args->queryPool = queryPool;
    args->firstQuery = firstQuery;
    return args;
}

CmdDrawClusterHUAWEIArgs* CommandRecorder::RecordCmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer,
                                                                      uint32_t groupCountX, uint32_t groupCountY,
                                                                      uint32_t groupCountZ) {
    auto* args = Alloc<CmdDrawClusterHUAWEIArgs>();
    args->commandBuffer = commandBuffer;
    args->groupCountX = groupCountX;
    args->groupCountY = groupCountY;
    args->groupCountZ = groupCountZ;
    return args;
}

CmdDrawClusterIndirectHUAWEIArgs* CommandRecorder::RecordCmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer,
                                                                                      VkBuffer buffer,
                                                                                      VkDeviceSize offset) {
    auto* args = Alloc<CmdDrawClusterIndirectHUAWEIArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    return args;
}

CmdCopyMemoryIndirectNVArgs* CommandRecorder::RecordCmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer,
                                                                            VkDeviceAddress copyBufferAddress,
                                                                            uint32_t copyCount, uint32_t stride) {
    auto* args = Alloc<CmdCopyMemoryIndirectNVArgs>();
    args->commandBuffer = commandBuffer;
    args->copyBufferAddress = copyBufferAddress;
    args->copyCount = copyCount;
    args->stride = stride;
    return args;
}

CmdCopyMemoryToImageIndirectNVArgs* CommandRecorder::RecordCmdCopyMemoryToImageIndirectNV(
    VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride,
    VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers* pImageSubresources) {
    auto* args = Alloc<CmdCopyMemoryToImageIndirectNVArgs>();
    args->commandBuffer = commandBuffer;
    args->copyBufferAddress = copyBufferAddress;
    args->copyCount = copyCount;
    args->stride = stride;
    args->dstImage = dstImage;
    args->dstImageLayout = dstImageLayout;
    if (pImageSubresources) {
        args->pImageSubresources =
            CopyArray(pImageSubresources, static_cast<uint64_t>(0U), static_cast<uint64_t>(copyCount));
    }
    return args;
}

CmdDecompressMemoryNVArgs* CommandRecorder::RecordCmdDecompressMemoryNV(
    VkCommandBuffer commandBuffer, uint32_t decompressRegionCount,
    const VkDecompressMemoryRegionNV* pDecompressMemoryRegions) {
    auto* args = Alloc<CmdDecompressMemoryNVArgs>();
    args->commandBuffer = commandBuffer;
    args->decompressRegionCount = decompressRegionCount;
    if (pDecompressMemoryRegions) {
        args->pDecompressMemoryRegions = CopyArray(pDecompressMemoryRegions, static_cast<uint64_t>(0U),
                                                   static_cast<uint64_t>(decompressRegionCount));
    }
    return args;
}

CmdDecompressMemoryIndirectCountNVArgs* CommandRecorder::RecordCmdDecompressMemoryIndirectCountNV(
    VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress,
    VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) {
    auto* args = Alloc<CmdDecompressMemoryIndirectCountNVArgs>();
    args->commandBuffer = commandBuffer;
    args->indirectCommandsAddress = indirectCommandsAddress;
    args->indirectCommandsCountAddress = indirectCommandsCountAddress;
    args->stride = stride;
    return args;
}

CmdUpdatePipelineIndirectBufferNVArgs* CommandRecorder::RecordCmdUpdatePipelineIndirectBufferNV(
    VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    auto* args = Alloc<CmdUpdatePipelineIndirectBufferNVArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineBindPoint = pipelineBindPoint;
    args->pipeline = pipeline;
    return args;
}

CmdSetDepthClampEnableEXTArgs* CommandRecorder::RecordCmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer,
                                                                                VkBool32 depthClampEnable) {
    auto* args = Alloc<CmdSetDepthClampEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthClampEnable = depthClampEnable;
    return args;
}

CmdSetPolygonModeEXTArgs* CommandRecorder::RecordCmdSetPolygonModeEXT(VkCommandBuffer commandBuffer,
                                                                      VkPolygonMode polygonMode) {
    auto* args = Alloc<CmdSetPolygonModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->polygonMode = polygonMode;
    return args;
}

CmdSetRasterizationSamplesEXTArgs* CommandRecorder::RecordCmdSetRasterizationSamplesEXT(
    VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) {
    auto* args = Alloc<CmdSetRasterizationSamplesEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->rasterizationSamples = rasterizationSamples;
    return args;
}

CmdSetSampleMaskEXTArgs* CommandRecorder::RecordCmdSetSampleMaskEXT(VkCommandBuffer commandBuffer,
                                                                    VkSampleCountFlagBits samples,
                                                                    const VkSampleMask* pSampleMask) {
    auto* args = Alloc<CmdSetSampleMaskEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->samples = samples;
    if (pSampleMask) {
        args->pSampleMask =
            CopyArray(pSampleMask, static_cast<uint64_t>(0U), static_cast<uint64_t>((samples + 31) / 32));
    }
    return args;
}

CmdSetAlphaToCoverageEnableEXTArgs* CommandRecorder::RecordCmdSetAlphaToCoverageEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) {
    auto* args = Alloc<CmdSetAlphaToCoverageEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->alphaToCoverageEnable = alphaToCoverageEnable;
    return args;
}

CmdSetAlphaToOneEnableEXTArgs* CommandRecorder::RecordCmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer,
                                                                                VkBool32 alphaToOneEnable) {
    auto* args = Alloc<CmdSetAlphaToOneEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->alphaToOneEnable = alphaToOneEnable;
    return args;
}

CmdSetLogicOpEnableEXTArgs* CommandRecorder::RecordCmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer,
                                                                          VkBool32 logicOpEnable) {
    auto* args = Alloc<CmdSetLogicOpEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->logicOpEnable = logicOpEnable;
    return args;
}

CmdSetColorBlendEnableEXTArgs* CommandRecorder::RecordCmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer,
                                                                                uint32_t firstAttachment,
                                                                                uint32_t attachmentCount,
                                                                                const VkBool32* pColorBlendEnables) {
    auto* args = Alloc<CmdSetColorBlendEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstAttachment = firstAttachment;
    args->attachmentCount = attachmentCount;
    if (pColorBlendEnables) {
        args->pColorBlendEnables =
            CopyArray(pColorBlendEnables, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    return args;
}

CmdSetColorBlendEquationEXTArgs* CommandRecorder::RecordCmdSetColorBlendEquationEXT(
    VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount,
    const VkColorBlendEquationEXT* pColorBlendEquations) {
    auto* args = Alloc<CmdSetColorBlendEquationEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstAttachment = firstAttachment;
    args->attachmentCount = attachmentCount;
    if (pColorBlendEquations) {
        args->pColorBlendEquations =
            CopyArray(pColorBlendEquations, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    return args;
}

CmdSetColorWriteMaskEXTArgs* CommandRecorder::RecordCmdSetColorWriteMaskEXT(
    VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount,
    const VkColorComponentFlags* pColorWriteMasks) {
    auto* args = Alloc<CmdSetColorWriteMaskEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstAttachment = firstAttachment;
    args->attachmentCount = attachmentCount;
    if (pColorWriteMasks) {
        args->pColorWriteMasks =
            CopyArray(pColorWriteMasks, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    return args;
}

CmdSetTessellationDomainOriginEXTArgs* CommandRecorder::RecordCmdSetTessellationDomainOriginEXT(
    VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) {
    auto* args = Alloc<CmdSetTessellationDomainOriginEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->domainOrigin = domainOrigin;
    return args;
}

CmdSetRasterizationStreamEXTArgs* CommandRecorder::RecordCmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer,
                                                                                      uint32_t rasterizationStream) {
    auto* args = Alloc<CmdSetRasterizationStreamEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->rasterizationStream = rasterizationStream;
    return args;
}

CmdSetConservativeRasterizationModeEXTArgs* CommandRecorder::RecordCmdSetConservativeRasterizationModeEXT(
    VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) {
    auto* args = Alloc<CmdSetConservativeRasterizationModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->conservativeRasterizationMode = conservativeRasterizationMode;
    return args;
}

CmdSetExtraPrimitiveOverestimationSizeEXTArgs* CommandRecorder::RecordCmdSetExtraPrimitiveOverestimationSizeEXT(
    VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) {
    auto* args = Alloc<CmdSetExtraPrimitiveOverestimationSizeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->extraPrimitiveOverestimationSize = extraPrimitiveOverestimationSize;
    return args;
}

CmdSetDepthClipEnableEXTArgs* CommandRecorder::RecordCmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer,
                                                                              VkBool32 depthClipEnable) {
    auto* args = Alloc<CmdSetDepthClipEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->depthClipEnable = depthClipEnable;
    return args;
}

CmdSetSampleLocationsEnableEXTArgs* CommandRecorder::RecordCmdSetSampleLocationsEnableEXT(
    VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) {
    auto* args = Alloc<CmdSetSampleLocationsEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->sampleLocationsEnable = sampleLocationsEnable;
    return args;
}

CmdSetColorBlendAdvancedEXTArgs* CommandRecorder::RecordCmdSetColorBlendAdvancedEXT(
    VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount,
    const VkColorBlendAdvancedEXT* pColorBlendAdvanced) {
    auto* args = Alloc<CmdSetColorBlendAdvancedEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->firstAttachment = firstAttachment;
    args->attachmentCount = attachmentCount;
    if (pColorBlendAdvanced) {
        args->pColorBlendAdvanced =
            CopyArray(pColorBlendAdvanced, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
    return args;
}

CmdSetProvokingVertexModeEXTArgs* CommandRecorder::RecordCmdSetProvokingVertexModeEXT(
    VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) {
    auto* args = Alloc<CmdSetProvokingVertexModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->provokingVertexMode = provokingVertexMode;
    return args;
}

CmdSetLineRasterizationModeEXTArgs* CommandRecorder::RecordCmdSetLineRasterizationModeEXT(
    VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) {
    auto* args = Alloc<CmdSetLineRasterizationModeEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->lineRasterizationMode = lineRasterizationMode;
    return args;
}

CmdSetLineStippleEnableEXTArgs* CommandRecorder::RecordCmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer,
                                                                                  VkBool32 stippledLineEnable) {
    auto* args = Alloc<CmdSetLineStippleEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->stippledLineEnable = stippledLineEnable;
    return args;
}

CmdSetDepthClipNegativeOneToOneEXTArgs* CommandRecorder::RecordCmdSetDepthClipNegativeOneToOneEXT(
    VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) {
    auto* args = Alloc<CmdSetDepthClipNegativeOneToOneEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->negativeOneToOne = negativeOneToOne;
    return args;
}

CmdSetViewportWScalingEnableNVArgs* CommandRecorder::RecordCmdSetViewportWScalingEnableNV(
    VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) {
    auto* args = Alloc<CmdSetViewportWScalingEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->viewportWScalingEnable = viewportWScalingEnable;
    return args;
}

CmdSetViewportSwizzleNVArgs* CommandRecorder::RecordCmdSetViewportSwizzleNV(
    VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
    const VkViewportSwizzleNV* pViewportSwizzles) {
    auto* args = Alloc<CmdSetViewportSwizzleNVArgs>();
    args->commandBuffer = commandBuffer;
    args->firstViewport = firstViewport;
    args->viewportCount = viewportCount;
    if (pViewportSwizzles) {
        args->pViewportSwizzles =
            CopyArray(pViewportSwizzles, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
    return args;
}

CmdSetCoverageToColorEnableNVArgs* CommandRecorder::RecordCmdSetCoverageToColorEnableNV(
    VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) {
    auto* args = Alloc<CmdSetCoverageToColorEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageToColorEnable = coverageToColorEnable;
    return args;
}

CmdSetCoverageToColorLocationNVArgs* CommandRecorder::RecordCmdSetCoverageToColorLocationNV(
    VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) {
    auto* args = Alloc<CmdSetCoverageToColorLocationNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageToColorLocation = coverageToColorLocation;
    return args;
}

CmdSetCoverageModulationModeNVArgs* CommandRecorder::RecordCmdSetCoverageModulationModeNV(
    VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) {
    auto* args = Alloc<CmdSetCoverageModulationModeNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageModulationMode = coverageModulationMode;
    return args;
}

CmdSetCoverageModulationTableEnableNVArgs* CommandRecorder::RecordCmdSetCoverageModulationTableEnableNV(
    VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) {
    auto* args = Alloc<CmdSetCoverageModulationTableEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageModulationTableEnable = coverageModulationTableEnable;
    return args;
}

CmdSetCoverageModulationTableNVArgs* CommandRecorder::RecordCmdSetCoverageModulationTableNV(
    VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float* pCoverageModulationTable) {
    auto* args = Alloc<CmdSetCoverageModulationTableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageModulationTableCount = coverageModulationTableCount;
    if (pCoverageModulationTable) {
        args->pCoverageModulationTable = CopyArray(pCoverageModulationTable, static_cast<uint64_t>(0U),
                                                   static_cast<uint64_t>(coverageModulationTableCount));
    }
    return args;
}

CmdSetShadingRateImageEnableNVArgs* CommandRecorder::RecordCmdSetShadingRateImageEnableNV(
    VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) {
    auto* args = Alloc<CmdSetShadingRateImageEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->shadingRateImageEnable = shadingRateImageEnable;
    return args;
}

CmdSetRepresentativeFragmentTestEnableNVArgs* CommandRecorder::RecordCmdSetRepresentativeFragmentTestEnableNV(
    VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) {
    auto* args = Alloc<CmdSetRepresentativeFragmentTestEnableNVArgs>();
    args->commandBuffer = commandBuffer;
    args->representativeFragmentTestEnable = representativeFragmentTestEnable;
    return args;
}

CmdSetCoverageReductionModeNVArgs* CommandRecorder::RecordCmdSetCoverageReductionModeNV(
    VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) {
    auto* args = Alloc<CmdSetCoverageReductionModeNVArgs>();
    args->commandBuffer = commandBuffer;
    args->coverageReductionMode = coverageReductionMode;
    return args;
}

CmdOpticalFlowExecuteNVArgs* CommandRecorder::RecordCmdOpticalFlowExecuteNV(
    VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV* pExecuteInfo) {
    auto* args = Alloc<CmdOpticalFlowExecuteNVArgs>();
    args->commandBuffer = commandBuffer;
    args->session = session;
    if (pExecuteInfo) {
        args->pExecuteInfo = CopyArray(pExecuteInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdBindShadersEXTArgs* CommandRecorder::RecordCmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount,
                                                                const VkShaderStageFlagBits* pStages,
                                                                const VkShaderEXT* pShaders) {
    auto* args = Alloc<CmdBindShadersEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->stageCount = stageCount;
    if (pStages) {
        args->pStages = CopyArray(pStages, static_cast<uint64_t>(0U), static_cast<uint64_t>(stageCount));
    }
    if (pShaders) {
        args->pShaders = CopyArray(pShaders, static_cast<uint64_t>(0U), static_cast<uint64_t>(stageCount));
    }
    return args;
}

CmdSetAttachmentFeedbackLoopEnableEXTArgs* CommandRecorder::RecordCmdSetAttachmentFeedbackLoopEnableEXT(
    VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) {
    auto* args = Alloc<CmdSetAttachmentFeedbackLoopEnableEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->aspectMask = aspectMask;
    return args;
}

CmdBuildAccelerationStructuresKHRArgs* CommandRecorder::RecordCmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR* const* ppBuildRangeInfos) {
    auto* args = Alloc<CmdBuildAccelerationStructuresKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->infoCount = infoCount;
    if (pInfos) {
        args->pInfos = CopyArray(pInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    if (ppBuildRangeInfos) {
        args->ppBuildRangeInfos =
            CopyArray(ppBuildRangeInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    return args;
}

CmdBuildAccelerationStructuresIndirectKHRArgs* CommandRecorder::RecordCmdBuildAccelerationStructuresIndirectKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos,
    const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides,
    const uint32_t* const* ppMaxPrimitiveCounts) {
    auto* args = Alloc<CmdBuildAccelerationStructuresIndirectKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->infoCount = infoCount;
    if (pInfos) {
        args->pInfos = CopyArray(pInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    if (pIndirectDeviceAddresses) {
        args->pIndirectDeviceAddresses =
            CopyArray(pIndirectDeviceAddresses, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    if (pIndirectStrides) {
        args->pIndirectStrides =
            CopyArray(pIndirectStrides, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    if (ppMaxPrimitiveCounts) {
        args->ppMaxPrimitiveCounts =
            CopyArray(ppMaxPrimitiveCounts, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
    return args;
}

CmdCopyAccelerationStructureKHRArgs* CommandRecorder::RecordCmdCopyAccelerationStructureKHR(
    VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo) {
    auto* args = Alloc<CmdCopyAccelerationStructureKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyAccelerationStructureToMemoryKHRArgs* CommandRecorder::RecordCmdCopyAccelerationStructureToMemoryKHR(
    VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
    auto* args = Alloc<CmdCopyAccelerationStructureToMemoryKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdCopyMemoryToAccelerationStructureKHRArgs* CommandRecorder::RecordCmdCopyMemoryToAccelerationStructureKHR(
    VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
    auto* args = Alloc<CmdCopyMemoryToAccelerationStructureKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pInfo) {
        args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    return args;
}

CmdWriteAccelerationStructuresPropertiesKHRArgs* CommandRecorder::RecordCmdWriteAccelerationStructuresPropertiesKHR(
    VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount,
    const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool,
    uint32_t firstQuery) {
    auto* args = Alloc<CmdWriteAccelerationStructuresPropertiesKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->accelerationStructureCount = accelerationStructureCount;
    if (pAccelerationStructures) {
        args->pAccelerationStructures = CopyArray(pAccelerationStructures, static_cast<uint64_t>(0U),
                                                  static_cast<uint64_t>(accelerationStructureCount));
    }
    args->queryType = queryType;
    args->queryPool = queryPool;
    args->firstQuery = firstQuery;
    return args;
}

CmdTraceRaysKHRArgs* CommandRecorder::RecordCmdTraceRaysKHR(
    VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height,
    uint32_t depth) {
    auto* args = Alloc<CmdTraceRaysKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pRaygenShaderBindingTable) {
        args->pRaygenShaderBindingTable =
            CopyArray(pRaygenShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pMissShaderBindingTable) {
        args->pMissShaderBindingTable =
            CopyArray(pMissShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pHitShaderBindingTable) {
        args->pHitShaderBindingTable =
            CopyArray(pHitShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pCallableShaderBindingTable) {
        args->pCallableShaderBindingTable =
            CopyArray(pCallableShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->width = width;
    args->height = height;
    args->depth = depth;
    return args;
}

CmdTraceRaysIndirectKHRArgs* CommandRecorder::RecordCmdTraceRaysIndirectKHR(
    VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable,
    const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
    auto* args = Alloc<CmdTraceRaysIndirectKHRArgs>();
    args->commandBuffer = commandBuffer;
    if (pRaygenShaderBindingTable) {
        args->pRaygenShaderBindingTable =
            CopyArray(pRaygenShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pMissShaderBindingTable) {
        args->pMissShaderBindingTable =
            CopyArray(pMissShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pHitShaderBindingTable) {
        args->pHitShaderBindingTable =
            CopyArray(pHitShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    if (pCallableShaderBindingTable) {
        args->pCallableShaderBindingTable =
            CopyArray(pCallableShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
    args->indirectDeviceAddress = indirectDeviceAddress;
    return args;
}

CmdSetRayTracingPipelineStackSizeKHRArgs* CommandRecorder::RecordCmdSetRayTracingPipelineStackSizeKHR(
    VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
    auto* args = Alloc<CmdSetRayTracingPipelineStackSizeKHRArgs>();
    args->commandBuffer = commandBuffer;
    args->pipelineStackSize = pipelineStackSize;
    return args;
}

CmdDrawMeshTasksEXTArgs* CommandRecorder::RecordCmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX,
                                                                    uint32_t groupCountY, uint32_t groupCountZ) {
    auto* args = Alloc<CmdDrawMeshTasksEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->groupCountX = groupCountX;
    args->groupCountY = groupCountY;
    args->groupCountZ = groupCountZ;
    return args;
}

CmdDrawMeshTasksIndirectEXTArgs* CommandRecorder::RecordCmdDrawMeshTasksIndirectEXT(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawMeshTasksIndirectEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->drawCount = drawCount;
    args->stride = stride;
    return args;
}

CmdDrawMeshTasksIndirectCountEXTArgs* CommandRecorder::RecordCmdDrawMeshTasksIndirectCountEXT(
    VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer,
    VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    auto* args = Alloc<CmdDrawMeshTasksIndirectCountEXTArgs>();
    args->commandBuffer = commandBuffer;
    args->buffer = buffer;
    args->offset = offset;
    args->countBuffer = countBuffer;
    args->countBufferOffset = countBufferOffset;
    args->maxDrawCount = maxDrawCount;
    args->stride = stride;
    return args;
}

// NOLINTEND
