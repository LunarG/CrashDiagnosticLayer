/*
 * Copyright (c) 2020-2026 Valve Corporation
 * Copyright (c) 2020-2026 LunarG, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This code was generated by Vulkan Configurator 3.4.2
 */

#pragma once

#include <vector>
#include <string>

#include <vulkan/vulkan.hpp>

struct LayerSettings;

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_semaphores` setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SEMAPHORES_OFF = "off";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SEMAPHORES_ON_CRASH = "on_crash";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_queue_submits` setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_RUNNING = "running";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_PENDING = "pending";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_command_buffers` setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_RUNNING = "running";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_PENDING = "pending";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_ALL = "all";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_commands` setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_RUNNING = "running";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_PENDING = "pending";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_ALL = "all";

// Possible values for `VK_LAYER_LUNARG_crash_diagnostic` layer `dump_shaders` setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_OFF = "off";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ON_CRASH = "on_crash";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ON_BIND = "on_bind";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_ALL = "all";

// Possible values for VK_LAYER_LUNARG_crash_diagnostic layer debug_action setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_MSG = "VK_DBG_LAYER_ACTION_LOG_MSG";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_STDOUT = "VK_DBG_LAYER_ACTION_LOG_STDOUT";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_STDERR = "VK_DBG_LAYER_ACTION_LOG_STDERR";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_DEBUG_OUTPUT = "VK_DBG_LAYER_ACTION_DEBUG_OUTPUT";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_BREAK = "VK_DBG_LAYER_ACTION_BREAK";

// Possible values for VK_LAYER_LUNARG_crash_diagnostic layer message_severity setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_VERBOSE = "verbose";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_INFO = "info";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_WARN = "warn";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_ERROR = "error";

// Possible values for VK_LAYER_LUNARG_crash_diagnostic layer message_api_trace setting:
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_API_TRACE_COMMON = "common";
[[maybe_unused]] static const char* VL_CRASH_DIAGNOSTIC_MESSAGE_API_TRACE_SEMAPHORES = "semaphores";

//Crash Diagnostic Layer is a crash/hang debugging tool that helps determines GPU progress in a Vulkan application.
// ==========================================
// VK_LAYER_LUNARG_crash_diagnostic - 1.4.341 (BETA) (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
// For more information about the layer: https://vulkan.lunarg.com/doc/sdk/latest/windows/crash_diagnostic_layer.html
struct CrashdiagnosticSettingData {
	static const uint32_t VERSION = VK_MAKE_API_VERSION(1, 4, 341, 0);

	// Synchronize commands
	// ------------------------------------------
	// sync_after_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Add pipeline barriers after instrumented commands to help identify whether a
	// Vulkan crash is due to a synchronization issue.
	// VK_KHR_dynamic_rendering usage is required for this feature otherwise Validation layer errors will be generated.
	VkBool32 sync_after_commands = VK_FALSE;

	// Add markers on each Vulkan command
	// ------------------------------------------
	// instrument_all_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Include completion markers around every vulkan command
	// This may allow more accuratute fault locations at the expense of larger command buffers and reduced performance
	VkBool32 instrument_all_commands = VK_FALSE;

	// Crash Dump Output Directory
	// ------------------------------------------
	// output_path (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// The directory where dump files and shader binaries are written.
	std::string output_path = "";

	// Watchdog Timer
	// ------------------------------------------
	// trigger_watchdog_timeout (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// If the application fails to submit new commands within a set time, a crash
	// dump will be created as if the a lost device error was encountered.
	// This setting has sub-settings:
	// - int32_t watchdog_timeout_ms = 30000;
	VkBool32 trigger_watchdog_timeout = VK_TRUE;

	// Watchdog Timeout (ms)
	// ------------------------------------------
	// watchdog_timeout_ms (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Time in milliseconds the application has to submit a new command before
	// creating a crash dump.
	// This setting requires ALL of the following values:
	// - VkBool32 trigger_watchdog_timeout = VK_TRUE;
	int64_t watchdog_timeout_ms = 30000;

	// Dump semaphores
	// ------------------------------------------
	// dump_semaphores (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control Vulkan semaphores reporting in the crash dump.
	std::string dump_semaphores = VL_CRASH_DIAGNOSTIC_DUMP_SEMAPHORES_OFF;

	// Dump queue submissions
	// ------------------------------------------
	// dump_queue_submits (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which queue submissions are included in the crash dump.
	std::string dump_queue_submits = VL_CRASH_DIAGNOSTIC_DUMP_QUEUE_SUBMITS_RUNNING;

	// Dump command buffers
	// ------------------------------------------
	// dump_command_buffers (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which command buffers are included in the crash crashdump.
	std::string dump_command_buffers = VL_CRASH_DIAGNOSTIC_DUMP_COMMAND_BUFFERS_RUNNING;

	// Dump commands
	// ------------------------------------------
	// dump_commands (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control which commands are included in the crash dump.
	std::string dump_commands = VL_CRASH_DIAGNOSTIC_DUMP_COMMANDS_RUNNING;

	// Dump shaders
	// ------------------------------------------
	// dump_shaders (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Control of shader dumping.
	std::string dump_shaders = VL_CRASH_DIAGNOSTIC_DUMP_SHADERS_OFF;

	// Debug Action
	// ------------------------------------------
	// debug_action (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Specifies what action is to be taken when a layer reports log messages
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> debug_action = {VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_LOG_STDOUT, VL_CRASH_DIAGNOSTIC_DEBUG_ACTION_VK_DBG_LAYER_ACTION_DEBUG_OUTPUT};

	// Log Filename
	// ------------------------------------------
	// log_file (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Specifies the output filename
	std::string log_file = "stdout";

	// Log Message Severity
	// ------------------------------------------
	// message_severity (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)
	// Comma-delineated list of options specifying the types of messages to be
	// reported
	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> message_severity = {VL_CRASH_DIAGNOSTIC_MESSAGE_SEVERITY_ERROR};

	// Log API trace
	// ------------------------------------------
	// message_api_trace (WINDOWS_X86, WINDOWS_ARM, LINUX, ANDROID)

	// This setting can list multiple values using the "," (comma) separator.
	std::vector<std::string> message_api_trace = {};

private:
	friend struct LayerSettings;

	const char* output_path_info = nullptr;
	const char* dump_semaphores_info = nullptr;
	const char* dump_queue_submits_info = nullptr;
	const char* dump_command_buffers_info = nullptr;
	const char* dump_commands_info = nullptr;
	const char* dump_shaders_info = nullptr;
	std::vector<const char*> debug_action_info;
	const char* log_file_info = nullptr;
	std::vector<const char*> message_severity_info;
	std::vector<const char*> message_api_trace_info;

	void init() {
		this->output_path_info = this->output_path.c_str();
		this->dump_semaphores_info = this->dump_semaphores.c_str();
		this->dump_queue_submits_info = this->dump_queue_submits.c_str();
		this->dump_command_buffers_info = this->dump_command_buffers.c_str();
		this->dump_commands_info = this->dump_commands.c_str();
		this->dump_shaders_info = this->dump_shaders.c_str();

		this->debug_action_info.resize(this->debug_action.size());
		for (std::size_t i = 0, n = debug_action_info.size(); i < n; ++i) {
			this->debug_action_info[i] = this->debug_action[i].c_str();
		}
		this->log_file_info = this->log_file.c_str();
		this->message_severity_info.resize(this->message_severity.size());
		for (std::size_t i = 0, n = message_severity_info.size(); i < n; ++i) {
			this->message_severity_info[i] = this->message_severity[i].c_str();
		}
		this->message_api_trace_info.resize(this->message_api_trace.size());
		for (std::size_t i = 0, n = message_api_trace_info.size(); i < n; ++i) {
			this->message_api_trace_info[i] = this->message_api_trace[i].c_str();
		}
	}
};

// `LayerSettings` allows initializing layer settings from Vulkan application code.
struct LayerSettings {
	CrashdiagnosticSettingData crash_diagnostic;

	// Use for VkLayerSettingsCreateInfoEXT `settingCount` and `pSettings` argument
	// Provided by VK_EXT_layer_settings
	// typedef struct VkLayerSettingsCreateInfoEXT {
	// 	VkStructureType             sType;
	// 	const void*                 pNext;
	// 	uint32_t                    settingCount;
	// 	const VkLayerSettingEXT*    pSettings;
	// } VkLayerSettingsCreateInfoEXT;
	std::vector<vk::LayerSettingEXT> info() {
		this->crash_diagnostic.init();

		std::vector<vk::LayerSettingEXT> init{
			{"VK_LAYER_LUNARG_crash_diagnostic", "sync_after_commands", vk::LayerSettingTypeEXT::eBool32, 1, &this->crash_diagnostic.sync_after_commands},
			{"VK_LAYER_LUNARG_crash_diagnostic", "instrument_all_commands", vk::LayerSettingTypeEXT::eBool32, 1, &this->crash_diagnostic.instrument_all_commands},
			{"VK_LAYER_LUNARG_crash_diagnostic", "output_path", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.output_path_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "trigger_watchdog_timeout", vk::LayerSettingTypeEXT::eBool32, 1, &this->crash_diagnostic.trigger_watchdog_timeout},
			{"VK_LAYER_LUNARG_crash_diagnostic", "watchdog_timeout_ms", vk::LayerSettingTypeEXT::eInt64, 1, &this->crash_diagnostic.watchdog_timeout_ms},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_semaphores", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.dump_semaphores_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_queue_submits", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.dump_queue_submits_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_command_buffers", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.dump_command_buffers_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_commands", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.dump_commands_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "dump_shaders", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.dump_shaders_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "debug_action", vk::LayerSettingTypeEXT::eString, static_cast<uint32_t>(this->crash_diagnostic.debug_action_info.size()), this->crash_diagnostic.debug_action_info.empty() ? nullptr : &this->crash_diagnostic.debug_action_info[0]},
			{"VK_LAYER_LUNARG_crash_diagnostic", "log_file", vk::LayerSettingTypeEXT::eString, 1, &this->crash_diagnostic.log_file_info},
			{"VK_LAYER_LUNARG_crash_diagnostic", "message_severity", vk::LayerSettingTypeEXT::eString, static_cast<uint32_t>(this->crash_diagnostic.message_severity_info.size()), this->crash_diagnostic.message_severity_info.empty() ? nullptr : &this->crash_diagnostic.message_severity_info[0]},
			{"VK_LAYER_LUNARG_crash_diagnostic", "message_api_trace", vk::LayerSettingTypeEXT::eString, static_cast<uint32_t>(this->crash_diagnostic.message_api_trace_info.size()), this->crash_diagnostic.message_api_trace_info.empty() ? nullptr : &this->crash_diagnostic.message_api_trace_info[0]},
		};
		return init;
	};
};

